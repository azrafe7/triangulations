// Generated by Haxe 3.4.1
(function ($global) { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.i32ToFloat = function(i) {
	var sign = 1 - (i >>> 31 << 1);
	var exp = i >>> 23 & 255;
	var sig = i & 8388607;
	if(sig == 0 && exp == 0) {
		return 0.0;
	}
	return sign * (1 + Math.pow(2,-23) * sig) * Math.pow(2,exp - 127);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	if(f == 0) {
		return 0;
	}
	var af = f < 0 ? -f : f;
	var exp = Math.floor(Math.log(af) / 0.6931471805599453);
	if(exp < -127) {
		exp = -127;
	} else if(exp > 128) {
		exp = 128;
	}
	var sig = Math.round((af / Math.pow(2,exp) - 1) * 8388608);
	if(sig == 8388608 && exp < 128) {
		sig = 0;
		++exp;
	}
	return (f < 0 ? -2147483648 : 0) | exp + 127 << 23 | sig;
};
var htmlHelper_tools_CSSEnterFrame = function() {
	this.s = window.document.createElement("style");
	this.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
	window.document.getElementsByTagName("head")[0].appendChild(this.s);
	this.s.animation = "spin 1s linear infinite";
	this.loop(60);
};
htmlHelper_tools_CSSEnterFrame.__name__ = true;
htmlHelper_tools_CSSEnterFrame.prototype = {
	destroy: function() {
		window.document.getElementsByTagName("head")[0].removeChild(this.s);
		window.requestAnimationFrame(null);
		this.s.innerHTML = "";
		this.s.animation = "";
		this.s = null;
	}
	,loop: function(tim) {
		window.requestAnimationFrame($bind(this,this.loop));
		if(this.onFrame != null) {
			this.onFrame();
		}
		return true;
	}
	,__class__: htmlHelper_tools_CSSEnterFrame
};
var htmlHelper_webgl_WebGLSetup = function(width_,height_,autoChild) {
	if(autoChild == null) {
		autoChild = true;
	}
	this.colors = [];
	this.indices = [];
	this.vertices = [];
	this.matrix32Array = new Float32Array([1.0,0.0,0.0,0.0,0.0,1.1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]);
	this.modelViewProjection = new khaMath_Matrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	this.bgAlpha = 1.;
	this.bgBlue = 1.;
	this.bgGreen = 1.;
	this.bgRed = 1.;
	this.width = width_;
	this.height = height_;
	this.canvas = window.document.createElement("canvas");
	this.canvas.width = this.width;
	this.canvas.height = this.height;
	var dom = this.canvas;
	var style = dom.style;
	style.paddingLeft = "0px";
	style.paddingTop = "0px";
	style.left = Std.string(0 + "px");
	style.top = Std.string(0 + "px");
	style.position = "absolute";
	if(autoChild) {
		window.document.body.appendChild(this.canvas);
	}
	this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(this.canvas,null);
};
htmlHelper_webgl_WebGLSetup.__name__ = true;
htmlHelper_webgl_WebGLSetup.createVertexShader = function(gl,str) {
	var vertexShader = gl.createShader(35633);
	gl.shaderSource(vertexShader,str);
	gl.compileShader(vertexShader);
	return vertexShader;
};
htmlHelper_webgl_WebGLSetup.createFragmentShader = function(gl,str) {
	var fragmentShader = gl.createShader(35632);
	gl.shaderSource(fragmentShader,str);
	gl.compileShader(fragmentShader);
	return fragmentShader;
};
htmlHelper_webgl_WebGLSetup.createShaderProgram = function(gl,vertex,fragment) {
	var program = gl.createProgram();
	gl.attachShader(program,vertex);
	gl.attachShader(program,fragment);
	gl.linkProgram(program);
	gl.useProgram(program);
	return program;
};
htmlHelper_webgl_WebGLSetup.uploadTriangleDataToBuffers = function(gl,program,vertices,indices) {
	var vertexBuffer = gl.createBuffer();
	gl.bindBuffer(34962,vertexBuffer);
	gl.bufferData(34962,new Float32Array(vertices),35044);
	var position = gl.getAttribLocation(program,"pos");
	gl.vertexAttribPointer(position,3,5126,false,0,0);
	gl.enableVertexAttribArray(position);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.uploadDataToBuffers = function(gl,program,vertices,colors,indices) {
	var vertexBuffer = gl.createBuffer();
	gl.bindBuffer(34962,vertexBuffer);
	gl.bufferData(34962,new Float32Array(vertices),35044);
	var position = gl.getAttribLocation(program,"pos");
	gl.vertexAttribPointer(position,3,5126,false,0,0);
	gl.enableVertexAttribArray(position);
	gl.bindBuffer(34962,null);
	var colorBuffer = gl.createBuffer();
	gl.bindBuffer(34962,colorBuffer);
	gl.bufferData(34962,new Float32Array(colors),35044);
	var col = gl.getAttribLocation(program,"color");
	gl.vertexAttribPointer(col,4,5126,false,0,0);
	gl.enableVertexAttribArray(col);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.uploadFloatToBuffers = function(gl,program,name,att,arr) {
	var floatBuffer = gl.createBuffer();
	gl.bindBuffer(34962,floatBuffer);
	gl.bufferData(34962,new Float32Array(arr),35044);
	var flo = gl.getAttribLocation(program,name);
	gl.vertexAttribPointer(flo,att,5126,false,0,0);
	gl.enableVertexAttribArray(flo);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.uploadSimpleColorToBuffers = function(gl,program,colors) {
	var colorBuffer = gl.createBuffer();
	gl.bindBuffer(34962,colorBuffer);
	gl.bufferData(34962,new Float32Array(colors),35044);
	var col = gl.getAttribLocation(program,"color");
	gl.vertexAttribPointer(col,4,5126,false,0,0);
	gl.enableVertexAttribArray(col);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.toRGB = function($int) {
	return { r : ($int >> 16 & 255) / 255, g : ($int >> 8 & 255) / 255, b : ($int & 255) / 255};
};
htmlHelper_webgl_WebGLSetup.transferM4_arr32 = function(arr,m) {
	arr.set([m._00,m._10,m._20,m._30,m._01,m._11,m._21,m._31,m._02,m._12,m._22,m._32,m._03,m._13,m._23,m._33]);
};
htmlHelper_webgl_WebGLSetup.ident = function() {
	return [1.0,0.0,0.0,0.0,0.0,1.1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0];
};
htmlHelper_webgl_WebGLSetup.prototype = {
	setupProgram: function(vertexString,fragmentString) {
		var gl = this.gl;
		var vertexShader = gl.createShader(35633);
		gl.shaderSource(vertexShader,vertexString);
		gl.compileShader(vertexShader);
		var vertex = vertexShader;
		var gl1 = this.gl;
		var fragmentShader = gl1.createShader(35632);
		gl1.shaderSource(fragmentShader,fragmentString);
		gl1.compileShader(fragmentShader);
		var fragment = fragmentShader;
		var gl2 = this.gl;
		var program = gl2.createProgram();
		gl2.attachShader(program,vertex);
		gl2.attachShader(program,fragment);
		gl2.linkProgram(program);
		gl2.useProgram(program);
		this.program = program;
		return this.program;
	}
	,clearVerticesAndColors: function() {
		this.vertices = [];
		this.indices = [];
		this.colors = [];
	}
	,setVerticesAndColors: function(vertices,triangleColors) {
		var rgb;
		var colorAlpha = 1.0;
		var _g1 = 0;
		var _g = vertices.length / 3 | 0;
		while(_g1 < _g) {
			var i = _g1++;
			var $int = triangleColors[i];
			rgb = { r : ($int >> 16 & 255) / 255, g : ($int >> 8 & 255) / 255, b : ($int & 255) / 255};
			var _g2 = 0;
			while(_g2 < 3) {
				var j = _g2++;
				this.colors.push(rgb.r);
				this.colors.push(rgb.g);
				this.colors.push(rgb.b);
				this.colors.push(colorAlpha);
			}
			this.indices.push(i);
		}
		var gl = this.gl;
		var program = this.program;
		var colors = this.colors;
		var indices = this.indices;
		var vertexBuffer = gl.createBuffer();
		gl.bindBuffer(34962,vertexBuffer);
		gl.bufferData(34962,new Float32Array(vertices),35044);
		var position = gl.getAttribLocation(program,"pos");
		gl.vertexAttribPointer(position,3,5126,false,0,0);
		gl.enableVertexAttribArray(position);
		gl.bindBuffer(34962,null);
		var colorBuffer = gl.createBuffer();
		gl.bindBuffer(34962,colorBuffer);
		gl.bufferData(34962,new Float32Array(colors),35044);
		var col = gl.getAttribLocation(program,"color");
		gl.vertexAttribPointer(col,4,5126,false,0,0);
		gl.enableVertexAttribArray(col);
		gl.bindBuffer(34962,null);
	}
	,render: function() {
		this.gl.clearColor(this.bgRed,this.bgGreen,this.bgBlue,this.bgAlpha);
		this.gl.enable(2884);
		this.gl.cullFace(1029);
		this.gl.clear(16384);
		this.gl.viewport(0,0,this.canvas.width,this.canvas.height);
		var modelViewProjectionID = this.gl.getUniformLocation(this.program,"modelViewProjection");
		var m = this.modelViewProjection;
		this.matrix32Array.set([m._00,m._10,m._20,m._30,m._01,m._11,m._21,m._31,m._02,m._12,m._22,m._32,m._03,m._13,m._23,m._33]);
		this.gl.uniformMatrix4fv(modelViewProjectionID,false,this.matrix32Array);
		this.gl.drawArrays(4,0,this.indices.length);
	}
	,__class__: htmlHelper_webgl_WebGLSetup
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html__$CanvasElement_CanvasUtil = function() { };
js_html__$CanvasElement_CanvasUtil.__name__ = true;
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var _g = 0;
	var _g1 = ["webgl","experimental-webgl"];
	while(_g < _g1.length) {
		var name = _g1[_g];
		++_g;
		var ctx = canvas.getContext(name,attribs);
		if(ctx != null) {
			return ctx;
		}
	}
	return null;
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
js_html_compat_ArrayBuffer.__name__ = true;
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_Float32Array = function() { };
js_html_compat_Float32Array.__name__ = true;
js_html_compat_Float32Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		var _g2 = [];
		var _g21 = 0;
		var _g11 = arr.length << 2;
		while(_g21 < _g11) {
			var i1 = _g21++;
			_g2.push(0);
		}
		arr.buffer = new js_html_compat_ArrayBuffer(_g2);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset >> 2;
		}
		arr = [];
		var _g12 = 0;
		var _g3 = length;
		while(_g12 < _g3) {
			var i2 = _g12++;
			var val = buffer.a[offset++] | buffer.a[offset++] << 8 | buffer.a[offset++] << 16 | buffer.a[offset++] << 24;
			arr.push(haxe_io_FPHelper.i32ToFloat(val));
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		var buffer1 = [];
		var _g4 = 0;
		while(_g4 < arr.length) {
			var f = arr[_g4];
			++_g4;
			var i3 = haxe_io_FPHelper.floatToI32(f);
			buffer1.push(i3 & 255);
			buffer1.push(i3 >> 8 & 255);
			buffer1.push(i3 >> 16 & 255);
			buffer1.push(i3 >>> 24);
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(buffer1);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Float32Array._subarray;
	arr.set = js_html_compat_Float32Array._set;
	return arr;
};
js_html_compat_Float32Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Float32Array._subarray = function(start,end) {
	var a = js_html_compat_Float32Array._new(this.slice(start,end));
	a.byteOffset = start * 4;
	return a;
};
var js_html_compat_Uint8Array = function() { };
js_html_compat_Uint8Array.__name__ = true;
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
var justTriangles_Bezier = function() { };
justTriangles_Bezier.__name__ = true;
justTriangles_Bezier.quadratic = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,2) * arr[0].x + 2 * u * t * arr[1].x + Math.pow(t,2) * arr[2].x, y : Math.pow(u1,2) * arr[0].y + 2 * u1 * t * arr[1].y + Math.pow(t,2) * arr[2].y};
};
justTriangles_Bezier._quadratic = function(t,startPoint,controlPoint,endPoint) {
	var u = 1 - t;
	return Math.pow(u,2) * startPoint + 2 * u * t * controlPoint + Math.pow(t,2) * endPoint;
};
justTriangles_Bezier.cubic = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,3) * arr[0].x + 3 * Math.pow(u,2) * t * arr[1].x + 3 * u * Math.pow(t,2) * arr[2].x + Math.pow(t,3) * arr[3].x, y : Math.pow(u1,3) * arr[0].y + 3 * Math.pow(u1,2) * t * arr[1].y + 3 * u1 * Math.pow(t,2) * arr[2].y + Math.pow(t,3) * arr[3].y};
};
justTriangles_Bezier._cubic = function(t,startPoint,controlPoint1,controlPoint2,endPoint) {
	var u = 1 - t;
	return Math.pow(u,3) * startPoint + 3 * Math.pow(u,2) * t * controlPoint1 + 3 * u * Math.pow(t,2) * controlPoint2 + Math.pow(t,3) * endPoint;
};
var justTriangles_Draw = function() {
	this.thickRatio = 1024;
};
justTriangles_Draw.__name__ = true;
justTriangles_Draw.set_thick = function(val) {
	if(val < 0) {
		val = 0.00001;
	}
	justTriangles_Draw.thickness = val / 1024;
	return justTriangles_Draw.thickness;
};
justTriangles_Draw.get_thick = function() {
	return justTriangles_Draw.thickness;
};
justTriangles_Draw.packManFill = function(id,dx,dy,radius,start,dA) {
	var centre = { x : dx, y : dy};
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / 60;
	var sides = Math.round(60);
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	var p1 = p;
	justTriangles_Draw.q0 = p1[0];
	justTriangles_Draw.q1 = p1[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	var draw1 = draw;
	var _g1 = 1;
	var _g = p1.length - 2;
	while(_g1 < _g) {
		var i2 = _g1++;
		draw1.rebuildAsPoly(p1[i2 + 2]);
		var q31 = draw1.p3;
		justTriangles_Draw.drawTri(id,false,justTriangles_Draw.q0,q31,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q31;
	}
};
justTriangles_Draw.roundedRectangleOutline = function(id,dx,dy,hi,wid,radiusSmall,radius) {
	var dia = radius * 2;
	var circleSides2 = 120;
	var dy1 = dy + hi;
	var start = -Math.PI - Math.PI / 2;
	var dA = Math.PI / 2;
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / circleSides2;
	var sides = Math.round(circleSides2);
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radiusSmall * Math.cos(nextAngle), y : dy1 + radiusSmall * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radiusSmall * Math.cos(nextAngle), y : dy1 + radiusSmall * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	var lb = p;
	var dx1 = dx + wid;
	var dy2 = dy + hi;
	var dA1 = Math.PI / 2;
	var p1 = [];
	var angle1 = 0;
	var angleInc1 = Math.PI * 2 / circleSides2;
	var sides1 = Math.round(circleSides2);
	var nextAngle1;
	if(dA1 < 0) {
		var i2 = -1;
		while(true) {
			angle1 = i2 * angleInc1;
			--i2;
			nextAngle1 = angle1;
			if(angle1 <= dA1) {
				break;
			}
			p1.push({ x : dx1 + radiusSmall * Math.cos(nextAngle1), y : dy2 + radiusSmall * Math.sin(nextAngle1)});
		}
	} else {
		var i3 = -1;
		while(true) {
			angle1 = i3 * angleInc1;
			++i3;
			nextAngle1 = angle1;
			if(angle1 >= dA1 + angleInc1) {
				break;
			}
			p1.push({ x : dx1 + radiusSmall * Math.cos(nextAngle1), y : dy2 + radiusSmall * Math.sin(nextAngle1)});
		}
	}
	p1.reverse();
	var rb = p1;
	var dx2 = dx + wid;
	var start1 = -Math.PI / 2;
	var dA2 = Math.PI / 2;
	var p2 = [];
	var angle2 = 0;
	var angleInc2 = Math.PI * 2 / circleSides2;
	var sides2 = Math.round(circleSides2);
	var nextAngle2;
	if(dA2 < 0) {
		var i4 = -1;
		while(true) {
			angle2 = i4 * angleInc2;
			--i4;
			nextAngle2 = angle2 + start1;
			if(angle2 <= dA2) {
				break;
			}
			p2.push({ x : dx2 + radiusSmall * Math.cos(nextAngle2), y : dy + radiusSmall * Math.sin(nextAngle2)});
		}
	} else {
		var i5 = -1;
		while(true) {
			angle2 = i5 * angleInc2;
			++i5;
			nextAngle2 = angle2 + start1;
			if(angle2 >= dA2 + angleInc2) {
				break;
			}
			p2.push({ x : dx2 + radiusSmall * Math.cos(nextAngle2), y : dy + radiusSmall * Math.sin(nextAngle2)});
		}
	}
	p2.reverse();
	var rt = p2;
	var start2 = -Math.PI;
	var dA3 = Math.PI / 2;
	var p3 = [];
	var angle3 = 0;
	var angleInc3 = Math.PI * 2 / circleSides2;
	var sides3 = Math.round(circleSides2);
	var nextAngle3;
	if(dA3 < 0) {
		var i6 = -1;
		while(true) {
			angle3 = i6 * angleInc3;
			--i6;
			nextAngle3 = angle3 + start2;
			if(angle3 <= dA3) {
				break;
			}
			p3.push({ x : dx + radiusSmall * Math.cos(nextAngle3), y : dy + radiusSmall * Math.sin(nextAngle3)});
		}
	} else {
		var i7 = -1;
		while(true) {
			angle3 = i7 * angleInc3;
			++i7;
			nextAngle3 = angle3 + start2;
			if(angle3 >= dA3 + angleInc3) {
				break;
			}
			p3.push({ x : dx + radiusSmall * Math.cos(nextAngle3), y : dy + radiusSmall * Math.sin(nextAngle3)});
		}
	}
	p3.reverse();
	var lt = p3;
	var p0_ = { x : dx, y : dy - radius};
	var p1_ = { x : dx + wid, y : dy - radius};
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = dia;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q3 = { x : draw.p3.x, y : draw.p3.y};
	var q4 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q3,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q3,q4,justTriangles_Draw.colorId);
	var p0_1 = { x : dx + radius + wid, y : dy};
	var p1_1 = { x : dx + radius + wid, y : dy + hi};
	var draw1 = new justTriangles_Draw();
	draw1.p0 = p1_1;
	draw1.p1 = p0_1;
	draw1.halfA = Math.PI / 2;
	draw1._thick = dia;
	draw1.beta = Math.PI / 2 - draw1.halfA;
	draw1.r = draw1._thick / 2 * Math.cos(draw1.beta);
	draw1._theta = draw1.theta(draw1.p0,draw1.p1);
	if(draw1._theta > 0) {
		if(draw1.halfA < 0) {
			draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
			draw1.angle1 = draw1._theta - draw1.halfA;
		} else {
			draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
			draw1.angle2 = draw1._theta + draw1.halfA;
		}
	} else if(draw1.halfA > 0) {
		draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
		draw1.angle2 = draw1._theta + draw1.halfA;
	} else {
		draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
		draw1.angle1 = draw1._theta - draw1.halfA;
	}
	if(draw1.p3old != null) {
		draw1.p3old2 = draw1.p3old;
	}
	if(draw1.p4old != null) {
		draw1.p4old2 = draw1.p4old;
	}
	if(draw1.p3 != null) {
		draw1.p3old = draw1.p3;
	}
	if(draw1.p4 != null) {
		draw1.p4old = draw1.p4;
	}
	draw1.p3 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle1), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle1)};
	draw1.p4 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle2), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle2)};
	var q01 = { x : draw1.p3.x, y : draw1.p3.y};
	var q11 = { x : draw1.p4.x, y : draw1.p4.y};
	draw1.p0 = p0_1;
	draw1.p1 = p1_1;
	draw1._theta = draw1.theta(draw1.p0,draw1.p1);
	if(draw1._theta > 0) {
		if(draw1.halfA < 0) {
			draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
			draw1.angle1 = draw1._theta - draw1.halfA;
		} else {
			draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
			draw1.angle2 = draw1._theta + draw1.halfA;
		}
	} else if(draw1.halfA > 0) {
		draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
		draw1.angle2 = draw1._theta + draw1.halfA;
	} else {
		draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
		draw1.angle1 = draw1._theta - draw1.halfA;
	}
	if(draw1.p3old != null) {
		draw1.p3old2 = draw1.p3old;
	}
	if(draw1.p4old != null) {
		draw1.p4old2 = draw1.p4old;
	}
	if(draw1.p3 != null) {
		draw1.p3old = draw1.p3;
	}
	if(draw1.p4 != null) {
		draw1.p4old = draw1.p4;
	}
	draw1.p3 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle1), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle1)};
	draw1.p4 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle2), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle2)};
	var q31 = { x : draw1.p3.x, y : draw1.p3.y};
	var q41 = { x : draw1.p4.x, y : draw1.p4.y};
	justTriangles_Draw.drawTri(id,true,q01,q31,q11,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q01,q31,q41,justTriangles_Draw.colorId);
	var p0_2 = { x : dx, y : dy + radius + hi};
	var p1_2 = { x : dx + wid, y : dy + radius + hi};
	var draw2 = new justTriangles_Draw();
	draw2.p0 = p1_2;
	draw2.p1 = p0_2;
	draw2.halfA = Math.PI / 2;
	draw2._thick = dia;
	draw2.beta = Math.PI / 2 - draw2.halfA;
	draw2.r = draw2._thick / 2 * Math.cos(draw2.beta);
	draw2._theta = draw2.theta(draw2.p0,draw2.p1);
	if(draw2._theta > 0) {
		if(draw2.halfA < 0) {
			draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
			draw2.angle1 = draw2._theta - draw2.halfA;
		} else {
			draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
			draw2.angle2 = draw2._theta + draw2.halfA;
		}
	} else if(draw2.halfA > 0) {
		draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
		draw2.angle2 = draw2._theta + draw2.halfA;
	} else {
		draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
		draw2.angle1 = draw2._theta - draw2.halfA;
	}
	if(draw2.p3old != null) {
		draw2.p3old2 = draw2.p3old;
	}
	if(draw2.p4old != null) {
		draw2.p4old2 = draw2.p4old;
	}
	if(draw2.p3 != null) {
		draw2.p3old = draw2.p3;
	}
	if(draw2.p4 != null) {
		draw2.p4old = draw2.p4;
	}
	draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
	draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
	var q02 = { x : draw2.p3.x, y : draw2.p3.y};
	var q12 = { x : draw2.p4.x, y : draw2.p4.y};
	draw2.p0 = p0_2;
	draw2.p1 = p1_2;
	draw2._theta = draw2.theta(draw2.p0,draw2.p1);
	if(draw2._theta > 0) {
		if(draw2.halfA < 0) {
			draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
			draw2.angle1 = draw2._theta - draw2.halfA;
		} else {
			draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
			draw2.angle2 = draw2._theta + draw2.halfA;
		}
	} else if(draw2.halfA > 0) {
		draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
		draw2.angle2 = draw2._theta + draw2.halfA;
	} else {
		draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
		draw2.angle1 = draw2._theta - draw2.halfA;
	}
	if(draw2.p3old != null) {
		draw2.p3old2 = draw2.p3old;
	}
	if(draw2.p4old != null) {
		draw2.p4old2 = draw2.p4old;
	}
	if(draw2.p3 != null) {
		draw2.p3old = draw2.p3;
	}
	if(draw2.p4 != null) {
		draw2.p4old = draw2.p4;
	}
	draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
	draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
	var q32 = { x : draw2.p3.x, y : draw2.p3.y};
	var q42 = { x : draw2.p4.x, y : draw2.p4.y};
	justTriangles_Draw.drawTri(id,true,q02,q32,q12,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q02,q32,q42,justTriangles_Draw.colorId);
	var p0_3 = { x : dx - radius, y : dy};
	var p1_3 = { x : dx - radius, y : dy + hi};
	var draw3 = new justTriangles_Draw();
	draw3.p0 = p1_3;
	draw3.p1 = p0_3;
	draw3.halfA = Math.PI / 2;
	draw3._thick = dia;
	draw3.beta = Math.PI / 2 - draw3.halfA;
	draw3.r = draw3._thick / 2 * Math.cos(draw3.beta);
	draw3._theta = draw3.theta(draw3.p0,draw3.p1);
	if(draw3._theta > 0) {
		if(draw3.halfA < 0) {
			draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
			draw3.angle1 = draw3._theta - draw3.halfA;
		} else {
			draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
			draw3.angle2 = draw3._theta + draw3.halfA;
		}
	} else if(draw3.halfA > 0) {
		draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
		draw3.angle2 = draw3._theta + draw3.halfA;
	} else {
		draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
		draw3.angle1 = draw3._theta - draw3.halfA;
	}
	if(draw3.p3old != null) {
		draw3.p3old2 = draw3.p3old;
	}
	if(draw3.p4old != null) {
		draw3.p4old2 = draw3.p4old;
	}
	if(draw3.p3 != null) {
		draw3.p3old = draw3.p3;
	}
	if(draw3.p4 != null) {
		draw3.p4old = draw3.p4;
	}
	draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
	draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
	var q03 = { x : draw3.p3.x, y : draw3.p3.y};
	var q13 = { x : draw3.p4.x, y : draw3.p4.y};
	draw3.p0 = p0_3;
	draw3.p1 = p1_3;
	draw3._theta = draw3.theta(draw3.p0,draw3.p1);
	if(draw3._theta > 0) {
		if(draw3.halfA < 0) {
			draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
			draw3.angle1 = draw3._theta - draw3.halfA;
		} else {
			draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
			draw3.angle2 = draw3._theta + draw3.halfA;
		}
	} else if(draw3.halfA > 0) {
		draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
		draw3.angle2 = draw3._theta + draw3.halfA;
	} else {
		draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
		draw3.angle1 = draw3._theta - draw3.halfA;
	}
	if(draw3.p3old != null) {
		draw3.p3old2 = draw3.p3old;
	}
	if(draw3.p4old != null) {
		draw3.p4old2 = draw3.p4old;
	}
	if(draw3.p3 != null) {
		draw3.p3old = draw3.p3;
	}
	if(draw3.p4 != null) {
		draw3.p4old = draw3.p4;
	}
	draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
	draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
	var q33 = { x : draw3.p3.x, y : draw3.p3.y};
	var q43 = { x : draw3.p4.x, y : draw3.p4.y};
	justTriangles_Draw.drawTri(id,true,q03,q33,q13,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q03,q33,q43,justTriangles_Draw.colorId);
	var centre = { x : dx, y : dy + hi};
	justTriangles_Draw.q0 = lb[0];
	justTriangles_Draw.q1 = lb[0];
	var draw4 = new justTriangles_Draw();
	draw4.create2Lines(lb[0],lb[1],lb[2],justTriangles_Draw.thickness);
	var q34 = draw4.p3;
	var q44 = draw4.p4;
	justTriangles_Draw.q0 = q34;
	justTriangles_Draw.q1 = q44;
	var draw5 = draw4;
	var _g1 = 1;
	var _g = lb.length - 2;
	while(_g1 < _g) {
		var i8 = _g1++;
		draw5.rebuildAsPoly(lb[i8 + 2]);
		var q35 = draw5.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q35,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q35;
	}
	var centre1 = { x : dx + wid, y : dy + hi};
	justTriangles_Draw.q0 = rb[0];
	justTriangles_Draw.q1 = rb[0];
	var draw6 = new justTriangles_Draw();
	draw6.create2Lines(rb[0],rb[1],rb[2],justTriangles_Draw.thickness);
	var q36 = draw6.p3;
	var q45 = draw6.p4;
	justTriangles_Draw.q0 = q36;
	justTriangles_Draw.q1 = q45;
	var draw7 = draw6;
	var _g11 = 1;
	var _g2 = rb.length - 2;
	while(_g11 < _g2) {
		var i9 = _g11++;
		draw7.rebuildAsPoly(rb[i9 + 2]);
		var q37 = draw7.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q37,centre1,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q37;
	}
	var centre2 = { x : dx + wid, y : dy};
	justTriangles_Draw.q0 = rt[0];
	justTriangles_Draw.q1 = rt[0];
	var draw8 = new justTriangles_Draw();
	draw8.create2Lines(rt[0],rt[1],rt[2],justTriangles_Draw.thickness);
	var q38 = draw8.p3;
	var q46 = draw8.p4;
	justTriangles_Draw.q0 = q38;
	justTriangles_Draw.q1 = q46;
	var draw9 = draw8;
	var _g12 = 1;
	var _g3 = rt.length - 2;
	while(_g12 < _g3) {
		var i10 = _g12++;
		draw9.rebuildAsPoly(rt[i10 + 2]);
		var q39 = draw9.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q39,centre2,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q39;
	}
	var centre3 = { x : dx, y : dy};
	justTriangles_Draw.q0 = lt[0];
	justTriangles_Draw.q1 = lt[0];
	var draw10 = new justTriangles_Draw();
	draw10.create2Lines(lt[0],lt[1],lt[2],justTriangles_Draw.thickness);
	var q310 = draw10.p3;
	var q47 = draw10.p4;
	justTriangles_Draw.q0 = q310;
	justTriangles_Draw.q1 = q47;
	var draw11 = draw10;
	var _g13 = 1;
	var _g4 = lt.length - 2;
	while(_g13 < _g4) {
		var i11 = _g13++;
		draw11.rebuildAsPoly(lt[i11 + 2]);
		var q311 = draw11.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q311,centre3,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q311;
	}
};
justTriangles_Draw.beginLine = function(id,p0_,p1_,thick) {
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var oldThickness = justTriangles_Draw.thickness;
	justTriangles_Draw.thickness = thick / 2;
	var temp = draw.angle1;
	var dx = p0_.x;
	var dy = p0_.y;
	var radius = thick / 4;
	var dA = Math.PI;
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / 24;
	var sides = Math.round(24);
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + temp;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + temp;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	var p1 = p;
	justTriangles_Draw.q0 = p1[0];
	justTriangles_Draw.q1 = p1[0];
	var draw1 = new justTriangles_Draw();
	draw1.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
	var q3 = draw1.p3;
	var q4 = draw1.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	var draw2 = draw1;
	var _g1 = 1;
	var _g = p1.length - 2;
	while(_g1 < _g) {
		var i2 = _g1++;
		draw2.rebuildAsPoly(p1[i2 + 2]);
		var q31 = draw2.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p0_,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q31;
	}
	justTriangles_Draw.thickness = oldThickness;
	var q32 = { x : draw.p3.x, y : draw.p3.y};
	var q41 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q32,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q32,q41,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.endLine = function(id,p0_,p1_,thick) {
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var oldThickness = justTriangles_Draw.thickness;
	justTriangles_Draw.thickness = thick / 2;
	var temp = draw.angle1 + Math.PI;
	var dx = p1_.x;
	var dy = p1_.y;
	var radius = thick / 4;
	var dA = Math.PI;
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / 24;
	var sides = Math.round(24);
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + temp;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + temp;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	var p1 = p;
	justTriangles_Draw.q0 = p1[0];
	justTriangles_Draw.q1 = p1[0];
	var draw1 = new justTriangles_Draw();
	draw1.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
	var q3 = draw1.p3;
	var q4 = draw1.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	var draw2 = draw1;
	var _g1 = 1;
	var _g = p1.length - 2;
	while(_g1 < _g) {
		var i2 = _g1++;
		draw2.rebuildAsPoly(p1[i2 + 2]);
		var q31 = draw2.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p1_,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q31;
	}
	justTriangles_Draw.thickness = oldThickness;
	var q32 = { x : draw.p3.x, y : draw.p3.y};
	var q41 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q32,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q32,q41,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.isolatedLine = function(id,p0_,p1_,thick,curveEnds) {
	if(curveEnds == null) {
		curveEnds = false;
	}
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	if(curveEnds) {
		var oldThickness = justTriangles_Draw.thickness;
		justTriangles_Draw.thickness = thick / 2;
		var temp = draw.angle1;
		var dx = p0_.x;
		var dy = p0_.y;
		var radius = thick / 4;
		var dA = Math.PI;
		var p = [];
		var angle = 0;
		var angleInc = Math.PI * 2 / 24;
		var sides = Math.round(24);
		var nextAngle;
		if(dA < 0) {
			var i = -1;
			while(true) {
				angle = i * angleInc;
				--i;
				nextAngle = angle + temp;
				if(angle <= dA) {
					break;
				}
				p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
			}
		} else {
			var i1 = -1;
			while(true) {
				angle = i1 * angleInc;
				++i1;
				nextAngle = angle + temp;
				if(angle >= dA + angleInc) {
					break;
				}
				p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
			}
		}
		p.reverse();
		var p1 = p;
		justTriangles_Draw.q0 = p1[0];
		justTriangles_Draw.q1 = p1[0];
		var draw1 = new justTriangles_Draw();
		draw1.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
		var q3 = draw1.p3;
		var q4 = draw1.p4;
		justTriangles_Draw.q0 = q3;
		justTriangles_Draw.q1 = q4;
		var draw2 = draw1;
		var _g1 = 1;
		var _g = p1.length - 2;
		while(_g1 < _g) {
			var i2 = _g1++;
			draw2.rebuildAsPoly(p1[i2 + 2]);
			var q31 = draw2.p3;
			justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p0_,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = q31;
		}
		temp += Math.PI;
		var dx1 = p1_.x;
		var dy1 = p1_.y;
		var radius1 = thick / 4;
		var dA1 = Math.PI;
		var p2 = [];
		var angle1 = 0;
		var angleInc1 = Math.PI * 2 / 24;
		var sides1 = Math.round(24);
		var nextAngle1;
		if(dA1 < 0) {
			var i3 = -1;
			while(true) {
				angle1 = i3 * angleInc1;
				--i3;
				nextAngle1 = angle1 + temp;
				if(angle1 <= dA1) {
					break;
				}
				p2.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
			}
		} else {
			var i4 = -1;
			while(true) {
				angle1 = i4 * angleInc1;
				++i4;
				nextAngle1 = angle1 + temp;
				if(angle1 >= dA1 + angleInc1) {
					break;
				}
				p2.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
			}
		}
		p2.reverse();
		var p3 = p2;
		justTriangles_Draw.q0 = p3[0];
		justTriangles_Draw.q1 = p3[0];
		var draw3 = new justTriangles_Draw();
		draw3.create2Lines(p3[0],p3[1],p3[2],justTriangles_Draw.thickness);
		var q32 = draw3.p3;
		var q41 = draw3.p4;
		justTriangles_Draw.q0 = q32;
		justTriangles_Draw.q1 = q41;
		var draw4 = draw3;
		var _g11 = 1;
		var _g2 = p3.length - 2;
		while(_g11 < _g2) {
			var i5 = _g11++;
			draw4.rebuildAsPoly(p3[i5 + 2]);
			var q33 = draw4.p3;
			justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q33,p1_,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = q33;
		}
		justTriangles_Draw.thickness = oldThickness;
	}
	var q34 = { x : draw.p3.x, y : draw.p3.y};
	var q42 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q34,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q34,q42,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.triangleJoin = function(id,draw,p0_,p1_,thick,curveEnds) {
	if(curveEnds == null) {
		curveEnds = false;
	}
	var oldAngle = draw.p3 != null ? draw.angle1 : null;
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	if(draw.p3old2 != null) {
		var clockWise = justTriangles_Draw.dist(draw.p3old2,p1_) > justTriangles_Draw.dist(draw.p4old2,p1_);
		if(curveEnds) {
			if(oldAngle != null) {
				var dif = Math.abs(draw.angle1 - oldAngle);
				if(dif > 0.1) {
					var oldThickness = justTriangles_Draw.thickness;
					justTriangles_Draw.thickness = thick / 2;
					if(clockWise) {
						var dx = p0_.x;
						var dy = p0_.y;
						var radius = thick / 4;
						var start = draw.angle1;
						var p = [];
						var angle = 0;
						var angleInc = Math.PI * 2 / 240;
						var sides = Math.round(240);
						var nextAngle;
						if(dif < 0) {
							var i = -1;
							while(true) {
								angle = i * angleInc;
								--i;
								nextAngle = angle + start;
								if(angle <= dif) {
									break;
								}
								p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
							}
						} else {
							var i1 = -1;
							while(true) {
								angle = i1 * angleInc;
								++i1;
								nextAngle = angle + start;
								if(angle >= dif + angleInc) {
									break;
								}
								p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
							}
							p.reverse();
						}
						var p1 = p;
						justTriangles_Draw.q0 = p1[0];
						justTriangles_Draw.q1 = p1[0];
						var draw1 = new justTriangles_Draw();
						draw1.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
						var q3 = draw1.p3;
						var q4 = draw1.p4;
						justTriangles_Draw.q0 = q3;
						justTriangles_Draw.q1 = q4;
						var draw2 = draw1;
						var _g1 = 1;
						var _g = p1.length - 2;
						while(_g1 < _g) {
							var i2 = _g1++;
							draw2.rebuildAsPoly(p1[i2 + 2]);
							var q31 = draw2.p3;
							justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p0_,justTriangles_Draw.colorId);
							justTriangles_Draw.q0 = q31;
						}
					} else {
						var dx1 = p0_.x;
						var dy1 = p0_.y;
						var radius1 = thick / 4;
						var start1 = draw.angle2;
						var dA = -dif;
						var p2 = [];
						var angle1 = 0;
						var angleInc1 = Math.PI * 2 / 240;
						var sides1 = Math.round(240);
						var nextAngle1;
						if(dA < 0) {
							var i3 = -1;
							while(true) {
								angle1 = i3 * angleInc1;
								--i3;
								nextAngle1 = angle1 + start1;
								if(angle1 <= dA) {
									break;
								}
								p2.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
							}
						} else {
							var i4 = -1;
							while(true) {
								angle1 = i4 * angleInc1;
								++i4;
								nextAngle1 = angle1 + start1;
								if(angle1 >= dA + angleInc1) {
									break;
								}
								p2.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
							}
							p2.reverse();
						}
						var p3 = p2;
						justTriangles_Draw.q0 = p3[0];
						justTriangles_Draw.q1 = p3[0];
						var draw3 = new justTriangles_Draw();
						draw3.create2Lines(p3[0],p3[1],p3[2],justTriangles_Draw.thickness);
						var q32 = draw3.p3;
						var q41 = draw3.p4;
						justTriangles_Draw.q0 = q32;
						justTriangles_Draw.q1 = q41;
						var draw4 = draw3;
						var _g11 = 1;
						var _g2 = p3.length - 2;
						while(_g11 < _g2) {
							var i5 = _g11++;
							draw4.rebuildAsPoly(p3[i5 + 2]);
							var q33 = draw4.p3;
							justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q33,p0_,justTriangles_Draw.colorId);
							justTriangles_Draw.q0 = q33;
						}
					}
					justTriangles_Draw.thickness = oldThickness;
				}
			}
		}
		if(clockWise) {
			justTriangles_Draw.drawTri(id,true,draw.p3old2,q1,p0_,justTriangles_Draw.colorId);
		} else {
			justTriangles_Draw.drawTri(id,true,draw.p4old2,q0,p0_,justTriangles_Draw.colorId);
		}
	}
	justTriangles_Draw.drawTri(id,true,draw.p3old,draw.p3,draw.p4old,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,draw.p3old,draw.p3,draw.p4,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.quadCurves = function(id,p,thick) {
	var curvePoints;
	var curveLen;
	var len = p.length - 1;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		if((i - 1) % 2 == 0) {
			var p0 = p[i];
			var p1 = p[i + 1];
			var p2 = p[i + 2];
			var p3 = [];
			var x = p0.x - p1.x;
			var y = p0.y - p1.y;
			var x1 = p1.x - p2.x;
			var y1 = p1.y - p2.y;
			var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
			var v;
			if(approxDistance == 0) {
				approxDistance = 0.000001;
			}
			var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.quadStep);
			var arr_0 = p0;
			var arr_1 = p1;
			var arr_2 = p2;
			var t = 0.0;
			p3.push(p0);
			t += step;
			while(t < 1) {
				var u = 1 - t;
				var u1 = 1 - t;
				v = { x : Math.pow(u,2) * arr_0.x + 2 * u * t * arr_1.x + Math.pow(t,2) * arr_2.x, y : Math.pow(u1,2) * arr_0.y + 2 * u1 * t * arr_1.y + Math.pow(t,2) * arr_2.y};
				p3.push({ x : v.x, y : v.y});
				t += step;
			}
			p3.push(p2);
			curvePoints = p3;
			curveLen = curvePoints.length;
			var p0_ = curvePoints[0];
			var p1_ = curvePoints[1];
			var draw = new justTriangles_Draw();
			draw.p0 = p1_;
			draw.p1 = p0_;
			draw.halfA = Math.PI / 2;
			draw._thick = thick;
			draw.beta = Math.PI / 2 - draw.halfA;
			draw.r = draw._thick / 2 * Math.cos(draw.beta);
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var q0 = { x : draw.p3.x, y : draw.p3.y};
			var q1 = { x : draw.p4.x, y : draw.p4.y};
			draw.p0 = p0_;
			draw.p1 = p1_;
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var oldThickness = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp = draw.angle1;
			var dx = p0_.x;
			var dy = p0_.y;
			var radius = thick / 4;
			var dA = Math.PI;
			var p4 = [];
			var angle = 0;
			var angleInc = Math.PI * 2 / 24;
			var sides = Math.round(24);
			var nextAngle;
			if(dA < 0) {
				var i1 = -1;
				while(true) {
					angle = i1 * angleInc;
					--i1;
					nextAngle = angle + temp;
					if(angle <= dA) {
						break;
					}
					p4.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			} else {
				var i2 = -1;
				while(true) {
					angle = i2 * angleInc;
					++i2;
					nextAngle = angle + temp;
					if(angle >= dA + angleInc) {
						break;
					}
					p4.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			}
			p4.reverse();
			var p5 = p4;
			justTriangles_Draw.q0 = p5[0];
			justTriangles_Draw.q1 = p5[0];
			var draw1 = new justTriangles_Draw();
			draw1.create2Lines(p5[0],p5[1],p5[2],justTriangles_Draw.thickness);
			var q3 = draw1.p3;
			var q4 = draw1.p4;
			justTriangles_Draw.q0 = q3;
			justTriangles_Draw.q1 = q4;
			var draw2 = draw1;
			var _g11 = 1;
			var _g2 = p5.length - 2;
			while(_g11 < _g2) {
				var i3 = _g11++;
				draw2.rebuildAsPoly(p5[i3 + 2]);
				var q31 = draw2.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p0_,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q31;
			}
			justTriangles_Draw.thickness = oldThickness;
			var q32 = { x : draw.p3.x, y : draw.p3.y};
			var q41 = { x : draw.p4.x, y : draw.p4.y};
			justTriangles_Draw.drawTri(id,true,q0,q32,q1,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q0,q32,q41,justTriangles_Draw.colorId);
			var p0_1 = curvePoints[curveLen - 2];
			var p1_1 = curvePoints[curveLen - 1];
			var draw3 = new justTriangles_Draw();
			draw3.p0 = p1_1;
			draw3.p1 = p0_1;
			draw3.halfA = Math.PI / 2;
			draw3._thick = thick;
			draw3.beta = Math.PI / 2 - draw3.halfA;
			draw3.r = draw3._thick / 2 * Math.cos(draw3.beta);
			draw3._theta = draw3.theta(draw3.p0,draw3.p1);
			if(draw3._theta > 0) {
				if(draw3.halfA < 0) {
					draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
					draw3.angle1 = draw3._theta - draw3.halfA;
				} else {
					draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
					draw3.angle2 = draw3._theta + draw3.halfA;
				}
			} else if(draw3.halfA > 0) {
				draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
				draw3.angle2 = draw3._theta + draw3.halfA;
			} else {
				draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
				draw3.angle1 = draw3._theta - draw3.halfA;
			}
			if(draw3.p3old != null) {
				draw3.p3old2 = draw3.p3old;
			}
			if(draw3.p4old != null) {
				draw3.p4old2 = draw3.p4old;
			}
			if(draw3.p3 != null) {
				draw3.p3old = draw3.p3;
			}
			if(draw3.p4 != null) {
				draw3.p4old = draw3.p4;
			}
			draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
			draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
			var q01 = { x : draw3.p3.x, y : draw3.p3.y};
			var q11 = { x : draw3.p4.x, y : draw3.p4.y};
			draw3.p0 = p0_1;
			draw3.p1 = p1_1;
			draw3._theta = draw3.theta(draw3.p0,draw3.p1);
			if(draw3._theta > 0) {
				if(draw3.halfA < 0) {
					draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
					draw3.angle1 = draw3._theta - draw3.halfA;
				} else {
					draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
					draw3.angle2 = draw3._theta + draw3.halfA;
				}
			} else if(draw3.halfA > 0) {
				draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
				draw3.angle2 = draw3._theta + draw3.halfA;
			} else {
				draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
				draw3.angle1 = draw3._theta - draw3.halfA;
			}
			if(draw3.p3old != null) {
				draw3.p3old2 = draw3.p3old;
			}
			if(draw3.p4old != null) {
				draw3.p4old2 = draw3.p4old;
			}
			if(draw3.p3 != null) {
				draw3.p3old = draw3.p3;
			}
			if(draw3.p4 != null) {
				draw3.p4old = draw3.p4;
			}
			draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
			draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
			var oldThickness1 = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp1 = draw3.angle1 + Math.PI;
			var dx1 = p1_1.x;
			var dy1 = p1_1.y;
			var radius1 = thick / 4;
			var dA1 = Math.PI;
			var p6 = [];
			var angle1 = 0;
			var angleInc1 = Math.PI * 2 / 24;
			var sides1 = Math.round(24);
			var nextAngle1;
			if(dA1 < 0) {
				var i4 = -1;
				while(true) {
					angle1 = i4 * angleInc1;
					--i4;
					nextAngle1 = angle1 + temp1;
					if(angle1 <= dA1) {
						break;
					}
					p6.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			} else {
				var i5 = -1;
				while(true) {
					angle1 = i5 * angleInc1;
					++i5;
					nextAngle1 = angle1 + temp1;
					if(angle1 >= dA1 + angleInc1) {
						break;
					}
					p6.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			}
			p6.reverse();
			var p7 = p6;
			justTriangles_Draw.q0 = p7[0];
			justTriangles_Draw.q1 = p7[0];
			var draw4 = new justTriangles_Draw();
			draw4.create2Lines(p7[0],p7[1],p7[2],justTriangles_Draw.thickness);
			var q33 = draw4.p3;
			var q42 = draw4.p4;
			justTriangles_Draw.q0 = q33;
			justTriangles_Draw.q1 = q42;
			var draw5 = draw4;
			var _g12 = 1;
			var _g3 = p7.length - 2;
			while(_g12 < _g3) {
				var i6 = _g12++;
				draw5.rebuildAsPoly(p7[i6 + 2]);
				var q34 = draw5.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q34,p1_1,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q34;
			}
			justTriangles_Draw.thickness = oldThickness1;
			var q35 = { x : draw3.p3.x, y : draw3.p3.y};
			var q43 = { x : draw3.p4.x, y : draw3.p4.y};
			justTriangles_Draw.drawTri(id,true,q01,q35,q11,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q01,q35,q43,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = curvePoints[0];
			justTriangles_Draw.q1 = curvePoints[0];
			var _g13 = 0;
			var _g4 = curvePoints.length - 2;
			while(_g13 < _g4) {
				var i7 = _g13++;
				var draw6 = new justTriangles_Draw();
				draw6.create2Lines(curvePoints[i7],curvePoints[i7 + 1],curvePoints[i7 + 2],justTriangles_Draw.thickness);
				var q36 = draw6.p3;
				var q44 = draw6.p4;
				if(i7 != 0) {
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q36,justTriangles_Draw.q1,justTriangles_Draw.colorId);
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q1,q36,q44,justTriangles_Draw.colorId);
				}
				justTriangles_Draw.q0 = q36;
				justTriangles_Draw.q1 = q44;
			}
		}
	}
};
justTriangles_Draw.cubicCurves = function(id,p,thick) {
	var curvePoints;
	var curveLen;
	var len = p.length - 1;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		if((i - 2) % 3 == 0) {
			var p0 = p[i];
			var p1 = p[i + 1];
			var p2 = p[i + 2];
			var p3 = p[i + 3];
			var p4 = [];
			var x = p0.x - p1.x;
			var y = p0.y - p1.y;
			var x1 = p1.x - p2.x;
			var y1 = p1.y - p2.y;
			var x2 = p2.x - p3.x;
			var y2 = p2.y - p3.y;
			var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
			var v;
			if(approxDistance == 0) {
				approxDistance = 0.000001;
			}
			var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.cubicStep);
			var arr_0 = p0;
			var arr_1 = p1;
			var arr_2 = p2;
			var arr_3 = p3;
			var t = 0.0;
			var u = 1.;
			var u1 = 1.;
			v = { x : Math.pow(u,3) * arr_0.x + 3 * Math.pow(u,2) * 0.0 * arr_1.x + 3 * u * Math.pow(0.0,2) * arr_2.x + Math.pow(0.0,3) * arr_3.x, y : Math.pow(u1,3) * arr_0.y + 3 * Math.pow(u1,2) * 0.0 * arr_1.y + 3 * u1 * Math.pow(0.0,2) * arr_2.y + Math.pow(0.0,3) * arr_3.y};
			p4.push({ x : v.x, y : v.y});
			t += step;
			while(t < 1) {
				var u2 = 1 - t;
				var u3 = 1 - t;
				v = { x : Math.pow(u2,3) * arr_0.x + 3 * Math.pow(u2,2) * t * arr_1.x + 3 * u2 * Math.pow(t,2) * arr_2.x + Math.pow(t,3) * arr_3.x, y : Math.pow(u3,3) * arr_0.y + 3 * Math.pow(u3,2) * t * arr_1.y + 3 * u3 * Math.pow(t,2) * arr_2.y + Math.pow(t,3) * arr_3.y};
				p4.push({ x : v.x, y : v.y});
				t += step;
			}
			var u4 = 0.;
			var u5 = 0.;
			v = { x : Math.pow(u4,3) * arr_0.x + 3 * Math.pow(u4,2) * arr_1.x + 3 * u4 * Math.pow(1.0,2) * arr_2.x + Math.pow(1.0,3) * arr_3.x, y : Math.pow(u5,3) * arr_0.y + 3 * Math.pow(u5,2) * arr_1.y + 3 * u5 * Math.pow(1.0,2) * arr_2.y + Math.pow(1.0,3) * arr_3.y};
			p4.push({ x : v.x, y : v.y});
			curvePoints = p4;
			curveLen = curvePoints.length;
			var p0_ = curvePoints[0];
			var p1_ = curvePoints[1];
			var draw = new justTriangles_Draw();
			draw.p0 = p1_;
			draw.p1 = p0_;
			draw.halfA = Math.PI / 2;
			draw._thick = thick;
			draw.beta = Math.PI / 2 - draw.halfA;
			draw.r = draw._thick / 2 * Math.cos(draw.beta);
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var q0 = { x : draw.p3.x, y : draw.p3.y};
			var q1 = { x : draw.p4.x, y : draw.p4.y};
			draw.p0 = p0_;
			draw.p1 = p1_;
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var oldThickness = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp = draw.angle1;
			var dx = p0_.x;
			var dy = p0_.y;
			var radius = thick / 4;
			var dA = Math.PI;
			var p5 = [];
			var angle = 0;
			var angleInc = Math.PI * 2 / 24;
			var sides = Math.round(24);
			var nextAngle;
			if(dA < 0) {
				var i1 = -1;
				while(true) {
					angle = i1 * angleInc;
					--i1;
					nextAngle = angle + temp;
					if(angle <= dA) {
						break;
					}
					p5.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			} else {
				var i2 = -1;
				while(true) {
					angle = i2 * angleInc;
					++i2;
					nextAngle = angle + temp;
					if(angle >= dA + angleInc) {
						break;
					}
					p5.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			}
			p5.reverse();
			var p6 = p5;
			justTriangles_Draw.q0 = p6[0];
			justTriangles_Draw.q1 = p6[0];
			var draw1 = new justTriangles_Draw();
			draw1.create2Lines(p6[0],p6[1],p6[2],justTriangles_Draw.thickness);
			var q3 = draw1.p3;
			var q4 = draw1.p4;
			justTriangles_Draw.q0 = q3;
			justTriangles_Draw.q1 = q4;
			var draw2 = draw1;
			var _g11 = 1;
			var _g2 = p6.length - 2;
			while(_g11 < _g2) {
				var i3 = _g11++;
				draw2.rebuildAsPoly(p6[i3 + 2]);
				var q31 = draw2.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p0_,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q31;
			}
			justTriangles_Draw.thickness = oldThickness;
			var q32 = { x : draw.p3.x, y : draw.p3.y};
			var q41 = { x : draw.p4.x, y : draw.p4.y};
			justTriangles_Draw.drawTri(id,true,q0,q32,q1,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q0,q32,q41,justTriangles_Draw.colorId);
			var p0_1 = curvePoints[curveLen - 3];
			var p1_1 = curvePoints[curveLen - 2];
			var draw3 = new justTriangles_Draw();
			draw3.p0 = p1_1;
			draw3.p1 = p0_1;
			draw3.halfA = Math.PI / 2;
			draw3._thick = thick;
			draw3.beta = Math.PI / 2 - draw3.halfA;
			draw3.r = draw3._thick / 2 * Math.cos(draw3.beta);
			draw3._theta = draw3.theta(draw3.p0,draw3.p1);
			if(draw3._theta > 0) {
				if(draw3.halfA < 0) {
					draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
					draw3.angle1 = draw3._theta - draw3.halfA;
				} else {
					draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
					draw3.angle2 = draw3._theta + draw3.halfA;
				}
			} else if(draw3.halfA > 0) {
				draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
				draw3.angle2 = draw3._theta + draw3.halfA;
			} else {
				draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
				draw3.angle1 = draw3._theta - draw3.halfA;
			}
			if(draw3.p3old != null) {
				draw3.p3old2 = draw3.p3old;
			}
			if(draw3.p4old != null) {
				draw3.p4old2 = draw3.p4old;
			}
			if(draw3.p3 != null) {
				draw3.p3old = draw3.p3;
			}
			if(draw3.p4 != null) {
				draw3.p4old = draw3.p4;
			}
			draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
			draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
			var q01 = { x : draw3.p3.x, y : draw3.p3.y};
			var q11 = { x : draw3.p4.x, y : draw3.p4.y};
			draw3.p0 = p0_1;
			draw3.p1 = p1_1;
			draw3._theta = draw3.theta(draw3.p0,draw3.p1);
			if(draw3._theta > 0) {
				if(draw3.halfA < 0) {
					draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
					draw3.angle1 = draw3._theta - draw3.halfA;
				} else {
					draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
					draw3.angle2 = draw3._theta + draw3.halfA;
				}
			} else if(draw3.halfA > 0) {
				draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
				draw3.angle2 = draw3._theta + draw3.halfA;
			} else {
				draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
				draw3.angle1 = draw3._theta - draw3.halfA;
			}
			if(draw3.p3old != null) {
				draw3.p3old2 = draw3.p3old;
			}
			if(draw3.p4old != null) {
				draw3.p4old2 = draw3.p4old;
			}
			if(draw3.p3 != null) {
				draw3.p3old = draw3.p3;
			}
			if(draw3.p4 != null) {
				draw3.p4old = draw3.p4;
			}
			draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
			draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
			var oldThickness1 = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp1 = draw3.angle1 + Math.PI;
			var dx1 = p1_1.x;
			var dy1 = p1_1.y;
			var radius1 = thick / 4;
			var dA1 = Math.PI;
			var p7 = [];
			var angle1 = 0;
			var angleInc1 = Math.PI * 2 / 24;
			var sides1 = Math.round(24);
			var nextAngle1;
			if(dA1 < 0) {
				var i4 = -1;
				while(true) {
					angle1 = i4 * angleInc1;
					--i4;
					nextAngle1 = angle1 + temp1;
					if(angle1 <= dA1) {
						break;
					}
					p7.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			} else {
				var i5 = -1;
				while(true) {
					angle1 = i5 * angleInc1;
					++i5;
					nextAngle1 = angle1 + temp1;
					if(angle1 >= dA1 + angleInc1) {
						break;
					}
					p7.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			}
			p7.reverse();
			var p8 = p7;
			justTriangles_Draw.q0 = p8[0];
			justTriangles_Draw.q1 = p8[0];
			var draw4 = new justTriangles_Draw();
			draw4.create2Lines(p8[0],p8[1],p8[2],justTriangles_Draw.thickness);
			var q33 = draw4.p3;
			var q42 = draw4.p4;
			justTriangles_Draw.q0 = q33;
			justTriangles_Draw.q1 = q42;
			var draw5 = draw4;
			var _g12 = 1;
			var _g3 = p8.length - 2;
			while(_g12 < _g3) {
				var i6 = _g12++;
				draw5.rebuildAsPoly(p8[i6 + 2]);
				var q34 = draw5.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q34,p1_1,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q34;
			}
			justTriangles_Draw.thickness = oldThickness1;
			var q35 = { x : draw3.p3.x, y : draw3.p3.y};
			var q43 = { x : draw3.p4.x, y : draw3.p4.y};
			justTriangles_Draw.drawTri(id,true,q01,q35,q11,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q01,q35,q43,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = curvePoints[0];
			justTriangles_Draw.q1 = curvePoints[0];
			var _g13 = 0;
			var _g4 = curvePoints.length - 2;
			while(_g13 < _g4) {
				var i7 = _g13++;
				var draw6 = new justTriangles_Draw();
				draw6.create2Lines(curvePoints[i7],curvePoints[i7 + 1],curvePoints[i7 + 2],justTriangles_Draw.thickness);
				var q36 = draw6.p3;
				var q44 = draw6.p4;
				if(i7 != 0) {
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q36,justTriangles_Draw.q1,justTriangles_Draw.colorId);
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q1,q36,q44,justTriangles_Draw.colorId);
				}
				justTriangles_Draw.q0 = q36;
				justTriangles_Draw.q1 = q44;
			}
		}
	}
};
justTriangles_Draw.dist = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return dx * dx + dy * dy;
};
justTriangles_Draw.poly = function(id,outline,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	var draw1 = draw;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		var i = _g1++;
		draw1.rebuildAsPoly(p[i + 2]);
		var q31 = draw1.p3;
		var q41 = draw1.p4;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q31,justTriangles_Draw.q1,justTriangles_Draw.colorId);
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q31,q41,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q31;
		justTriangles_Draw.q1 = q41;
	}
};
justTriangles_Draw.outerPoly = function(id,outline,centre,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	var draw1 = draw;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		var i = _g1++;
		draw1.rebuildAsPoly(p[i + 2]);
		var q31 = draw1.p3;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q31,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q31;
	}
};
justTriangles_Draw.outerPolyExtra = function(id,outline,centre,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	var draw1 = draw;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		var i = _g1++;
		draw1.rebuildAsPoly(p[i + 2]);
		var q31 = draw1.p3;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q31,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q31;
	}
};
justTriangles_Draw.innerPoly = function(id,outline,centre,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	var draw1 = draw;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		var i = _g1++;
		draw1.rebuildAsPoly(p[i + 2]);
		var q41 = draw1.p4;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q41,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q1 = q41;
	}
};
justTriangles_Draw.triangles = function(id,outline,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var _g1 = 0;
	var _g = p.length - 2;
	while(_g1 < _g) {
		var i = _g1++;
		var draw = new justTriangles_Draw();
		draw.create2Lines(p[i],p[i + 1],p[i + 2],justTriangles_Draw.thickness);
		var q3 = draw.p3;
		var q4 = draw.p4;
		if(i != 0) {
			justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,justTriangles_Draw.q1,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q3,q4,justTriangles_Draw.colorId);
		}
		justTriangles_Draw.q0 = q3;
		justTriangles_Draw.q1 = q4;
	}
};
justTriangles_Draw.firstQuad = function(id,p,i) {
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[i],p[i + 1],p[i + 2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	return draw;
};
justTriangles_Draw.otherQuad = function(id,outline,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,justTriangles_Draw.q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q3,q4,justTriangles_Draw.colorId);
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	return draw;
};
justTriangles_Draw.outerFilledTriangles = function(id,outline,centre,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q3 = draw.p3;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,centre,justTriangles_Draw.colorId);
	justTriangles_Draw.q0 = q3;
	return draw;
};
justTriangles_Draw.outerFilledTrianglesExtra = function(id,outline,centre,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q3 = draw.p3;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,centre,justTriangles_Draw.colorId);
	justTriangles_Draw.q0 = q3;
	return draw;
};
justTriangles_Draw.innerFilledTriangles = function(id,outline,centre,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q4 = draw.p4;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q4,centre,justTriangles_Draw.colorId);
	justTriangles_Draw.q1 = q4;
	return draw;
};
justTriangles_Draw.quad = function(id,outline,p,i) {
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[i],p[i + 1],p[i + 2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	if(i != 0) {
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,justTriangles_Draw.q1,justTriangles_Draw.colorId);
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q3,q4,justTriangles_Draw.colorId);
	}
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	return draw;
};
justTriangles_Draw.generateMidPoints = function(arr) {
	var out = [];
	var a;
	var b;
	var len = arr.length - 2;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		a = arr[i];
		b = arr[i + 1];
		out.push({ x : (b.x + a.x) / 2, y : (b.y + a.y) / 2});
		out.push({ x : b.x, y : b.y});
	}
	a = arr[0];
	out.unshift({ x : a.x, y : a.y});
	out.unshift({ x : a.x, y : a.y});
	b = arr[arr.length - 1];
	out.push({ x : b.x, y : b.y});
	out.push({ x : b.x, y : b.y});
	out.push({ x : b.x, y : b.y});
	return out;
};
justTriangles_Draw.prototype = {
	create2Lines: function(p0_,p1_,p2_,thick) {
		this.p0 = p0_;
		this.p1 = p1_;
		this.p2 = p2_;
		this.b2 = justTriangles_Draw.dist(this.p0,this.p1);
		this.c2 = justTriangles_Draw.dist(this.p1,this.p2);
		this.a2 = justTriangles_Draw.dist(this.p0,this.p2);
		this.b = Math.sqrt(this.b2);
		this.c = Math.sqrt(this.c2);
		this.a = Math.sqrt(this.a2);
		this.cosA = (this.b2 + this.c2 - this.a2) / (2 * this.b * this.c);
		if(this.cosA > 1) {
			this.cosA = 1;
		} else if(this.cosA < -1) {
			this.cosA = -1;
		}
		this.angleA = Math.acos(this.cosA);
		this.halfA = this.angleA / 2;
		this._thick = thick;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = this._thick / 2 * Math.cos(this.beta);
		this._theta = this.theta(this.p0,this.p1);
		if(this._theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this._theta + this.halfA + Math.PI / 2;
				this.angle1 = this._theta - this.halfA;
			} else {
				this.angle1 = this._theta + this.halfA - Math.PI;
				this.angle2 = this._theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this._theta + this.halfA - Math.PI;
			this.angle2 = this._theta + this.halfA;
		} else {
			this.angle2 = this._theta + this.halfA + Math.PI / 2;
			this.angle1 = this._theta - this.halfA;
		}
		if(this.p3old != null) {
			this.p3old2 = this.p3old;
		}
		if(this.p4old != null) {
			this.p4old2 = this.p4old;
		}
		if(this.p3 != null) {
			this.p3old = this.p3;
		}
		if(this.p4 != null) {
			this.p4old = this.p4;
		}
		this.p3 = { x : this.p1.x + this.r * Math.cos(this.angle1), y : this.p1.y + this.r * Math.sin(this.angle1)};
		this.p4 = { x : this.p1.x + this.r * Math.cos(this.angle2), y : this.p1.y + this.r * Math.sin(this.angle2)};
	}
	,setThickness: function(val) {
		this._thick = val;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = this._thick / 2 * Math.cos(this.beta);
	}
	,calculateP3p4: function() {
		this._theta = this.theta(this.p0,this.p1);
		if(this._theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this._theta + this.halfA + Math.PI / 2;
				this.angle1 = this._theta - this.halfA;
			} else {
				this.angle1 = this._theta + this.halfA - Math.PI;
				this.angle2 = this._theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this._theta + this.halfA - Math.PI;
			this.angle2 = this._theta + this.halfA;
		} else {
			this.angle2 = this._theta + this.halfA + Math.PI / 2;
			this.angle1 = this._theta - this.halfA;
		}
		if(this.p3old != null) {
			this.p3old2 = this.p3old;
		}
		if(this.p4old != null) {
			this.p4old2 = this.p4old;
		}
		if(this.p3 != null) {
			this.p3old = this.p3;
		}
		if(this.p4 != null) {
			this.p4old = this.p4;
		}
		this.p3 = { x : this.p1.x + this.r * Math.cos(this.angle1), y : this.p1.y + this.r * Math.sin(this.angle1)};
		this.p4 = { x : this.p1.x + this.r * Math.cos(this.angle2), y : this.p1.y + this.r * Math.sin(this.angle2)};
	}
	,rebuildAsPoly: function(p2_) {
		this.p0 = this.p1;
		this.p1 = this.p2;
		this.p2 = p2_;
		this._theta = this.theta(this.p0,this.p1);
		if(this._theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this._theta + this.halfA + Math.PI / 2;
				this.angle1 = this._theta - this.halfA;
			} else {
				this.angle1 = this._theta + this.halfA - Math.PI;
				this.angle2 = this._theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this._theta + this.halfA - Math.PI;
			this.angle2 = this._theta + this.halfA;
		} else {
			this.angle2 = this._theta + this.halfA + Math.PI / 2;
			this.angle1 = this._theta - this.halfA;
		}
		if(this.p3old != null) {
			this.p3old2 = this.p3old;
		}
		if(this.p4old != null) {
			this.p4old2 = this.p4old;
		}
		if(this.p3 != null) {
			this.p3old = this.p3;
		}
		if(this.p4 != null) {
			this.p4old = this.p4;
		}
		this.p3 = { x : this.p1.x + this.r * Math.cos(this.angle1), y : this.p1.y + this.r * Math.sin(this.angle1)};
		this.p4 = { x : this.p1.x + this.r * Math.cos(this.angle2), y : this.p1.y + this.r * Math.sin(this.angle2)};
	}
	,theta: function(p0,p1) {
		var dx = p0.x - p1.x;
		var dy = p0.y - p1.y;
		return Math.atan2(dy,dx);
	}
	,__class__: justTriangles_Draw
};
var justTriangles_IPathContext = function() { };
justTriangles_IPathContext.__name__ = true;
justTriangles_IPathContext.prototype = {
	__class__: justTriangles_IPathContext
};
var justTriangles_LineType = { __ename__ : true, __constructs__ : ["TriangleJoinCurve","TriangleJoinStraight","Poly","Curves","Round","Isolated","Quad"] };
justTriangles_LineType.TriangleJoinCurve = ["TriangleJoinCurve",0];
justTriangles_LineType.TriangleJoinCurve.__enum__ = justTriangles_LineType;
justTriangles_LineType.TriangleJoinStraight = ["TriangleJoinStraight",1];
justTriangles_LineType.TriangleJoinStraight.__enum__ = justTriangles_LineType;
justTriangles_LineType.Poly = ["Poly",2];
justTriangles_LineType.Poly.__enum__ = justTriangles_LineType;
justTriangles_LineType.Curves = ["Curves",3];
justTriangles_LineType.Curves.__enum__ = justTriangles_LineType;
justTriangles_LineType.Round = ["Round",4];
justTriangles_LineType.Round.__enum__ = justTriangles_LineType;
justTriangles_LineType.Isolated = ["Isolated",5];
justTriangles_LineType.Isolated.__enum__ = justTriangles_LineType;
justTriangles_LineType.Quad = ["Quad",6];
justTriangles_LineType.Quad.__enum__ = justTriangles_LineType;
var justTriangles_PathContext = function(id_,width_,tx_,ty_) {
	if(ty_ == null) {
		ty_ = 0;
	}
	if(tx_ == null) {
		tx_ = 0;
	}
	this.lineType = justTriangles_LineType.TriangleJoinCurve;
	this.dirty = true;
	this.fill = false;
	this.id = id_;
	this.dw = width_ / 2;
	this.s = 1 / width_;
	this.tx = tx_;
	this.ty = ty_;
	this.minX = 1;
	this.maxX = -1;
	this.minY = 1;
	this.maxY = -1;
	this.lineColors = [];
	this.fillColors = [];
	this.thicks = [];
	this.lineColor = justTriangles_Draw.colorId;
	this.fillColor = justTriangles_Draw.colorId;
	this.thick = justTriangles_Draw.get_thick();
	this.ppp = [];
	this.moveTo(this.dw,this.dw);
};
justTriangles_PathContext.__name__ = true;
justTriangles_PathContext.__interfaces__ = [justTriangles_IPathContext];
justTriangles_PathContext.prototype = {
	setColor: function(lineColor_,fillColor_) {
		if(fillColor_ == null) {
			fillColor_ = -1;
		}
		if(fillColor_ != -1) {
			this.fillColor = fillColor_;
		}
		this.lineColor = lineColor_;
	}
	,setThickness: function(thick_) {
		this.thick = thick_;
		return this.thick;
	}
	,pt: function(x,y) {
		var x0 = this.s * (x - this.dw + this.tx);
		var y0 = this.s * (y - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		return { x : x0, y : y0};
	}
	,withinBounds: function(x,y) {
		if(x > this.minX && x < this.maxX && y > this.minY) {
			return y < this.maxY;
		} else {
			return false;
		}
	}
	,moveTo: function(x,y) {
		this.dirty = true;
		var x0 = this.s * (x - this.dw + this.tx);
		var y0 = this.s * (y - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		this.p0 = { x : x0, y : y0};
		if(this.pp != null) {
			if(this.pp.length == 1) {
				this.ppp.pop();
				this.lineColors.pop();
				this.fillColors.pop();
				this.thicks.pop();
			}
		}
		this.pp = [];
		var pl = this.ppp.length;
		this.lineColors[pl] = this.lineColor;
		this.fillColors[pl] = this.fillColor;
		this.thicks[pl] = this.thick;
		this.pp.push(this.p0);
		this.ppp.push(this.pp);
	}
	,moveToPoint: function(p0) {
		this.dirty = true;
		if(this.pp != null) {
			if(this.pp.length == 1) {
				this.ppp.pop();
				this.lineColors.pop();
				this.fillColors.pop();
				this.thicks.pop();
			}
		}
		this.pp = [];
		var pl = this.ppp.length;
		this.lineColors[this.ppp.length] = this.lineColor;
		this.fillColors[this.ppp.length] = this.fillColor;
		this.thicks[pl] = this.thick;
		this.pp.push(p0);
		this.ppp.push(this.pp);
	}
	,lineTo: function(x,y) {
		var x0 = this.s * (x - this.dw + this.tx);
		var y0 = this.s * (y - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		var p1 = { x : x0, y : y0};
		this.pp.push(p1);
		this.p0 = p1;
	}
	,quadTo: function(x1,y1,x2,y2) {
		var x0 = this.s * (x1 - this.dw + this.tx);
		var y0 = this.s * (y1 - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		var p1 = { x : x0, y : y0};
		var x01 = this.s * (x2 - this.dw + this.tx);
		var y01 = this.s * (y2 - this.dw + this.ty);
		if(x01 < this.minX) {
			this.minX = x01;
		}
		if(x01 < this.minY) {
			this.minY = y01;
		}
		if(x01 > this.maxX) {
			this.maxX = x01;
		}
		if(y01 > this.maxY) {
			this.maxY = y01;
		}
		var p2 = { x : x01, y : y01};
		var p0 = this.p0;
		var p = [];
		var x = p0.x - p1.x;
		var y = p0.y - p1.y;
		var x3 = p1.x - p2.x;
		var y3 = p1.y - p2.y;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		var v;
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.quadStep);
		var arr_0 = p0;
		var arr_1 = p1;
		var arr_2 = p2;
		var t = 0.0;
		p.push(p0);
		t += step;
		while(t < 1) {
			var u = 1 - t;
			var u1 = 1 - t;
			v = { x : Math.pow(u,2) * arr_0.x + 2 * u * t * arr_1.x + Math.pow(t,2) * arr_2.x, y : Math.pow(u1,2) * arr_0.y + 2 * u1 * t * arr_1.y + Math.pow(t,2) * arr_2.y};
			p.push({ x : v.x, y : v.y});
			t += step;
		}
		p.push(p2);
		var pMore = p;
		var plen = this.pp.length;
		var _g1 = 1;
		var _g = pMore.length;
		while(_g1 < _g) {
			var i = _g1++;
			this.pp[plen++] = pMore[i];
		}
		this.p0 = p2;
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		var x0 = this.s * (x1 - this.dw + this.tx);
		var y0 = this.s * (y1 - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		var p1 = { x : x0, y : y0};
		var x01 = this.s * (x2 - this.dw + this.tx);
		var y01 = this.s * (y2 - this.dw + this.ty);
		if(x01 < this.minX) {
			this.minX = x01;
		}
		if(x01 < this.minY) {
			this.minY = y01;
		}
		if(x01 > this.maxX) {
			this.maxX = x01;
		}
		if(y01 > this.maxY) {
			this.maxY = y01;
		}
		var p2 = { x : x01, y : y01};
		var x02 = this.s * (x3 - this.dw + this.tx);
		var y02 = this.s * (y3 - this.dw + this.ty);
		if(x02 < this.minX) {
			this.minX = x02;
		}
		if(x02 < this.minY) {
			this.minY = y02;
		}
		if(x02 > this.maxX) {
			this.maxX = x02;
		}
		if(y02 > this.maxY) {
			this.maxY = y02;
		}
		var p3 = { x : x02, y : y02};
		var p0 = this.p0;
		var p = [];
		var x = p0.x - p1.x;
		var y = p0.y - p1.y;
		var x4 = p1.x - p2.x;
		var y4 = p1.y - p2.y;
		var x5 = p2.x - p3.x;
		var y5 = p2.y - p3.y;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5);
		var v;
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.cubicStep);
		var arr_0 = p0;
		var arr_1 = p1;
		var arr_2 = p2;
		var arr_3 = p3;
		var t = 0.0;
		var u = 1.;
		var u1 = 1.;
		v = { x : Math.pow(u,3) * arr_0.x + 3 * Math.pow(u,2) * 0.0 * arr_1.x + 3 * u * Math.pow(0.0,2) * arr_2.x + Math.pow(0.0,3) * arr_3.x, y : Math.pow(u1,3) * arr_0.y + 3 * Math.pow(u1,2) * 0.0 * arr_1.y + 3 * u1 * Math.pow(0.0,2) * arr_2.y + Math.pow(0.0,3) * arr_3.y};
		p.push({ x : v.x, y : v.y});
		t += step;
		while(t < 1) {
			var u2 = 1 - t;
			var u3 = 1 - t;
			v = { x : Math.pow(u2,3) * arr_0.x + 3 * Math.pow(u2,2) * t * arr_1.x + 3 * u2 * Math.pow(t,2) * arr_2.x + Math.pow(t,3) * arr_3.x, y : Math.pow(u3,3) * arr_0.y + 3 * Math.pow(u3,2) * t * arr_1.y + 3 * u3 * Math.pow(t,2) * arr_2.y + Math.pow(t,3) * arr_3.y};
			p.push({ x : v.x, y : v.y});
			t += step;
		}
		var u4 = 0.;
		var u5 = 0.;
		v = { x : Math.pow(u4,3) * arr_0.x + 3 * Math.pow(u4,2) * arr_1.x + 3 * u4 * Math.pow(1.0,2) * arr_2.x + Math.pow(1.0,3) * arr_3.x, y : Math.pow(u5,3) * arr_0.y + 3 * Math.pow(u5,2) * arr_1.y + 3 * u5 * Math.pow(1.0,2) * arr_2.y + Math.pow(1.0,3) * arr_3.y};
		p.push({ x : v.x, y : v.y});
		var pMore = p;
		var plen = this.pp.length;
		var _g1 = 1;
		var _g = pMore.length;
		while(_g1 < _g) {
			var i = _g1++;
			this.pp[plen++] = pMore[i];
		}
		this.p0 = p3;
	}
	,rectangle: function(x,y,width,height) {
		var p1_y;
		var p1_x;
		var x0 = this.s * (x - this.dw + this.tx);
		var y0 = this.s * (y - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		p1_x = x0;
		p1_y = y0;
		var x1 = p1_x;
		var y1 = p1_y;
		var wid = width * this.s;
		var hi = height * this.s;
		var p = [{ x : x1, y : y1},{ x : x1 + wid, y : y1},{ x : x1 + wid, y : y1 + hi},{ x : x1, y : y1 + hi},{ x : x1, y : y1},{ x : x1 + wid, y : y1},{ x : x1 + wid, y : y1 + hi}];
		p.reverse();
		var pMore = p;
		this.moveToPoint(pMore[0]);
		var _g = 0;
		while(_g < pMore.length) {
			var p1 = pMore[_g];
			++_g;
			this.pp.push(p1);
		}
	}
	,arc_move: function(x,y,radius,start,dA,direction,sides) {
		if(direction == null) {
			direction = true;
		}
		if(sides == null) {
			sides = justTriangles_PathContext.circleSides;
		}
		var p1_y;
		var p1_x;
		var x0 = this.s * (x - this.dw + this.tx);
		var y0 = this.s * (y - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		p1_x = x0;
		p1_y = y0;
		if(direction == false) {
			dA = -dA;
		}
		var radius1 = radius * this.s;
		var sides1 = sides;
		var p = [];
		var dx = p1_x;
		var dy = p1_y;
		var angle = 0;
		var angleInc = Math.PI * 2 / sides1;
		var sides2 = Math.round(sides1);
		var nextAngle;
		if(dA < 0) {
			var i = -1;
			while(true) {
				angle = i * angleInc;
				nextAngle = angle + start;
				--i;
				if(angle <= dA) {
					break;
				}
				p.push({ x : dx + radius1 * Math.cos(nextAngle), y : dy + radius1 * Math.sin(nextAngle)});
			}
		} else {
			var i1 = -1;
			while(true) {
				angle = i1 * angleInc;
				++i1;
				nextAngle = angle + start;
				if(angle >= dA + angleInc) {
					break;
				}
				p.push({ x : dx + radius1 * Math.cos(nextAngle), y : dy + radius1 * Math.sin(nextAngle)});
			}
		}
		var pMore = p;
		this.moveToPoint(pMore[0]);
		var _g = 0;
		while(_g < pMore.length) {
			var p1 = pMore[_g];
			++_g;
			this.pp.push(p1);
		}
	}
	,arc: function(x,y,radius,start,dA,direction,sides) {
		if(direction == null) {
			direction = true;
		}
		if(sides == null) {
			sides = justTriangles_PathContext.circleSides;
		}
		var p1_y;
		var p1_x;
		var x0 = this.s * (x - this.dw + this.tx);
		var y0 = this.s * (y - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		p1_x = x0;
		p1_y = y0;
		if(direction == false) {
			dA = -dA;
		}
		var radius1 = radius * this.s;
		var sides1 = sides;
		var p = [];
		var dx = p1_x;
		var dy = p1_y;
		var angle = 0;
		var angleInc = Math.PI * 2 / sides1;
		var sides2 = Math.round(sides1);
		var nextAngle;
		if(dA < 0) {
			var i = -1;
			while(true) {
				angle = i * angleInc;
				nextAngle = angle + start;
				--i;
				if(angle <= dA) {
					break;
				}
				p.push({ x : dx + radius1 * Math.cos(nextAngle), y : dy + radius1 * Math.sin(nextAngle)});
			}
		} else {
			var i1 = -1;
			while(true) {
				angle = i1 * angleInc;
				++i1;
				nextAngle = angle + start;
				if(angle >= dA + angleInc) {
					break;
				}
				p.push({ x : dx + radius1 * Math.cos(nextAngle), y : dy + radius1 * Math.sin(nextAngle)});
			}
		}
		var pMore = p;
		var _g = 0;
		while(_g < pMore.length) {
			var p1 = pMore[_g];
			++_g;
			this.pp.push(p1);
		}
	}
	,roundedRectangle: function(dx,dy,width,height,radius) {
		var pi = Math.PI;
		var pi_2 = Math.PI / 2;
		var p_arc1x = dx + radius;
		var p_arc1y = dy + radius;
		var p_arc2x = dx + width - radius;
		var p_arc2y = dy + radius;
		var p_arc3x = dx + width - radius;
		var p_arc3y = dy + height - radius;
		var p_arc4x = dx + radius;
		var p_arc4y = dy + height - radius;
		var p1x = dx + radius;
		var p1y = dy;
		var p2x = dx + width - radius;
		var p2y = dy;
		var p3x = dx + width;
		var p3y = dy + radius;
		var p4x = dx + width;
		var p4y = dy + height - radius;
		var p5x = dx + width - radius;
		var p5y = dy + height;
		var p6x = dx + radius;
		var p6y = dy + height;
		var p7x = dx;
		var p7y = dy + height - radius;
		var p8x = dx;
		var p8y = dy + radius;
		this.moveTo(p8x,p8y);
		this.arc_move(p_arc1x,p_arc1y,radius,pi,pi_2,true,60);
		this.arc(p_arc2x,p_arc2y,radius,-pi_2,pi_2,true,60);
		this.arc(p_arc3x,p_arc3y,radius,0,pi_2,true,60);
		this.arc(p_arc4x,p_arc4y,radius,pi_2,pi_2,true,60);
		this.lineTo(p8x,p8y);
	}
	,regularPoly: function(sides,x,y,radius,rotation) {
		if(rotation == null) {
			rotation = 0;
		}
		var p1_y;
		var p1_x;
		var x0 = this.s * (x - this.dw + this.tx);
		var y0 = this.s * (y - this.dw + this.ty);
		if(x0 < this.minX) {
			this.minX = x0;
		}
		if(x0 < this.minY) {
			this.minY = y0;
		}
		if(x0 > this.maxX) {
			this.maxX = x0;
		}
		if(y0 > this.maxY) {
			this.maxY = y0;
		}
		p1_x = x0;
		p1_y = y0;
		var radius1 = radius * this.s;
		var sides1 = sides;
		var p = [];
		var angle = 0;
		var angleInc = Math.PI * 2 / sides1;
		var offset = rotation - Math.PI / 2;
		var tot = sides1 + 3;
		var _g1 = 0;
		var _g = tot;
		while(_g1 < _g) {
			var i = _g1++;
			angle = i * angleInc;
			angle += offset;
			p[tot - i - 1] = { x : p1_x + radius1 * Math.cos(angle), y : p1_y + radius1 * Math.sin(angle)};
		}
		var pMore = p;
		this.moveToPoint(pMore[0]);
		var _g2 = 0;
		while(_g2 < pMore.length) {
			var p1 = pMore[_g2];
			++_g2;
			this.pp.push(p1);
		}
	}
	,fillTriangles: function() {
		var p;
		var l = this.ppp_.length;
		var j = 0;
		var _g = 0;
		var _g1 = this.ppp_;
		while(_g < _g1.length) {
			var pp0 = _g1[_g];
			++_g;
			var poly = [];
			var _g3 = 0;
			var _g2 = pp0.length;
			while(_g3 < _g2) {
				var i = _g3++;
				p = pp0[i];
				poly.push(p.x);
				poly.push(p.y);
			}
			justTriangles_Draw.colorId = this.fillColors[j];
			var n = poly.length >> 1;
			var tgs;
			if(n < 3) {
				tgs = [];
			} else {
				var tgs1 = [];
				var avl = [];
				var _g11 = 0;
				var _g4 = n;
				while(_g11 < _g4) {
					var i1 = _g11++;
					avl.push(i1);
				}
				var i2 = 0;
				var al = n;
				var i0;
				var i11;
				var i21;
				var vi;
				var ax;
				var ay;
				var bx;
				var by;
				var cx;
				var cy;
				var earFound;
				while(al > 3) {
					i0 = avl[i2 % al];
					i11 = avl[(i2 + 1) % al];
					i21 = avl[(i2 + 2) % al];
					ax = poly[2 * i0];
					ay = poly[2 * i0 + 1];
					bx = poly[2 * i11];
					by = poly[2 * i11 + 1];
					cx = poly[2 * i21];
					cy = poly[2 * i21 + 1];
					earFound = false;
					if((ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0) {
						earFound = true;
						var _g12 = 0;
						var _g5 = al;
						while(_g12 < _g5) {
							var j1 = _g12++;
							var vi1 = avl[j1];
							if(vi1 == i0 || vi1 == i11 || vi1 == i21) {
								continue;
							}
							var v0x = cx - ax;
							var v0y = cy - ay;
							var v1x = bx - ax;
							var v1y = by - ay;
							var v2x = poly[2 * vi1] - ax;
							var v2y = poly[2 * vi1 + 1] - ay;
							var dot00 = v0x * v0x + v0y * v0y;
							var dot01 = v0x * v1x + v0y * v1y;
							var dot02 = v0x * v2x + v0y * v2y;
							var dot11 = v1x * v1x + v1y * v1y;
							var dot12 = v1x * v2x + v1y * v2y;
							var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
							var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
							var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
							if(u >= 0 && v >= 0 && u + v < 1) {
								earFound = false;
								break;
							}
						}
					}
					if(earFound) {
						tgs1.push(i0);
						tgs1.push(i11);
						tgs1.push(i21);
						avl.splice((i2 + 1) % al,1);
						--al;
						i2 = 0;
					} else if(i2++ > 3 * al) {
						break;
					}
				}
				tgs1.push(avl[0]);
				tgs1.push(avl[1]);
				tgs1.push(avl[2]);
				tgs = tgs1;
			}
			var triples = justTriangles__$PolyK_ArrayTriple_$Impl_$._new(tgs);
			var a;
			var b;
			var c;
			var i3;
			var _g6 = 0;
			while(_g6 < (triples.length / 3 | 0)) {
				var tri_c;
				var tri_b;
				var tri_a;
				var i4 = _g6 * 3 | 0;
				tri_a = triples[i4];
				tri_b = triples[i4 + 1];
				tri_c = triples[i4 + 2];
				++_g6;
				i3 = tri_a * 2 | 0;
				a = { x : poly[i3], y : poly[i3 + 1]};
				i3 = tri_b * 2 | 0;
				b = { x : poly[i3], y : poly[i3 + 1]};
				i3 = tri_c * 2 | 0;
				c = { x : poly[i3], y : poly[i3 + 1]};
				var n1 = poly.length >> 1;
				var tgs2;
				if(n1 < 3) {
					tgs2 = [];
				} else {
					var tgs3 = [];
					var avl1 = [];
					var _g13 = 0;
					var _g7 = n1;
					while(_g13 < _g7) {
						var i5 = _g13++;
						avl1.push(i5);
					}
					var i6 = 0;
					var al1 = n1;
					var i01;
					var i12;
					var i22;
					var vi2;
					var ax1;
					var ay1;
					var bx1;
					var by1;
					var cx1;
					var cy1;
					var earFound1;
					while(al1 > 3) {
						i01 = avl1[i6 % al1];
						i12 = avl1[(i6 + 1) % al1];
						i22 = avl1[(i6 + 2) % al1];
						ax1 = poly[2 * i01];
						ay1 = poly[2 * i01 + 1];
						bx1 = poly[2 * i12];
						by1 = poly[2 * i12 + 1];
						cx1 = poly[2 * i22];
						cy1 = poly[2 * i22 + 1];
						earFound1 = false;
						if((ay1 - by1) * (cx1 - bx1) + (bx1 - ax1) * (cy1 - by1) >= 0) {
							earFound1 = true;
							var _g14 = 0;
							var _g8 = al1;
							while(_g14 < _g8) {
								var j2 = _g14++;
								var vi3 = avl1[j2];
								if(vi3 == i01 || vi3 == i12 || vi3 == i22) {
									continue;
								}
								var v0x1 = cx1 - ax1;
								var v0y1 = cy1 - ay1;
								var v1x1 = bx1 - ax1;
								var v1y1 = by1 - ay1;
								var v2x1 = poly[2 * vi3] - ax1;
								var v2y1 = poly[2 * vi3 + 1] - ay1;
								var dot001 = v0x1 * v0x1 + v0y1 * v0y1;
								var dot011 = v0x1 * v1x1 + v0y1 * v1y1;
								var dot021 = v0x1 * v2x1 + v0y1 * v2y1;
								var dot111 = v1x1 * v1x1 + v1y1 * v1y1;
								var dot121 = v1x1 * v2x1 + v1y1 * v2y1;
								var invDenom1 = 1 / (dot001 * dot111 - dot011 * dot011);
								var u1 = (dot111 * dot021 - dot011 * dot121) * invDenom1;
								var v1 = (dot001 * dot121 - dot011 * dot021) * invDenom1;
								if(u1 >= 0 && v1 >= 0 && u1 + v1 < 1) {
									earFound1 = false;
									break;
								}
							}
						}
						if(earFound1) {
							tgs3.push(i01);
							tgs3.push(i12);
							tgs3.push(i22);
							avl1.splice((i6 + 1) % al1,1);
							--al1;
							i6 = 0;
						} else if(i6++ > 3 * al1) {
							break;
						}
					}
					tgs3.push(avl1[0]);
					tgs3.push(avl1[1]);
					tgs3.push(avl1[2]);
					tgs2 = tgs3;
				}
				var triples1 = justTriangles__$PolyK_ArrayTriple_$Impl_$._new(tgs2);
				var a1;
				var b1;
				var c1;
				var i7;
				var _g15 = 0;
				while(_g15 < (triples1.length / 3 | 0)) {
					var tri_c1;
					var tri_b1;
					var tri_a1;
					var i8 = _g15 * 3 | 0;
					tri_a1 = triples1[i8];
					tri_b1 = triples1[i8 + 1];
					tri_c1 = triples1[i8 + 2];
					++_g15;
					i7 = tri_a1 * 2 | 0;
					a1 = { x : poly[i7], y : poly[i7 + 1]};
					i7 = tri_b1 * 2 | 0;
					b1 = { x : poly[i7], y : poly[i7 + 1]};
					i7 = tri_c1 * 2 | 0;
					c1 = { x : poly[i7], y : poly[i7 + 1]};
					justTriangles_Draw.drawTri(this.id,false,a1,b1,c1,justTriangles_Draw.colorId);
				}
			}
			++j;
		}
	}
	,polyKFill: function(poly) {
		var n = poly.length >> 1;
		var tgs;
		if(n < 3) {
			tgs = [];
		} else {
			var tgs1 = [];
			var avl = [];
			var _g1 = 0;
			var _g = n;
			while(_g1 < _g) {
				var i = _g1++;
				avl.push(i);
			}
			var i1 = 0;
			var al = n;
			var i0;
			var i11;
			var i2;
			var vi;
			var ax;
			var ay;
			var bx;
			var by;
			var cx;
			var cy;
			var earFound;
			while(al > 3) {
				i0 = avl[i1 % al];
				i11 = avl[(i1 + 1) % al];
				i2 = avl[(i1 + 2) % al];
				ax = poly[2 * i0];
				ay = poly[2 * i0 + 1];
				bx = poly[2 * i11];
				by = poly[2 * i11 + 1];
				cx = poly[2 * i2];
				cy = poly[2 * i2 + 1];
				earFound = false;
				if((ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0) {
					earFound = true;
					var _g11 = 0;
					var _g2 = al;
					while(_g11 < _g2) {
						var j = _g11++;
						var vi1 = avl[j];
						if(vi1 == i0 || vi1 == i11 || vi1 == i2) {
							continue;
						}
						var v0x = cx - ax;
						var v0y = cy - ay;
						var v1x = bx - ax;
						var v1y = by - ay;
						var v2x = poly[2 * vi1] - ax;
						var v2y = poly[2 * vi1 + 1] - ay;
						var dot00 = v0x * v0x + v0y * v0y;
						var dot01 = v0x * v1x + v0y * v1y;
						var dot02 = v0x * v2x + v0y * v2y;
						var dot11 = v1x * v1x + v1y * v1y;
						var dot12 = v1x * v2x + v1y * v2y;
						var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
						var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
						var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
						if(u >= 0 && v >= 0 && u + v < 1) {
							earFound = false;
							break;
						}
					}
				}
				if(earFound) {
					tgs1.push(i0);
					tgs1.push(i11);
					tgs1.push(i2);
					avl.splice((i1 + 1) % al,1);
					--al;
					i1 = 0;
				} else if(i1++ > 3 * al) {
					break;
				}
			}
			tgs1.push(avl[0]);
			tgs1.push(avl[1]);
			tgs1.push(avl[2]);
			tgs = tgs1;
		}
		var triples = justTriangles__$PolyK_ArrayTriple_$Impl_$._new(tgs);
		var a;
		var b;
		var c;
		var i3;
		var _g3 = 0;
		while(_g3 < (triples.length / 3 | 0)) {
			var tri_c;
			var tri_b;
			var tri_a;
			var i4 = _g3 * 3 | 0;
			tri_a = triples[i4];
			tri_b = triples[i4 + 1];
			tri_c = triples[i4 + 2];
			++_g3;
			i3 = tri_a * 2 | 0;
			a = { x : poly[i3], y : poly[i3 + 1]};
			i3 = tri_b * 2 | 0;
			b = { x : poly[i3], y : poly[i3 + 1]};
			i3 = tri_c * 2 | 0;
			c = { x : poly[i3], y : poly[i3 + 1]};
			var n1 = poly.length >> 1;
			var tgs2;
			if(n1 < 3) {
				tgs2 = [];
			} else {
				var tgs3 = [];
				var avl1 = [];
				var _g12 = 0;
				var _g4 = n1;
				while(_g12 < _g4) {
					var i5 = _g12++;
					avl1.push(i5);
				}
				var i6 = 0;
				var al1 = n1;
				var i01;
				var i12;
				var i21;
				var vi2;
				var ax1;
				var ay1;
				var bx1;
				var by1;
				var cx1;
				var cy1;
				var earFound1;
				while(al1 > 3) {
					i01 = avl1[i6 % al1];
					i12 = avl1[(i6 + 1) % al1];
					i21 = avl1[(i6 + 2) % al1];
					ax1 = poly[2 * i01];
					ay1 = poly[2 * i01 + 1];
					bx1 = poly[2 * i12];
					by1 = poly[2 * i12 + 1];
					cx1 = poly[2 * i21];
					cy1 = poly[2 * i21 + 1];
					earFound1 = false;
					if((ay1 - by1) * (cx1 - bx1) + (bx1 - ax1) * (cy1 - by1) >= 0) {
						earFound1 = true;
						var _g13 = 0;
						var _g5 = al1;
						while(_g13 < _g5) {
							var j1 = _g13++;
							var vi3 = avl1[j1];
							if(vi3 == i01 || vi3 == i12 || vi3 == i21) {
								continue;
							}
							var v0x1 = cx1 - ax1;
							var v0y1 = cy1 - ay1;
							var v1x1 = bx1 - ax1;
							var v1y1 = by1 - ay1;
							var v2x1 = poly[2 * vi3] - ax1;
							var v2y1 = poly[2 * vi3 + 1] - ay1;
							var dot001 = v0x1 * v0x1 + v0y1 * v0y1;
							var dot011 = v0x1 * v1x1 + v0y1 * v1y1;
							var dot021 = v0x1 * v2x1 + v0y1 * v2y1;
							var dot111 = v1x1 * v1x1 + v1y1 * v1y1;
							var dot121 = v1x1 * v2x1 + v1y1 * v2y1;
							var invDenom1 = 1 / (dot001 * dot111 - dot011 * dot011);
							var u1 = (dot111 * dot021 - dot011 * dot121) * invDenom1;
							var v1 = (dot001 * dot121 - dot011 * dot021) * invDenom1;
							if(u1 >= 0 && v1 >= 0 && u1 + v1 < 1) {
								earFound1 = false;
								break;
							}
						}
					}
					if(earFound1) {
						tgs3.push(i01);
						tgs3.push(i12);
						tgs3.push(i21);
						avl1.splice((i6 + 1) % al1,1);
						--al1;
						i6 = 0;
					} else if(i6++ > 3 * al1) {
						break;
					}
				}
				tgs3.push(avl1[0]);
				tgs3.push(avl1[1]);
				tgs3.push(avl1[2]);
				tgs2 = tgs3;
			}
			var triples1 = justTriangles__$PolyK_ArrayTriple_$Impl_$._new(tgs2);
			var a1;
			var b1;
			var c1;
			var i7;
			var _g14 = 0;
			while(_g14 < (triples1.length / 3 | 0)) {
				var tri_c1;
				var tri_b1;
				var tri_a1;
				var i8 = _g14 * 3 | 0;
				tri_a1 = triples1[i8];
				tri_b1 = triples1[i8 + 1];
				tri_c1 = triples1[i8 + 2];
				++_g14;
				i7 = tri_a1 * 2 | 0;
				a1 = { x : poly[i7], y : poly[i7 + 1]};
				i7 = tri_b1 * 2 | 0;
				b1 = { x : poly[i7], y : poly[i7 + 1]};
				i7 = tri_c1 * 2 | 0;
				c1 = { x : poly[i7], y : poly[i7 + 1]};
				justTriangles_Draw.drawTri(this.id,false,a1,b1,c1,justTriangles_Draw.colorId);
			}
		}
	}
	,render: function(thick_,outline) {
		if(outline == null) {
			outline = true;
		}
		if(this.dirty) {
			var p;
			if(this.ppp_ == null) {
				this.ppp_ = [];
			}
			var plen = this.ppp.length;
			var plen_ = this.ppp_.length;
			var pp0 = this.ppp[0];
			var _g1 = plen_;
			var _g = plen;
			while(_g1 < _g) {
				var i = _g1++;
				pp0 = this.ppp[i];
				p = pp0.slice();
				p.reverse();
				this.ppp_[i] = p;
			}
			this.dirty = false;
		}
		if(this.fill) {
			this.fillTriangles();
		}
		var j = 0;
		var l = this.ppp_.length;
		var _g2 = 0;
		var _g11 = this.ppp_;
		while(_g2 < _g11.length) {
			var pp01 = _g11[_g2];
			++_g2;
			var _g21 = this.lineType;
			switch(_g21[1]) {
			case 0:
				var draw = new justTriangles_Draw();
				justTriangles_Draw.colorId = this.lineColors[j];
				justTriangles_Draw.set_thick(this.thicks[j]);
				var _g3 = 0;
				var _g22 = pp01.length;
				while(_g3 < _g22) {
					var i1 = _g3++;
					if(i1 % 1 == 0 && i1 < pp01.length - 1) {
						var id = this.id;
						var p0_ = pp01[i1];
						var p1_ = pp01[i1 + 1];
						var thick = this.thick / 800;
						var oldAngle = draw.p3 != null ? draw.angle1 : null;
						draw.p0 = p1_;
						draw.p1 = p0_;
						draw.halfA = Math.PI / 2;
						draw._thick = thick;
						draw.beta = Math.PI / 2 - draw.halfA;
						draw.r = draw._thick / 2 * Math.cos(draw.beta);
						draw._theta = draw.theta(draw.p0,draw.p1);
						if(draw._theta > 0) {
							if(draw.halfA < 0) {
								draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
								draw.angle1 = draw._theta - draw.halfA;
							} else {
								draw.angle1 = draw._theta + draw.halfA - Math.PI;
								draw.angle2 = draw._theta + draw.halfA;
							}
						} else if(draw.halfA > 0) {
							draw.angle1 = draw._theta + draw.halfA - Math.PI;
							draw.angle2 = draw._theta + draw.halfA;
						} else {
							draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
							draw.angle1 = draw._theta - draw.halfA;
						}
						if(draw.p3old != null) {
							draw.p3old2 = draw.p3old;
						}
						if(draw.p4old != null) {
							draw.p4old2 = draw.p4old;
						}
						if(draw.p3 != null) {
							draw.p3old = draw.p3;
						}
						if(draw.p4 != null) {
							draw.p4old = draw.p4;
						}
						draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
						draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
						var q0 = { x : draw.p3.x, y : draw.p3.y};
						var q1 = { x : draw.p4.x, y : draw.p4.y};
						draw.p0 = p0_;
						draw.p1 = p1_;
						draw._theta = draw.theta(draw.p0,draw.p1);
						if(draw._theta > 0) {
							if(draw.halfA < 0) {
								draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
								draw.angle1 = draw._theta - draw.halfA;
							} else {
								draw.angle1 = draw._theta + draw.halfA - Math.PI;
								draw.angle2 = draw._theta + draw.halfA;
							}
						} else if(draw.halfA > 0) {
							draw.angle1 = draw._theta + draw.halfA - Math.PI;
							draw.angle2 = draw._theta + draw.halfA;
						} else {
							draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
							draw.angle1 = draw._theta - draw.halfA;
						}
						if(draw.p3old != null) {
							draw.p3old2 = draw.p3old;
						}
						if(draw.p4old != null) {
							draw.p4old2 = draw.p4old;
						}
						if(draw.p3 != null) {
							draw.p3old = draw.p3;
						}
						if(draw.p4 != null) {
							draw.p4old = draw.p4;
						}
						draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
						draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
						if(draw.p3old2 != null) {
							var clockWise = justTriangles_Draw.dist(draw.p3old2,p1_) > justTriangles_Draw.dist(draw.p4old2,p1_);
							if(oldAngle != null) {
								var dif = Math.abs(draw.angle1 - oldAngle);
								if(dif > 0.1) {
									var oldThickness = justTriangles_Draw.thickness;
									justTriangles_Draw.thickness = thick / 2;
									if(clockWise) {
										var dx = p0_.x;
										var dy = p0_.y;
										var radius = thick / 4;
										var start = draw.angle1;
										var p1 = [];
										var angle = 0;
										var angleInc = Math.PI * 2 / 240;
										var sides = Math.round(240);
										var nextAngle;
										if(dif < 0) {
											var i2 = -1;
											while(true) {
												angle = i2 * angleInc;
												--i2;
												nextAngle = angle + start;
												if(angle <= dif) {
													break;
												}
												p1.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
											}
										} else {
											var i3 = -1;
											while(true) {
												angle = i3 * angleInc;
												++i3;
												nextAngle = angle + start;
												if(angle >= dif + angleInc) {
													break;
												}
												p1.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
											}
											p1.reverse();
										}
										var p2 = p1;
										justTriangles_Draw.q0 = p2[0];
										justTriangles_Draw.q1 = p2[0];
										var draw1 = new justTriangles_Draw();
										draw1.create2Lines(p2[0],p2[1],p2[2],justTriangles_Draw.thickness);
										var q3 = draw1.p3;
										var q4 = draw1.p4;
										justTriangles_Draw.q0 = q3;
										justTriangles_Draw.q1 = q4;
										var draw2 = draw1;
										var _g12 = 1;
										var _g4 = p2.length - 2;
										while(_g12 < _g4) {
											var i4 = _g12++;
											draw2.rebuildAsPoly(p2[i4 + 2]);
											var q31 = draw2.p3;
											justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p0_,justTriangles_Draw.colorId);
											justTriangles_Draw.q0 = q31;
										}
									} else {
										var dx1 = p0_.x;
										var dy1 = p0_.y;
										var radius1 = thick / 4;
										var start1 = draw.angle2;
										var dA = -dif;
										var p3 = [];
										var angle1 = 0;
										var angleInc1 = Math.PI * 2 / 240;
										var sides1 = Math.round(240);
										var nextAngle1;
										if(dA < 0) {
											var i5 = -1;
											while(true) {
												angle1 = i5 * angleInc1;
												--i5;
												nextAngle1 = angle1 + start1;
												if(angle1 <= dA) {
													break;
												}
												p3.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
											}
										} else {
											var i6 = -1;
											while(true) {
												angle1 = i6 * angleInc1;
												++i6;
												nextAngle1 = angle1 + start1;
												if(angle1 >= dA + angleInc1) {
													break;
												}
												p3.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
											}
											p3.reverse();
										}
										var p4 = p3;
										justTriangles_Draw.q0 = p4[0];
										justTriangles_Draw.q1 = p4[0];
										var draw3 = new justTriangles_Draw();
										draw3.create2Lines(p4[0],p4[1],p4[2],justTriangles_Draw.thickness);
										var q32 = draw3.p3;
										var q41 = draw3.p4;
										justTriangles_Draw.q0 = q32;
										justTriangles_Draw.q1 = q41;
										var draw4 = draw3;
										var _g13 = 1;
										var _g5 = p4.length - 2;
										while(_g13 < _g5) {
											var i7 = _g13++;
											draw4.rebuildAsPoly(p4[i7 + 2]);
											var q33 = draw4.p3;
											justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q33,p0_,justTriangles_Draw.colorId);
											justTriangles_Draw.q0 = q33;
										}
									}
									justTriangles_Draw.thickness = oldThickness;
								}
							}
							if(clockWise) {
								justTriangles_Draw.drawTri(id,true,draw.p3old2,q1,p0_,justTriangles_Draw.colorId);
							} else {
								justTriangles_Draw.drawTri(id,true,draw.p4old2,q0,p0_,justTriangles_Draw.colorId);
							}
						}
						justTriangles_Draw.drawTri(id,true,draw.p3old,draw.p3,draw.p4old,justTriangles_Draw.colorId);
						justTriangles_Draw.drawTri(id,true,draw.p3old,draw.p3,draw.p4,justTriangles_Draw.colorId);
					}
				}
				break;
			case 1:
				var draw5 = new justTriangles_Draw();
				justTriangles_Draw.colorId = this.lineColors[j];
				justTriangles_Draw.set_thick(this.thicks[j]);
				var _g31 = 0;
				var _g23 = pp01.length;
				while(_g31 < _g23) {
					var i8 = _g31++;
					if(i8 % 1 == 0 && i8 < pp01.length - 1) {
						var id1 = this.id;
						var p0_1 = pp01[i8];
						var p1_1 = pp01[i8 + 1];
						var thick1 = this.thick / 800;
						var oldAngle1 = draw5.p3 != null ? draw5.angle1 : null;
						draw5.p0 = p1_1;
						draw5.p1 = p0_1;
						draw5.halfA = Math.PI / 2;
						draw5._thick = thick1;
						draw5.beta = Math.PI / 2 - draw5.halfA;
						draw5.r = draw5._thick / 2 * Math.cos(draw5.beta);
						draw5._theta = draw5.theta(draw5.p0,draw5.p1);
						if(draw5._theta > 0) {
							if(draw5.halfA < 0) {
								draw5.angle2 = draw5._theta + draw5.halfA + Math.PI / 2;
								draw5.angle1 = draw5._theta - draw5.halfA;
							} else {
								draw5.angle1 = draw5._theta + draw5.halfA - Math.PI;
								draw5.angle2 = draw5._theta + draw5.halfA;
							}
						} else if(draw5.halfA > 0) {
							draw5.angle1 = draw5._theta + draw5.halfA - Math.PI;
							draw5.angle2 = draw5._theta + draw5.halfA;
						} else {
							draw5.angle2 = draw5._theta + draw5.halfA + Math.PI / 2;
							draw5.angle1 = draw5._theta - draw5.halfA;
						}
						if(draw5.p3old != null) {
							draw5.p3old2 = draw5.p3old;
						}
						if(draw5.p4old != null) {
							draw5.p4old2 = draw5.p4old;
						}
						if(draw5.p3 != null) {
							draw5.p3old = draw5.p3;
						}
						if(draw5.p4 != null) {
							draw5.p4old = draw5.p4;
						}
						draw5.p3 = { x : draw5.p1.x + draw5.r * Math.cos(draw5.angle1), y : draw5.p1.y + draw5.r * Math.sin(draw5.angle1)};
						draw5.p4 = { x : draw5.p1.x + draw5.r * Math.cos(draw5.angle2), y : draw5.p1.y + draw5.r * Math.sin(draw5.angle2)};
						var q01 = { x : draw5.p3.x, y : draw5.p3.y};
						var q11 = { x : draw5.p4.x, y : draw5.p4.y};
						draw5.p0 = p0_1;
						draw5.p1 = p1_1;
						draw5._theta = draw5.theta(draw5.p0,draw5.p1);
						if(draw5._theta > 0) {
							if(draw5.halfA < 0) {
								draw5.angle2 = draw5._theta + draw5.halfA + Math.PI / 2;
								draw5.angle1 = draw5._theta - draw5.halfA;
							} else {
								draw5.angle1 = draw5._theta + draw5.halfA - Math.PI;
								draw5.angle2 = draw5._theta + draw5.halfA;
							}
						} else if(draw5.halfA > 0) {
							draw5.angle1 = draw5._theta + draw5.halfA - Math.PI;
							draw5.angle2 = draw5._theta + draw5.halfA;
						} else {
							draw5.angle2 = draw5._theta + draw5.halfA + Math.PI / 2;
							draw5.angle1 = draw5._theta - draw5.halfA;
						}
						if(draw5.p3old != null) {
							draw5.p3old2 = draw5.p3old;
						}
						if(draw5.p4old != null) {
							draw5.p4old2 = draw5.p4old;
						}
						if(draw5.p3 != null) {
							draw5.p3old = draw5.p3;
						}
						if(draw5.p4 != null) {
							draw5.p4old = draw5.p4;
						}
						draw5.p3 = { x : draw5.p1.x + draw5.r * Math.cos(draw5.angle1), y : draw5.p1.y + draw5.r * Math.sin(draw5.angle1)};
						draw5.p4 = { x : draw5.p1.x + draw5.r * Math.cos(draw5.angle2), y : draw5.p1.y + draw5.r * Math.sin(draw5.angle2)};
						if(draw5.p3old2 != null) {
							var clockWise1 = justTriangles_Draw.dist(draw5.p3old2,p1_1) > justTriangles_Draw.dist(draw5.p4old2,p1_1);
							if(clockWise1) {
								justTriangles_Draw.drawTri(id1,true,draw5.p3old2,q11,p0_1,justTriangles_Draw.colorId);
							} else {
								justTriangles_Draw.drawTri(id1,true,draw5.p4old2,q01,p0_1,justTriangles_Draw.colorId);
							}
						}
						justTriangles_Draw.drawTri(id1,true,draw5.p3old,draw5.p3,draw5.p4old,justTriangles_Draw.colorId);
						justTriangles_Draw.drawTri(id1,true,draw5.p3old,draw5.p3,draw5.p4,justTriangles_Draw.colorId);
					}
				}
				break;
			case 2:
				justTriangles_Draw.colorId = this.lineColors[j];
				var id2 = this.id;
				justTriangles_Draw.q0 = pp01[0];
				justTriangles_Draw.q1 = pp01[0];
				var draw6 = new justTriangles_Draw();
				draw6.create2Lines(pp01[0],pp01[1],pp01[2],justTriangles_Draw.thickness);
				var q34 = draw6.p3;
				var q42 = draw6.p4;
				justTriangles_Draw.q0 = q34;
				justTriangles_Draw.q1 = q42;
				var draw7 = draw6;
				var _g14 = 1;
				var _g6 = pp01.length - 2;
				while(_g14 < _g6) {
					var i9 = _g14++;
					draw7.rebuildAsPoly(pp01[i9 + 2]);
					var q35 = draw7.p3;
					var q43 = draw7.p4;
					justTriangles_Draw.drawTri(id2,outline,justTriangles_Draw.q0,q35,justTriangles_Draw.q1,justTriangles_Draw.colorId);
					justTriangles_Draw.drawTri(id2,outline,justTriangles_Draw.q1,q35,q43,justTriangles_Draw.colorId);
					justTriangles_Draw.q0 = q35;
					justTriangles_Draw.q1 = q43;
				}
				break;
			case 3:
				justTriangles_Draw.colorId = this.lineColors[j];
				var _g32 = 0;
				var _g24 = pp01.length;
				while(_g32 < _g24) {
					var i10 = _g32++;
					if(i10 % 1 == 0 && i10 < pp01.length - 2) {
						var id3 = this.id;
						var draw8 = new justTriangles_Draw();
						draw8.create2Lines(pp01[i10],pp01[i10 + 1],pp01[i10 + 2],justTriangles_Draw.thickness);
						var q36 = draw8.p3;
						var q44 = draw8.p4;
						if(i10 != 0) {
							justTriangles_Draw.drawTri(id3,outline,justTriangles_Draw.q0,q36,justTriangles_Draw.q1,justTriangles_Draw.colorId);
							justTriangles_Draw.drawTri(id3,outline,justTriangles_Draw.q1,q36,q44,justTriangles_Draw.colorId);
						}
						justTriangles_Draw.q0 = q36;
						justTriangles_Draw.q1 = q44;
					}
				}
				break;
			case 4:
				justTriangles_Draw.colorId = this.lineColors[j];
				var _g33 = 0;
				var _g25 = pp01.length;
				while(_g33 < _g25) {
					var i11 = _g33++;
					if(i11 % 1 == 0 && i11 < pp01.length - 2) {
						var id4 = this.id;
						var p0_2 = pp01[i11];
						var p1_2 = pp01[i11 + 1];
						var thick2 = this.thick / 800;
						var draw9 = new justTriangles_Draw();
						draw9.p0 = p1_2;
						draw9.p1 = p0_2;
						draw9.halfA = Math.PI / 2;
						draw9._thick = thick2;
						draw9.beta = Math.PI / 2 - draw9.halfA;
						draw9.r = draw9._thick / 2 * Math.cos(draw9.beta);
						draw9._theta = draw9.theta(draw9.p0,draw9.p1);
						if(draw9._theta > 0) {
							if(draw9.halfA < 0) {
								draw9.angle2 = draw9._theta + draw9.halfA + Math.PI / 2;
								draw9.angle1 = draw9._theta - draw9.halfA;
							} else {
								draw9.angle1 = draw9._theta + draw9.halfA - Math.PI;
								draw9.angle2 = draw9._theta + draw9.halfA;
							}
						} else if(draw9.halfA > 0) {
							draw9.angle1 = draw9._theta + draw9.halfA - Math.PI;
							draw9.angle2 = draw9._theta + draw9.halfA;
						} else {
							draw9.angle2 = draw9._theta + draw9.halfA + Math.PI / 2;
							draw9.angle1 = draw9._theta - draw9.halfA;
						}
						if(draw9.p3old != null) {
							draw9.p3old2 = draw9.p3old;
						}
						if(draw9.p4old != null) {
							draw9.p4old2 = draw9.p4old;
						}
						if(draw9.p3 != null) {
							draw9.p3old = draw9.p3;
						}
						if(draw9.p4 != null) {
							draw9.p4old = draw9.p4;
						}
						draw9.p3 = { x : draw9.p1.x + draw9.r * Math.cos(draw9.angle1), y : draw9.p1.y + draw9.r * Math.sin(draw9.angle1)};
						draw9.p4 = { x : draw9.p1.x + draw9.r * Math.cos(draw9.angle2), y : draw9.p1.y + draw9.r * Math.sin(draw9.angle2)};
						var q02 = { x : draw9.p3.x, y : draw9.p3.y};
						var q12 = { x : draw9.p4.x, y : draw9.p4.y};
						draw9.p0 = p0_2;
						draw9.p1 = p1_2;
						draw9._theta = draw9.theta(draw9.p0,draw9.p1);
						if(draw9._theta > 0) {
							if(draw9.halfA < 0) {
								draw9.angle2 = draw9._theta + draw9.halfA + Math.PI / 2;
								draw9.angle1 = draw9._theta - draw9.halfA;
							} else {
								draw9.angle1 = draw9._theta + draw9.halfA - Math.PI;
								draw9.angle2 = draw9._theta + draw9.halfA;
							}
						} else if(draw9.halfA > 0) {
							draw9.angle1 = draw9._theta + draw9.halfA - Math.PI;
							draw9.angle2 = draw9._theta + draw9.halfA;
						} else {
							draw9.angle2 = draw9._theta + draw9.halfA + Math.PI / 2;
							draw9.angle1 = draw9._theta - draw9.halfA;
						}
						if(draw9.p3old != null) {
							draw9.p3old2 = draw9.p3old;
						}
						if(draw9.p4old != null) {
							draw9.p4old2 = draw9.p4old;
						}
						if(draw9.p3 != null) {
							draw9.p3old = draw9.p3;
						}
						if(draw9.p4 != null) {
							draw9.p4old = draw9.p4;
						}
						draw9.p3 = { x : draw9.p1.x + draw9.r * Math.cos(draw9.angle1), y : draw9.p1.y + draw9.r * Math.sin(draw9.angle1)};
						draw9.p4 = { x : draw9.p1.x + draw9.r * Math.cos(draw9.angle2), y : draw9.p1.y + draw9.r * Math.sin(draw9.angle2)};
						var oldThickness1 = justTriangles_Draw.thickness;
						justTriangles_Draw.thickness = thick2 / 2;
						var temp = draw9.angle1;
						var dx2 = p0_2.x;
						var dy2 = p0_2.y;
						var radius2 = thick2 / 4;
						var dA1 = Math.PI;
						var p5 = [];
						var angle2 = 0;
						var angleInc2 = Math.PI * 2 / 24;
						var sides2 = Math.round(24);
						var nextAngle2;
						if(dA1 < 0) {
							var i12 = -1;
							while(true) {
								angle2 = i12 * angleInc2;
								--i12;
								nextAngle2 = angle2 + temp;
								if(angle2 <= dA1) {
									break;
								}
								p5.push({ x : dx2 + radius2 * Math.cos(nextAngle2), y : dy2 + radius2 * Math.sin(nextAngle2)});
							}
						} else {
							var i13 = -1;
							while(true) {
								angle2 = i13 * angleInc2;
								++i13;
								nextAngle2 = angle2 + temp;
								if(angle2 >= dA1 + angleInc2) {
									break;
								}
								p5.push({ x : dx2 + radius2 * Math.cos(nextAngle2), y : dy2 + radius2 * Math.sin(nextAngle2)});
							}
						}
						p5.reverse();
						var p6 = p5;
						justTriangles_Draw.q0 = p6[0];
						justTriangles_Draw.q1 = p6[0];
						var draw10 = new justTriangles_Draw();
						draw10.create2Lines(p6[0],p6[1],p6[2],justTriangles_Draw.thickness);
						var q37 = draw10.p3;
						var q45 = draw10.p4;
						justTriangles_Draw.q0 = q37;
						justTriangles_Draw.q1 = q45;
						var draw11 = draw10;
						var _g15 = 1;
						var _g7 = p6.length - 2;
						while(_g15 < _g7) {
							var i14 = _g15++;
							draw11.rebuildAsPoly(p6[i14 + 2]);
							var q38 = draw11.p3;
							justTriangles_Draw.drawTri(id4,true,justTriangles_Draw.q0,q38,p0_2,justTriangles_Draw.colorId);
							justTriangles_Draw.q0 = q38;
						}
						temp += Math.PI;
						var dx3 = p1_2.x;
						var dy3 = p1_2.y;
						var radius3 = thick2 / 4;
						var dA2 = Math.PI;
						var p7 = [];
						var angle3 = 0;
						var angleInc3 = Math.PI * 2 / 24;
						var sides3 = Math.round(24);
						var nextAngle3;
						if(dA2 < 0) {
							var i15 = -1;
							while(true) {
								angle3 = i15 * angleInc3;
								--i15;
								nextAngle3 = angle3 + temp;
								if(angle3 <= dA2) {
									break;
								}
								p7.push({ x : dx3 + radius3 * Math.cos(nextAngle3), y : dy3 + radius3 * Math.sin(nextAngle3)});
							}
						} else {
							var i16 = -1;
							while(true) {
								angle3 = i16 * angleInc3;
								++i16;
								nextAngle3 = angle3 + temp;
								if(angle3 >= dA2 + angleInc3) {
									break;
								}
								p7.push({ x : dx3 + radius3 * Math.cos(nextAngle3), y : dy3 + radius3 * Math.sin(nextAngle3)});
							}
						}
						p7.reverse();
						var p8 = p7;
						justTriangles_Draw.q0 = p8[0];
						justTriangles_Draw.q1 = p8[0];
						var draw12 = new justTriangles_Draw();
						draw12.create2Lines(p8[0],p8[1],p8[2],justTriangles_Draw.thickness);
						var q39 = draw12.p3;
						var q46 = draw12.p4;
						justTriangles_Draw.q0 = q39;
						justTriangles_Draw.q1 = q46;
						var draw13 = draw12;
						var _g16 = 1;
						var _g8 = p8.length - 2;
						while(_g16 < _g8) {
							var i17 = _g16++;
							draw13.rebuildAsPoly(p8[i17 + 2]);
							var q310 = draw13.p3;
							justTriangles_Draw.drawTri(id4,true,justTriangles_Draw.q0,q310,p1_2,justTriangles_Draw.colorId);
							justTriangles_Draw.q0 = q310;
						}
						justTriangles_Draw.thickness = oldThickness1;
						var q311 = { x : draw9.p3.x, y : draw9.p3.y};
						var q47 = { x : draw9.p4.x, y : draw9.p4.y};
						justTriangles_Draw.drawTri(id4,true,q02,q311,q12,justTriangles_Draw.colorId);
						justTriangles_Draw.drawTri(id4,true,q02,q311,q47,justTriangles_Draw.colorId);
					}
				}
				break;
			case 5:
				justTriangles_Draw.colorId = this.lineColors[j];
				var _g34 = 0;
				var _g26 = pp01.length;
				while(_g34 < _g26) {
					var i18 = _g34++;
					if(i18 % 1 == 0 && i18 < pp01.length - 2) {
						var id5 = this.id;
						var p0_3 = pp01[i18];
						var p1_3 = pp01[i18 + 1];
						var thick3 = this.thick / 800;
						var draw14 = new justTriangles_Draw();
						draw14.p0 = p1_3;
						draw14.p1 = p0_3;
						draw14.halfA = Math.PI / 2;
						draw14._thick = thick3;
						draw14.beta = Math.PI / 2 - draw14.halfA;
						draw14.r = draw14._thick / 2 * Math.cos(draw14.beta);
						draw14._theta = draw14.theta(draw14.p0,draw14.p1);
						if(draw14._theta > 0) {
							if(draw14.halfA < 0) {
								draw14.angle2 = draw14._theta + draw14.halfA + Math.PI / 2;
								draw14.angle1 = draw14._theta - draw14.halfA;
							} else {
								draw14.angle1 = draw14._theta + draw14.halfA - Math.PI;
								draw14.angle2 = draw14._theta + draw14.halfA;
							}
						} else if(draw14.halfA > 0) {
							draw14.angle1 = draw14._theta + draw14.halfA - Math.PI;
							draw14.angle2 = draw14._theta + draw14.halfA;
						} else {
							draw14.angle2 = draw14._theta + draw14.halfA + Math.PI / 2;
							draw14.angle1 = draw14._theta - draw14.halfA;
						}
						if(draw14.p3old != null) {
							draw14.p3old2 = draw14.p3old;
						}
						if(draw14.p4old != null) {
							draw14.p4old2 = draw14.p4old;
						}
						if(draw14.p3 != null) {
							draw14.p3old = draw14.p3;
						}
						if(draw14.p4 != null) {
							draw14.p4old = draw14.p4;
						}
						draw14.p3 = { x : draw14.p1.x + draw14.r * Math.cos(draw14.angle1), y : draw14.p1.y + draw14.r * Math.sin(draw14.angle1)};
						draw14.p4 = { x : draw14.p1.x + draw14.r * Math.cos(draw14.angle2), y : draw14.p1.y + draw14.r * Math.sin(draw14.angle2)};
						var q03 = { x : draw14.p3.x, y : draw14.p3.y};
						var q13 = { x : draw14.p4.x, y : draw14.p4.y};
						draw14.p0 = p0_3;
						draw14.p1 = p1_3;
						draw14._theta = draw14.theta(draw14.p0,draw14.p1);
						if(draw14._theta > 0) {
							if(draw14.halfA < 0) {
								draw14.angle2 = draw14._theta + draw14.halfA + Math.PI / 2;
								draw14.angle1 = draw14._theta - draw14.halfA;
							} else {
								draw14.angle1 = draw14._theta + draw14.halfA - Math.PI;
								draw14.angle2 = draw14._theta + draw14.halfA;
							}
						} else if(draw14.halfA > 0) {
							draw14.angle1 = draw14._theta + draw14.halfA - Math.PI;
							draw14.angle2 = draw14._theta + draw14.halfA;
						} else {
							draw14.angle2 = draw14._theta + draw14.halfA + Math.PI / 2;
							draw14.angle1 = draw14._theta - draw14.halfA;
						}
						if(draw14.p3old != null) {
							draw14.p3old2 = draw14.p3old;
						}
						if(draw14.p4old != null) {
							draw14.p4old2 = draw14.p4old;
						}
						if(draw14.p3 != null) {
							draw14.p3old = draw14.p3;
						}
						if(draw14.p4 != null) {
							draw14.p4old = draw14.p4;
						}
						draw14.p3 = { x : draw14.p1.x + draw14.r * Math.cos(draw14.angle1), y : draw14.p1.y + draw14.r * Math.sin(draw14.angle1)};
						draw14.p4 = { x : draw14.p1.x + draw14.r * Math.cos(draw14.angle2), y : draw14.p1.y + draw14.r * Math.sin(draw14.angle2)};
						var q312 = { x : draw14.p3.x, y : draw14.p3.y};
						var q48 = { x : draw14.p4.x, y : draw14.p4.y};
						justTriangles_Draw.drawTri(id5,true,q03,q312,q13,justTriangles_Draw.colorId);
						justTriangles_Draw.drawTri(id5,true,q03,q312,q48,justTriangles_Draw.colorId);
					}
				}
				break;
			case 6:
				justTriangles_Draw.colorId = this.lineColors[j];
				var _g35 = 0;
				var _g27 = pp01.length;
				while(_g35 < _g27) {
					var i19 = _g35++;
					if(i19 % 1 == 0 && i19 < pp01.length - 2) {
						var id6 = this.id;
						var draw15 = new justTriangles_Draw();
						draw15.create2Lines(pp01[i19],pp01[i19 + 1],pp01[i19 + 2],justTriangles_Draw.thickness);
						var q313 = draw15.p3;
						var q49 = draw15.p4;
						if(i19 != 0) {
							justTriangles_Draw.drawTri(id6,outline,justTriangles_Draw.q0,q313,justTriangles_Draw.q1,justTriangles_Draw.colorId);
							justTriangles_Draw.drawTri(id6,outline,justTriangles_Draw.q1,q313,q49,justTriangles_Draw.colorId);
						}
						justTriangles_Draw.q0 = q313;
						justTriangles_Draw.q1 = q49;
					}
				}
				break;
			}
			++j;
		}
	}
	,reverseEntries: function() {
		var p;
		if(this.ppp_ == null) {
			this.ppp_ = [];
		}
		var plen = this.ppp.length;
		var plen_ = this.ppp_.length;
		var pp0 = this.ppp[0];
		var _g1 = plen_;
		var _g = plen;
		while(_g1 < _g) {
			var i = _g1++;
			pp0 = this.ppp[i];
			p = pp0.slice();
			p.reverse();
			this.ppp_[i] = p;
		}
		this.dirty = false;
	}
	,clear: function() {
		this.lineColors = [];
		this.fillColors = [];
		this.thicks = [];
		this.ppp = [];
		this.minX = 1;
		this.maxX = -1;
		this.minY = 1;
		this.maxY = -1;
		this.dirty = true;
		this.ppp_ = null;
		this.ppp = null;
		this.pp = null;
		this.p0 = null;
	}
	,__class__: justTriangles_PathContext
};
var justTriangles_PathContextTrace = function() {
};
justTriangles_PathContextTrace.__name__ = true;
justTriangles_PathContextTrace.__interfaces__ = [justTriangles_IPathContext];
justTriangles_PathContextTrace.prototype = {
	moveTo: function(x,y) {
		console.log("moveTo( " + x + ", " + y + " );");
	}
	,lineTo: function(x,y) {
		console.log("lineTo( " + x + ", " + y + " );");
	}
	,quadTo: function(x1,y1,x2,y2) {
		console.log("quadTo( " + x1 + ", " + y1 + ", " + x2 + ", " + y2 + " );");
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		console.log("curveTo( " + x1 + ", " + y1 + ", " + x2 + ", " + y2 + ", " + x3 + ", " + y3 + " );");
	}
	,__class__: justTriangles_PathContextTrace
};
var justTriangles__$PolyK_ArrayPairs_$Impl_$ = {};
justTriangles__$PolyK_ArrayPairs_$Impl_$.__name__ = true;
justTriangles__$PolyK_ArrayPairs_$Impl_$._new = function(arr) {
	var this1 = arr;
	return this1;
};
justTriangles__$PolyK_ArrayPairs_$Impl_$.get_length = function(this1) {
	return this1.length / 2 | 0;
};
justTriangles__$PolyK_ArrayPairs_$Impl_$.access = function(this1,key) {
	var i = key * 2 | 0;
	return { x : this1[i], y : this1[i + 1]};
};
justTriangles__$PolyK_ArrayPairs_$Impl_$.reverse = function(this1) {
	var arr = [];
	var _g = 0;
	var _g1 = justTriangles__$PolyK_ArrayPairs_$Impl_$._new(this1);
	while(_g < (_g1.length / 2 | 0)) {
		var i_y;
		var i_x;
		var i = _g * 2 | 0;
		i_x = _g1[i];
		i_y = _g1[i + 1];
		++_g;
		arr.unshift(i_y);
		arr.unshift(i_x);
	}
	this1 = arr;
	return arr;
};
var justTriangles__$PolyK_ArrayTriple_$Impl_$ = {};
justTriangles__$PolyK_ArrayTriple_$Impl_$.__name__ = true;
justTriangles__$PolyK_ArrayTriple_$Impl_$._new = function(arr) {
	var this1 = arr;
	return this1;
};
justTriangles__$PolyK_ArrayTriple_$Impl_$.get_length = function(this1) {
	return this1.length / 3 | 0;
};
justTriangles__$PolyK_ArrayTriple_$Impl_$.access = function(this1,key) {
	var i = key * 3 | 0;
	return { a : this1[i], b : this1[i + 1], c : this1[i + 2]};
};
justTriangles__$PolyK_ArrayTriple_$Impl_$.reverse = function(this1) {
	var arr = [];
	var _g = 0;
	var _g1 = justTriangles__$PolyK_ArrayTriple_$Impl_$._new(this1);
	while(_g < (_g1.length / 3 | 0)) {
		var i_c;
		var i_b;
		var i_a;
		var i = _g * 3 | 0;
		i_a = _g1[i];
		i_b = _g1[i + 1];
		i_c = _g1[i + 2];
		++_g;
		arr.unshift(i_c);
		arr.unshift(i_b);
		arr.unshift(i_a);
	}
	this1 = arr;
	return arr;
};
var justTriangles_PolyK = function() {
};
justTriangles_PolyK.__name__ = true;
justTriangles_PolyK.isSimple = function(p) {
	var n = p.length >> 1;
	if(n < 4) {
		return true;
	}
	var a1_y;
	var a1_x = 0.;
	a1_y = 0.;
	var a1_flag = false;
	var a2_y;
	var a2_x = 0.;
	a2_y = 0.;
	var a2_flag = false;
	var b1_y;
	var b1_x = 0.;
	b1_y = 0.;
	var b1_flag = false;
	var b2_y;
	var b2_x = 0.;
	b2_y = 0.;
	var b2_flag = false;
	var c_x = 0.;
	var c_y = 0.;
	var c_flag = false;
	var ind;
	var _g1 = 0;
	var _g = n;
	while(_g1 < _g) {
		var i = _g1++;
		ind = 2 * i | 0;
		a1_x = p[ind];
		a1_y = p[ind + 1];
		if(i == n - 1) {
			a2_x = p[0];
			a2_y = p[1];
		} else {
			a2_x = p[ind + 2];
			a2_y = p[ind + 3];
		}
		var _g3 = 0;
		var _g2 = n;
		while(_g3 < _g2) {
			var j = _g3++;
			if(Math.abs(i - j) < 2) {
				continue;
			}
			if(j == n - 1 && i == 0) {
				continue;
			}
			if(i == n - 1 && j == 0) {
				continue;
			}
			ind = 2 * j;
			b1_x = p[ind];
			b1_y = p[ind + 1];
			if(j == n - 1) {
				b2_x = p[0];
				b2_y = p[1];
			} else {
				b2_x = p[ind + 2];
				b2_y = p[ind + 3];
			}
			var dax = a1_x - a2_x;
			var dbx = b1_x - b2_x;
			var day = a1_y - a2_y;
			var dby = b1_y - b2_y;
			var Den = dax * dby - day * dbx;
			var c;
			if(Den == 0) {
				c = null;
			} else {
				var A = a1_x * a2_y - a1_y * a2_x;
				var B = b1_x * b2_y - b1_y * b2_x;
				var I = { x : (A * dbx - dax * B) / Den, y : (A * dby - day * B) / Den, flag : false};
				var c1;
				var minx = Math.min(a1_x,a2_x);
				var maxx = Math.max(a1_x,a2_x);
				var miny = Math.min(a1_y,a2_y);
				var maxy = Math.max(a1_y,a2_y);
				if(minx == maxx ? miny <= I.y && I.y <= maxy : miny == maxy ? minx <= I.x && I.x <= maxx : minx <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx && miny <= I.y + 0.0000000001 && I.y - 0.0000000001 <= maxy) {
					var minx1 = Math.min(b1_x,b2_x);
					var maxx1 = Math.max(b1_x,b2_x);
					var miny1 = Math.min(b1_y,b2_y);
					var maxy1 = Math.max(b1_y,b2_y);
					if(minx1 == maxx1) {
						if(miny1 <= I.y) {
							c1 = I.y <= maxy1;
						} else {
							c1 = false;
						}
					} else if(miny1 == maxy1) {
						if(minx1 <= I.x) {
							c1 = I.x <= maxx1;
						} else {
							c1 = false;
						}
					} else if(minx1 <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx1 && miny1 <= I.y + 0.0000000001) {
						c1 = I.y - 0.0000000001 <= maxy1;
					} else {
						c1 = false;
					}
				} else {
					c1 = false;
				}
				if(c1) {
					c = I;
				} else {
					c = null;
				}
			}
			if(c != null) {
				return false;
			}
		}
	}
	return true;
};
justTriangles_PolyK.isConvex = function(p) {
	if(p.length < 6) {
		return true;
	}
	var l = p.length - 4;
	var l2 = l / 2 | 0;
	var i;
	var _g1 = 0;
	var _g = l2;
	while(_g1 < _g) {
		var k = _g1++;
		i = k * 2;
		var bx = p[i + 2];
		var by = p[i + 3];
		if(!((p[i + 1] - by) * (p[i + 4] - bx) + (bx - p[i]) * (p[i + 5] - by) >= 0)) {
			return false;
		}
	}
	var bx1 = p[l + 2];
	var by1 = p[l + 3];
	if(!((p[l + 1] - by1) * (p[0] - bx1) + (bx1 - p[l]) * (p[1] - by1) >= 0)) {
		return false;
	}
	var bx2 = p[0];
	var by2 = p[1];
	if(!((p[l + 3] - by2) * (p[2] - bx2) + (bx2 - p[l + 2]) * (p[3] - by2) >= 0)) {
		return false;
	}
	return true;
};
justTriangles_PolyK.getArea = function(p) {
	if(p.length < 6) {
		return 0;
	}
	var l = p.length - 2;
	var sum = 0.;
	var l2 = l / 2 | 0;
	var i;
	var _g1 = 0;
	var _g = l2;
	while(_g1 < _g) {
		var k = _g1++;
		i = k * 2;
		sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
	}
	sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
	return -sum * 0.5;
};
justTriangles_PolyK.getAABB = function(p) {
	var minx = Infinity;
	var miny = Infinity;
	var maxx = -Infinity;
	var maxy = -Infinity;
	var _g = 0;
	var _g1 = justTriangles__$PolyK_ArrayPairs_$Impl_$._new(p);
	while(_g < (_g1.length / 2 | 0)) {
		var i_y;
		var i_x;
		var i = _g * 2 | 0;
		i_x = _g1[i];
		i_y = _g1[i + 1];
		++_g;
		minx = Math.min(minx,i_x);
		maxx = Math.max(maxx,i_x);
		miny = Math.min(miny,i_y);
		maxy = Math.max(maxy,i_y);
	}
	return { x : minx, y : miny, width : maxx - minx, height : maxy - miny};
};
justTriangles_PolyK.reverse = function(p) {
	var ap = justTriangles__$PolyK_ArrayPairs_$Impl_$._new(p);
	var arr = [];
	var _g = 0;
	var _g1 = justTriangles__$PolyK_ArrayPairs_$Impl_$._new(ap);
	while(_g < (_g1.length / 2 | 0)) {
		var i_y;
		var i_x;
		var i = _g * 2 | 0;
		i_x = _g1[i];
		i_y = _g1[i + 1];
		++_g;
		arr.unshift(i_y);
		arr.unshift(i_x);
	}
	ap = arr;
	return arr;
};
justTriangles_PolyK.triangulate = function(p) {
	var n = p.length >> 1;
	if(n < 3) {
		return [];
	}
	var tgs = [];
	var avl = [];
	var _g1 = 0;
	var _g = n;
	while(_g1 < _g) {
		var i = _g1++;
		avl.push(i);
	}
	var i1 = 0;
	var al = n;
	var i0;
	var i11;
	var i2;
	var vi;
	var ax;
	var ay;
	var bx;
	var by;
	var cx;
	var cy;
	var earFound;
	while(al > 3) {
		i0 = avl[i1 % al];
		i11 = avl[(i1 + 1) % al];
		i2 = avl[(i1 + 2) % al];
		ax = p[2 * i0];
		ay = p[2 * i0 + 1];
		bx = p[2 * i11];
		by = p[2 * i11 + 1];
		cx = p[2 * i2];
		cy = p[2 * i2 + 1];
		earFound = false;
		if((ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0) {
			earFound = true;
			var _g11 = 0;
			var _g2 = al;
			while(_g11 < _g2) {
				var j = _g11++;
				var vi1 = avl[j];
				if(vi1 == i0 || vi1 == i11 || vi1 == i2) {
					continue;
				}
				var v0x = cx - ax;
				var v0y = cy - ay;
				var v1x = bx - ax;
				var v1y = by - ay;
				var v2x = p[2 * vi1] - ax;
				var v2y = p[2 * vi1 + 1] - ay;
				var dot00 = v0x * v0x + v0y * v0y;
				var dot01 = v0x * v1x + v0y * v1y;
				var dot02 = v0x * v2x + v0y * v2y;
				var dot11 = v1x * v1x + v1y * v1y;
				var dot12 = v1x * v2x + v1y * v2y;
				var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
				var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
				var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
				if(u >= 0 && v >= 0 && u + v < 1) {
					earFound = false;
					break;
				}
			}
		}
		if(earFound) {
			tgs.push(i0);
			tgs.push(i11);
			tgs.push(i2);
			avl.splice((i1 + 1) % al,1);
			--al;
			i1 = 0;
		} else if(i1++ > 3 * al) {
			break;
		}
	}
	tgs.push(avl[0]);
	tgs.push(avl[1]);
	tgs.push(avl[2]);
	return tgs;
};
justTriangles_PolyK.containsPoint = function(p,px,py) {
	var n = p.length >> 1;
	var ax;
	var ay = p[2 * n - 3] - py;
	var bx = p[2 * n - 2] - px;
	var by = p[2 * n - 1] - py;
	var twoi;
	var lup = by > ay;
	var lx;
	var _g1 = 0;
	var _g = n;
	while(_g1 < _g) {
		var i = _g1++;
		ax = bx;
		ay = by;
		twoi = 2 * i;
		bx = p[twoi] - px;
		by = p[twoi + 1] - py;
		if(ay == by) {
			continue;
		}
		lup = by > ay;
	}
	var depth = 0;
	var _g11 = 0;
	var _g2 = n;
	while(_g11 < _g2) {
		var i1 = _g11++;
		ax = bx;
		ay = by;
		twoi = 2 * i1;
		bx = p[twoi] - px;
		by = p[twoi + 1] - py;
		if(ay < 0 && by < 0) {
			continue;
		}
		if(ay > 0 && by > 0) {
			continue;
		}
		if(ax < 0 && bx < 0) {
			continue;
		}
		if(ay == by && Math.min(ax,bx) <= 0) {
			return true;
		}
		if(ay == by) {
			continue;
		}
		lx = ax + (bx - ax) * -ay / (by - ay);
		if(lx == 0) {
			return true;
		}
		if(lx > 0) {
			++depth;
		}
		if(ay == 0 && lup && by > ay) {
			--depth;
		}
		if(ay == 0 && !lup && by < ay) {
			--depth;
		}
		lup = by > ay;
	}
	return (depth & 1) == 1;
};
justTriangles_PolyK.slice = function(p,ax,ay,bx,by) {
	if(justTriangles_PolyK.containsPoint(p,ax,ay) || justTriangles_PolyK.containsPoint(p,bx,by)) {
		return [p.slice(0)];
	}
	var a_y;
	var a_x = ax;
	a_y = ay;
	var a_flag = false;
	var b_y;
	var b_x = ax;
	b_y = ay;
	var b_flag = false;
	var iscs = [];
	var ps = [];
	var _g = 0;
	var _g1 = justTriangles__$PolyK_ArrayPairs_$Impl_$._new(p);
	while(_g < (_g1.length / 2 | 0)) {
		var i_y;
		var i_x;
		var i = _g * 2 | 0;
		i_x = _g1[i];
		i_y = _g1[i + 1];
		++_g;
		ps.push({ x : i_x, y : i_y, flag : false});
	}
	var l = ps.length;
	var isc;
	var skip = false;
	var _g11 = 0;
	var _g2 = l;
	while(_g11 < _g2) {
		var i1 = _g11++;
		if(skip) {
			skip = false;
			continue;
		}
		var b1 = ps[i1];
		var b2 = ps[(i1 + 1) % ps.length];
		var dax = a_x - b_x;
		var dbx = b1.x - b2.x;
		var day = a_y - b_y;
		var dby = b1.y - b2.y;
		var Den = dax * dby - day * dbx;
		if(Den == 0) {
			isc = null;
		} else {
			var A = a_x * b_y - a_y * b_x;
			var B = b1.x * b2.y - b1.y * b2.x;
			var I = { x : (A * dbx - dax * B) / Den, y : (A * dby - day * B) / Den, flag : false};
			var isc1;
			var minx = Math.min(a_x,b_x);
			var maxx = Math.max(a_x,b_x);
			var miny = Math.min(a_y,b_y);
			var maxy = Math.max(a_y,b_y);
			if(minx == maxx ? miny <= I.y && I.y <= maxy : miny == maxy ? minx <= I.x && I.x <= maxx : minx <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx && miny <= I.y + 0.0000000001 && I.y - 0.0000000001 <= maxy) {
				var minx1 = Math.min(b1.x,b2.x);
				var maxx1 = Math.max(b1.x,b2.x);
				var miny1 = Math.min(b1.y,b2.y);
				var maxy1 = Math.max(b1.y,b2.y);
				if(minx1 == maxx1) {
					if(miny1 <= I.y) {
						isc1 = I.y <= maxy1;
					} else {
						isc1 = false;
					}
				} else if(miny1 == maxy1) {
					if(minx1 <= I.x) {
						isc1 = I.x <= maxx1;
					} else {
						isc1 = false;
					}
				} else if(minx1 <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx1 && miny1 <= I.y + 0.0000000001) {
					isc1 = I.y - 0.0000000001 <= maxy1;
				} else {
					isc1 = false;
				}
			} else {
				isc1 = false;
			}
			if(isc1) {
				isc = I;
			} else {
				isc = null;
			}
		}
		var fisc = iscs[0];
		var lisc = iscs[iscs.length - 1];
		var tmp;
		var tmp1;
		if(isc != null) {
			if(fisc != null) {
				var dx = fisc.x - isc.x;
				var dy = fisc.y - isc.y;
				tmp1 = Math.sqrt(dx * dx + dy * dy) > 0.0000000001;
			} else {
				tmp1 = true;
			}
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			if(lisc != null) {
				var dx1 = lisc.x - isc.x;
				var dy1 = lisc.y - isc.y;
				tmp = Math.sqrt(dx1 * dx1 + dy1 * dy1) > 0.0000000001;
			} else {
				tmp = true;
			}
		} else {
			tmp = false;
		}
		if(tmp) {
			isc.flag = true;
			iscs.push(isc);
			ps.splice(i1 + 1,0);
			ps.splice(i1 + 1,0,isc);
			skip = true;
		}
	}
	if(iscs.length < 2) {
		return [p.slice(0)];
	}
	var comp = function(u,v) {
		var dx2 = u.x - a_x;
		var dy2 = u.y - a_y;
		var dx3 = v.x - a_x;
		var dy3 = v.y - a_y;
		var val = Math.sqrt(dx2 * dx2 + dy2 * dy2) - Math.sqrt(dx3 * dx3 + dy3 * dy3);
		if(val > 0) {
			return 1;
		}
		if(val < 0) {
			return -1;
		}
		return 0;
	};
	iscs.sort(comp);
	var pgs = [];
	var dir = 0;
	while(iscs.length > 0) {
		var n = ps.length;
		var i0 = iscs[0];
		var i11 = iscs[1];
		var ind0 = ps.indexOf(i0);
		var ind1 = ps.indexOf(i11);
		var solved = false;
		if(justTriangles_PolyK.firstWithFlag(ps,ind0) == ind1) {
			solved = true;
		} else {
			i0 = iscs[1];
			i11 = iscs[0];
			ind0 = ps.indexOf(i0);
			ind1 = ps.indexOf(i11);
			if(justTriangles_PolyK.firstWithFlag(ps,ind0) == ind1) {
				solved = true;
			}
		}
		if(solved) {
			--dir;
			var ind11 = ind1;
			var n1 = ps.length;
			var nps = [];
			if(ind11 < ind0) {
				ind11 += n1;
			}
			var l1 = ind11 + 1;
			var _g12 = ind0;
			var _g3 = l1;
			while(_g12 < _g3) {
				var i2 = _g12++;
				nps.push(ps[i2 % n1]);
			}
			var pgn = nps;
			pgs.push(pgn);
			var ind12 = ind0;
			var n2 = ps.length;
			var nps1 = [];
			if(ind12 < ind1) {
				ind12 += n2;
			}
			var l2 = ind12 + 1;
			var _g13 = ind1;
			var _g4 = l2;
			while(_g13 < _g4) {
				var i3 = _g13++;
				nps1.push(ps[i3 % n2]);
			}
			ps = nps1;
			i0.flag = i11.flag = false;
			iscs.splice(0,2);
			if(iscs.length == 0) {
				pgs.push(ps);
			}
		} else {
			++dir;
			iscs.reverse();
		}
		if(dir > 1) {
			break;
		}
	}
	var result = [];
	var l3 = pgs.length;
	var l21;
	var _g14 = 0;
	var _g5 = l3;
	while(_g14 < _g5) {
		var i4 = _g14++;
		var pg = pgs[i4];
		var npg = [];
		l21 = pg.length;
		var _g31 = 0;
		var _g21 = l21;
		while(_g31 < _g21) {
			var j = _g31++;
			npg.push(pg[j].x);
			npg.push(pg[j].y);
		}
		result.push(npg);
	}
	return result;
};
justTriangles_PolyK.raycast = function(p,x,y,dx,dy,isc) {
	var l = p.length - 2;
	var tp = [];
	var _g = 0;
	while(_g < 10) {
		var i = _g++;
		tp.push({ x : 0., y : 0., flag : false});
	}
	var a1 = tp[0];
	var a2 = tp[1];
	var b1 = tp[2];
	var b2 = tp[3];
	var c = tp[4];
	a1.x = x;
	a1.y = y;
	a2.x = x + dx;
	a2.y = y + dy;
	if(isc == null) {
		isc = { dist : 0, edge : 0, norm : { x : 0, y : 0}, refl : { x : 0, y : 0}};
	}
	isc.dist = Infinity;
	var l2 = l / 2 | 0;
	var i1;
	var _g1 = 0;
	var _g2 = l2;
	while(_g1 < _g2) {
		var k = _g1++;
		i1 = k * 2;
		b1.x = p[i1];
		b1.y = p[i1 + 1];
		b2.x = p[i1 + 2];
		b2.y = p[i1 + 3];
		var dax = a1.x - a2.x;
		var dbx = b1.x - b2.x;
		var day = a1.y - a2.y;
		var dby = b1.y - b2.y;
		var Den = dax * dby - day * dbx;
		var nisc;
		if(Den == 0) {
			nisc = null;
		} else {
			var A = a1.x * a2.y - a1.y * a2.x;
			var B = b1.x * b2.y - b1.y * b2.x;
			var I = c;
			var iDen = 1 / Den;
			I.x = (A * dbx - dax * B) * iDen;
			I.y = (A * dby - day * B) * iDen;
			var minx = Math.min(b1.x,b2.x);
			var maxx = Math.max(b1.x,b2.x);
			var miny = Math.min(b1.y,b2.y);
			var maxy = Math.max(b1.y,b2.y);
			if(!(minx == maxx ? miny <= I.y && I.y <= maxy : miny == maxy ? minx <= I.x && I.x <= maxx : minx <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx && miny <= I.y + 0.0000000001 && I.y - 0.0000000001 <= maxy)) {
				nisc = null;
			} else if(day > 0 && I.y > a1.y || day < 0 && I.y < a1.y) {
				nisc = null;
			} else if(dax > 0 && I.x > a1.x || dax < 0 && I.x < a1.x) {
				nisc = null;
			} else {
				nisc = I;
			}
		}
		if(nisc != null) {
			var dx1 = c.x - a1.x;
			var dy1 = c.y - a1.y;
			var nrl = Math.sqrt(dx1 * dx1 + dy1 * dy1);
			if(nrl < isc.dist) {
				var dx2 = b2.x - b1.x;
				var dy2 = b2.y - b1.y;
				var ibl = 1 / Math.sqrt(dx2 * dx2 + dy2 * dy2);
				var nx = -(b2.y - b1.y) * ibl;
				var ny = (b2.x - b1.x) * ibl;
				var ddot = 2 * (dx * nx + dy * ny);
				isc.dist = nrl;
				isc.norm.x = nx;
				isc.norm.y = ny;
				isc.refl.x = -ddot * nx + dx;
				isc.refl.y = -ddot * ny + dy;
				isc.edge = i1 / 2;
			}
		}
	}
	b1.x = b2.x;
	b1.y = b2.y;
	b2.x = p[0];
	b2.y = p[1];
	var dax1 = a1.x - a2.x;
	var dbx1 = b1.x - b2.x;
	var day1 = a1.y - a2.y;
	var dby1 = b1.y - b2.y;
	var Den1 = dax1 * dby1 - day1 * dbx1;
	var nisc1;
	if(Den1 == 0) {
		nisc1 = null;
	} else {
		var A1 = a1.x * a2.y - a1.y * a2.x;
		var B1 = b1.x * b2.y - b1.y * b2.x;
		var I1 = c;
		var iDen1 = 1 / Den1;
		I1.x = (A1 * dbx1 - dax1 * B1) * iDen1;
		I1.y = (A1 * dby1 - day1 * B1) * iDen1;
		var minx1 = Math.min(b1.x,b2.x);
		var maxx1 = Math.max(b1.x,b2.x);
		var miny1 = Math.min(b1.y,b2.y);
		var maxy1 = Math.max(b1.y,b2.y);
		if(!(minx1 == maxx1 ? miny1 <= I1.y && I1.y <= maxy1 : miny1 == maxy1 ? minx1 <= I1.x && I1.x <= maxx1 : minx1 <= I1.x + 0.0000000001 && I1.x - 0.0000000001 <= maxx1 && miny1 <= I1.y + 0.0000000001 && I1.y - 0.0000000001 <= maxy1)) {
			nisc1 = null;
		} else if(day1 > 0 && I1.y > a1.y || day1 < 0 && I1.y < a1.y) {
			nisc1 = null;
		} else if(dax1 > 0 && I1.x > a1.x || dax1 < 0 && I1.x < a1.x) {
			nisc1 = null;
		} else {
			nisc1 = I1;
		}
	}
	if(nisc1 != null) {
		var dx3 = c.x - a1.x;
		var dy3 = c.y - a1.y;
		var nrl1 = Math.sqrt(dx3 * dx3 + dy3 * dy3);
		if(nrl1 < isc.dist) {
			var dx4 = b2.x - b1.x;
			var dy4 = b2.y - b1.y;
			var ibl1 = 1 / Math.sqrt(dx4 * dx4 + dy4 * dy4);
			var nx1 = -(b2.y - b1.y) * ibl1;
			var ny1 = (b2.x - b1.x) * ibl1;
			var ddot1 = 2 * (dx * nx1 + dy * ny1);
			isc.dist = nrl1;
			isc.norm.x = nx1;
			isc.norm.y = ny1;
			isc.refl.x = -ddot1 * nx1 + dx;
			isc.refl.y = -ddot1 * ny1 + dy;
			isc.edge = p.length / 2 - 1;
		}
	}
	if(isc.dist != Infinity) {
		return isc;
	} else {
		return null;
	}
};
justTriangles_PolyK.closestEdge = function(p,x,y,isc) {
	var l = p.length - 2;
	var tp = [];
	var _g = 0;
	while(_g < 10) {
		var i = _g++;
		tp.push({ x : 0., y : 0., flag : false});
	}
	var a1 = tp[0];
	var b1 = tp[2];
	var b2 = tp[3];
	var c = tp[4];
	a1.x = x;
	a1.y = y;
	if(isc == null) {
		isc = { dist : 0, edge : 0, point : { x : 0, y : 0}, norm : { x : 0, y : 0}};
	}
	isc.dist = Infinity;
	var l2 = l / 2 | 0;
	var i1;
	var _g1 = 0;
	var _g2 = l2;
	while(_g1 < _g2) {
		var k = _g1++;
		i1 = k * 2;
		b1.x = p[i1];
		b1.y = p[i1 + 1];
		b2.x = p[i1 + 2];
		b2.y = p[i1 + 3];
		var x1 = a1.x;
		var y1 = a1.y;
		var x11 = b1.x;
		var y11 = b1.y;
		var x2 = b2.x;
		var y2 = b2.y;
		var A = x1 - x11;
		var B = y1 - y11;
		var C = x2 - x11;
		var D = y2 - y11;
		var dot = A * C + B * D;
		var len_sq = C * C + D * D;
		var param = dot / len_sq;
		var xx;
		var yy;
		if(param < 0 || x11 == x2 && y11 == y2) {
			xx = x11;
			yy = y11;
		} else if(param > 1) {
			xx = x2;
			yy = y2;
		} else {
			xx = x11 + param * C;
			yy = y11 + param * D;
		}
		var dx = x1 - xx;
		var dy = y1 - yy;
		var dst = Math.sqrt(dx * dx + dy * dy);
		if(dst < isc.dist) {
			isc.dist = dst;
			isc.edge = i1 >> 1;
			isc.point.x = xx;
			isc.point.y = yy;
		}
	}
	b1.x = b2.x;
	b1.y = b2.y;
	b2.x = p[0];
	b2.y = p[1];
	var x3 = a1.x;
	var y3 = a1.y;
	var x12 = b1.x;
	var y12 = b1.y;
	var x21 = b2.x;
	var y21 = b2.y;
	var A1 = x3 - x12;
	var B1 = y3 - y12;
	var C1 = x21 - x12;
	var D1 = y21 - y12;
	var dot1 = A1 * C1 + B1 * D1;
	var len_sq1 = C1 * C1 + D1 * D1;
	var param1 = dot1 / len_sq1;
	var xx1;
	var yy1;
	if(param1 < 0 || x12 == x21 && y12 == y21) {
		xx1 = x12;
		yy1 = y12;
	} else if(param1 > 1) {
		xx1 = x21;
		yy1 = y21;
	} else {
		xx1 = x12 + param1 * C1;
		yy1 = y12 + param1 * D1;
	}
	var dx1 = x3 - xx1;
	var dy1 = y3 - yy1;
	var dst1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
	if(dst1 < isc.dist) {
		isc.dist = dst1;
		isc.edge = l >> 1;
		isc.point.x = xx1;
		isc.point.y = yy1;
	}
	var idst = 1 / isc.dist;
	isc.norm.x = (x - isc.point.x) * idst;
	isc.norm.y = (y - isc.point.y) * idst;
	return isc;
};
justTriangles_PolyK.pointLineDist = function(p,a,b,edge,isc) {
	var x = p.x;
	var y = p.y;
	var x1 = a.x;
	var y1 = a.y;
	var x2 = b.x;
	var y2 = b.y;
	var A = x - x1;
	var B = y - y1;
	var C = x2 - x1;
	var D = y2 - y1;
	var dot = A * C + B * D;
	var len_sq = C * C + D * D;
	var param = dot / len_sq;
	var xx;
	var yy;
	if(param < 0 || x1 == x2 && y1 == y2) {
		xx = x1;
		yy = y1;
	} else if(param > 1) {
		xx = x2;
		yy = y2;
	} else {
		xx = x1 + param * C;
		yy = y1 + param * D;
	}
	var dx = x - xx;
	var dy = y - yy;
	var dst = Math.sqrt(dx * dx + dy * dy);
	if(dst < isc.dist) {
		isc.dist = dst;
		isc.edge = edge;
		isc.point.x = xx;
		isc.point.y = yy;
	}
};
justTriangles_PolyK.updateISC = function(dx,dy,a1,b1,b2,c,edge,isc) {
	var dx1 = c.x - a1.x;
	var dy1 = c.y - a1.y;
	var nrl = Math.sqrt(dx1 * dx1 + dy1 * dy1);
	if(nrl < isc.dist) {
		var dx2 = b2.x - b1.x;
		var dy2 = b2.y - b1.y;
		var ibl = 1 / Math.sqrt(dx2 * dx2 + dy2 * dy2);
		var nx = -(b2.y - b1.y) * ibl;
		var ny = (b2.x - b1.x) * ibl;
		var ddot = 2 * (dx * nx + dy * ny);
		isc.dist = nrl;
		isc.norm.x = nx;
		isc.norm.y = ny;
		isc.refl.x = -ddot * nx + dx;
		isc.refl.y = -ddot * ny + dy;
		isc.edge = edge;
	}
};
justTriangles_PolyK.getPoints = function(ps,ind0,ind1) {
	var n = ps.length;
	var nps = [];
	if(ind1 < ind0) {
		ind1 += n;
	}
	var l = ind1 + 1;
	var _g1 = ind0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		nps.push(ps[i % n]);
	}
	return nps;
};
justTriangles_PolyK.firstWithFlag = function(ps,ind) {
	var n = ps.length;
	while(true) {
		ind = (ind + 1) % n;
		if(ps[ind].flag) {
			return ind;
		}
	}
};
justTriangles_PolyK.pointInTriangle = function(px,py,ax,ay,bx,by,cx,cy) {
	var v0x = cx - ax;
	var v0y = cy - ay;
	var v1x = bx - ax;
	var v1y = by - ay;
	var v2x = px - ax;
	var v2y = py - ay;
	var dot00 = v0x * v0x + v0y * v0y;
	var dot01 = v0x * v1x + v0y * v1y;
	var dot02 = v0x * v2x + v0y * v2y;
	var dot11 = v1x * v1x + v1y * v1y;
	var dot12 = v1x * v2x + v1y * v2y;
	var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
	var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
	if(u >= 0 && v >= 0) {
		return u + v < 1;
	} else {
		return false;
	}
};
justTriangles_PolyK.rayLineIntersection = function(a1,a2,b1,b2,c) {
	var dax = a1.x - a2.x;
	var dbx = b1.x - b2.x;
	var day = a1.y - a2.y;
	var dby = b1.y - b2.y;
	var Den = dax * dby - day * dbx;
	if(Den == 0) {
		return null;
	}
	var A = a1.x * a2.y - a1.y * a2.x;
	var B = b1.x * b2.y - b1.y * b2.x;
	var I = c;
	var iDen = 1 / Den;
	I.x = (A * dbx - dax * B) * iDen;
	I.y = (A * dby - day * B) * iDen;
	var minx = Math.min(b1.x,b2.x);
	var maxx = Math.max(b1.x,b2.x);
	var miny = Math.min(b1.y,b2.y);
	var maxy = Math.max(b1.y,b2.y);
	if(!(minx == maxx ? miny <= I.y && I.y <= maxy : miny == maxy ? minx <= I.x && I.x <= maxx : minx <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx && miny <= I.y + 0.0000000001 && I.y - 0.0000000001 <= maxy)) {
		return null;
	}
	if(day > 0 && I.y > a1.y || day < 0 && I.y < a1.y) {
		return null;
	}
	if(dax > 0 && I.x > a1.x || dax < 0 && I.x < a1.x) {
		return null;
	}
	return I;
};
justTriangles_PolyK.getLineIntersection = function(a1,a2,b1,b2) {
	var dax = a1.x - a2.x;
	var dbx = b1.x - b2.x;
	var day = a1.y - a2.y;
	var dby = b1.y - b2.y;
	var Den = dax * dby - day * dbx;
	if(Den == 0) {
		return null;
	}
	var A = a1.x * a2.y - a1.y * a2.x;
	var B = b1.x * b2.y - b1.y * b2.x;
	var I = { x : (A * dbx - dax * B) / Den, y : (A * dby - day * B) / Den, flag : false};
	var tmp;
	var minx = Math.min(a1.x,a2.x);
	var maxx = Math.max(a1.x,a2.x);
	var miny = Math.min(a1.y,a2.y);
	var maxy = Math.max(a1.y,a2.y);
	if(minx == maxx ? miny <= I.y && I.y <= maxy : miny == maxy ? minx <= I.x && I.x <= maxx : minx <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx && miny <= I.y + 0.0000000001 && I.y - 0.0000000001 <= maxy) {
		var minx1 = Math.min(b1.x,b2.x);
		var maxx1 = Math.max(b1.x,b2.x);
		var miny1 = Math.min(b1.y,b2.y);
		var maxy1 = Math.max(b1.y,b2.y);
		if(minx1 == maxx1) {
			if(miny1 <= I.y) {
				tmp = I.y <= maxy1;
			} else {
				tmp = false;
			}
		} else if(miny1 == maxy1) {
			if(minx1 <= I.x) {
				tmp = I.x <= maxx1;
			} else {
				tmp = false;
			}
		} else if(minx1 <= I.x + 0.0000000001 && I.x - 0.0000000001 <= maxx1 && miny1 <= I.y + 0.0000000001) {
			tmp = I.y - 0.0000000001 <= maxy1;
		} else {
			tmp = false;
		}
	} else {
		tmp = false;
	}
	if(tmp) {
		return I;
	}
	return null;
};
justTriangles_PolyK.inRect = function(a,b,c) {
	var minx = Math.min(b.x,c.x);
	var maxx = Math.max(b.x,c.x);
	var miny = Math.min(b.y,c.y);
	var maxy = Math.max(b.y,c.y);
	if(minx == maxx) {
		if(miny <= a.y) {
			return a.y <= maxy;
		} else {
			return false;
		}
	}
	if(miny == maxy) {
		if(minx <= a.x) {
			return a.x <= maxx;
		} else {
			return false;
		}
	}
	if(minx <= a.x + 0.0000000001 && a.x - 0.0000000001 <= maxx && miny <= a.y + 0.0000000001) {
		return a.y - 0.0000000001 <= maxy;
	} else {
		return false;
	}
};
justTriangles_PolyK.convex = function(ax,ay,bx,by,cx,cy) {
	return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
};
justTriangles_PolyK.dist = function(a,b) {
	var dx = b.x - a.x;
	var dy = b.y - a.y;
	return Math.sqrt(dx * dx + dy * dy);
};
justTriangles_PolyK.prototype = {
	__class__: justTriangles_PolyK
};
var justTriangles_QuickPaths = function() {
};
justTriangles_QuickPaths.__name__ = true;
justTriangles_QuickPaths.speechBubble = function(ctx,sX,sY,offX,offY) {
	var x0 = sX * 75 + offX;
	var y0 = sY * 25 + offY;
	var x1 = sX * 25 + offX;
	var y1 = sY * 25 + offY;
	var x2 = sX * 25 + offX;
	var y2 = sY * 62.5 + offY;
	var x3 = sX * 25 + offX;
	var y3 = sY * 100 + offY;
	var x4 = sX * 50 + offX;
	var y4 = sY * 100 + offY;
	var x5 = sX * 50 + offX;
	var y5 = sY * 120 + offY;
	var x6 = sX * 30 + offX;
	var y6 = sY * 125 + offY;
	var x7 = sX * 60 + offX;
	var y7 = sY * 120 + offY;
	var x8 = sX * 65 + offX;
	var y8 = sY * 100 + offY;
	var x9 = sX * 125 + offX;
	var y9 = sY * 100 + offY;
	var x10 = sX * 125 + offX;
	var y10 = sY * 62.5 + offY;
	var x11 = sX * 125 + offX;
	var y11 = sY * 25 + offY;
	ctx.moveTo(x0,y0);
	ctx.quadTo(x1,y1,x2,y2);
	ctx.quadTo(x3,y3,x4,y4);
	ctx.quadTo(x5,y5,x6,y6);
	ctx.quadTo(x7,y7,x8,y8);
	ctx.quadTo(x9,y9,x10,y10);
	ctx.quadTo(x11,y11,x0,y0);
};
justTriangles_QuickPaths.heart = function(ctx,sX,sY,offX,offY) {
	var x0 = sX * 75 + offX;
	var y0 = sY * 40 + offY;
	var x1 = sX * 75 + offX;
	var y1 = sX * 37 + offY;
	var x2 = sX * 70 + offX;
	var y2 = sY * 25 + offY;
	var x3 = sX * 50 + offX;
	var y3 = sY * 25 + offY;
	var x4 = sX * 20 + offX;
	var y4 = sY * 25 + offY;
	var x5 = sX * 20 + offX;
	var y5 = sY * 62.5 + offY;
	var x6 = sX * 20 + offX;
	var y6 = sY * 62.5 + offY;
	var x7 = sX * 20 + offX;
	var y7 = sY * 80 + offY;
	var x8 = sX * 40 + offX;
	var y8 = sY * 102 + offY;
	var x9 = sX * 75 + offX;
	var y9 = sY * 120 + offY;
	var x10 = sX * 110 + offX;
	var y10 = sY * 102 + offY;
	var x11 = sX * 130 + offX;
	var y11 = sY * 80 + offY;
	var x12 = sX * 130 + offX;
	var y12 = sY * 62.5 + offY;
	var x13 = sX * 130 + offX;
	var y13 = sY * 62.5 + offY;
	var x14 = sX * 130 + offX;
	var y14 = sY * 25 + offY;
	var x15 = sX * 100 + offX;
	var y15 = sY * 25 + offY;
	var x16 = sX * 85 + offX;
	var y16 = sY * 25 + offY;
	var x17 = sX * 75 + offX;
	var y17 = sY * 37 + offY;
	ctx.moveTo(x0,y0);
	ctx.curveTo(x1,y1,x2,y2,x3,y3);
	ctx.curveTo(x4,y4,x5,y5,x6,y6);
	ctx.curveTo(x7,y7,x8,y8,x9,y9);
	ctx.curveTo(x10,y10,x11,y11,x12,y12);
	ctx.curveTo(x13,y13,x14,y14,x15,y15);
	ctx.curveTo(x16,y16,x17,y17,x0,y0);
};
justTriangles_QuickPaths.prototype = {
	__class__: justTriangles_QuickPaths
};
var justTriangles_ShapePoints = function() { };
justTriangles_ShapePoints.__name__ = true;
justTriangles_ShapePoints.boxPoints = function(p,wid,hi) {
	var p1 = [{ x : p.x, y : p.y},{ x : p.x + wid, y : p.y},{ x : p.x + wid, y : p.y + hi},{ x : p.x, y : p.y + hi},{ x : p.x, y : p.y},{ x : p.x + wid, y : p.y},{ x : p.x + wid, y : p.y + hi}];
	return p1;
};
justTriangles_ShapePoints.box = function(x,y,wid,hi) {
	var p = [{ x : x, y : y},{ x : x + wid, y : y},{ x : x + wid, y : y + hi},{ x : x, y : y + hi},{ x : x, y : y},{ x : x + wid, y : y},{ x : x + wid, y : y + hi}];
	p.reverse();
	return p;
};
justTriangles_ShapePoints.equalTri = function(dx,dy,radius,rotation) {
	if(rotation == null) {
		rotation = 0;
	}
	var p = [];
	var angle = 0;
	var offset = -2.5 * Math.PI * 2 / 6 - Math.PI + rotation;
	var _g = 0;
	while(_g < 6) {
		var i = _g++;
		angle = i * (Math.PI * 2) / 3 - offset;
		p.push({ x : dx + radius * Math.cos(angle), y : dy + radius * Math.sin(angle)});
	}
	p.reverse();
	return p;
};
justTriangles_ShapePoints.polyPoints = function(d,radius,sides,rotation) {
	if(rotation == null) {
		rotation = 0;
	}
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var offset = rotation - Math.PI / 2;
	var tot = sides + 3;
	var _g1 = 0;
	var _g = tot;
	while(_g1 < _g) {
		var i = _g1++;
		angle = i * angleInc;
		angle += offset;
		p[tot - i - 1] = { x : d.x + radius * Math.cos(angle), y : d.y + radius * Math.sin(angle)};
	}
	return p;
};
justTriangles_ShapePoints.poly = function(dx,dy,radius,sides) {
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var _g1 = 0;
	var _g = sides + 3;
	while(_g1 < _g) {
		var i = _g1++;
		angle = i * angleInc;
		p.push({ x : dx + radius * Math.cos(angle), y : dy + radius * Math.sin(angle)});
	}
	p.reverse();
	return p;
};
justTriangles_ShapePoints.horizontalWave = function(x_,dx_,y_,amplitude,sides,repeats) {
	var p = [];
	var dx = 0;
	var angleInc = Math.PI * 2 / sides;
	var len = sides * repeats | 0;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		p.push({ x : x_ + (dx += dx_), y : y_ + amplitude * Math.sin(i * angleInc)});
	}
	return p;
};
justTriangles_ShapePoints.verticalWave = function(x_,y_,dy_,amplitude,sides,repeats) {
	var p = [];
	var dy = 0;
	var angleInc = Math.PI * 2 / sides;
	var len = sides * repeats | 0;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		p.push({ y : y_ + (dy += dy_), x : x_ + amplitude * Math.sin(i * angleInc)});
	}
	return p;
};
justTriangles_ShapePoints.arcPoints = function(d,radius,start,dA,sides) {
	var p = [];
	var dx = d.x;
	var dy = d.y;
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var sides1 = Math.round(sides);
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			nextAngle = angle + start;
			--i;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	return p;
};
justTriangles_ShapePoints.arc_internal = function(dx,dy,radius,start,dA,sides) {
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var sides1 = Math.round(sides);
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
		p.reverse();
	}
	return p;
};
justTriangles_ShapePoints.arc = function(dx,dy,radius,start,dA,sides) {
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var sides1 = Math.round(sides);
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	return p;
};
justTriangles_ShapePoints.quadCurve = function(p0,p1,p2) {
	var p = [];
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	var x1 = p1.x - p2.x;
	var y1 = p1.y - p2.y;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	var v;
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.quadStep);
	var arr_0 = p0;
	var arr_1 = p1;
	var arr_2 = p2;
	var t = 0.0;
	p.push(p0);
	t += step;
	while(t < 1) {
		var u = 1 - t;
		var u1 = 1 - t;
		v = { x : Math.pow(u,2) * arr_0.x + 2 * u * t * arr_1.x + Math.pow(t,2) * arr_2.x, y : Math.pow(u1,2) * arr_0.y + 2 * u1 * t * arr_1.y + Math.pow(t,2) * arr_2.y};
		p.push({ x : v.x, y : v.y});
		t += step;
	}
	p.push(p2);
	return p;
};
justTriangles_ShapePoints.cubicCurve = function(p0,p1,p2,p3) {
	var p = [];
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	var x1 = p1.x - p2.x;
	var y1 = p1.y - p2.y;
	var x2 = p2.x - p3.x;
	var y2 = p2.y - p3.y;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	var v;
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.cubicStep);
	var arr_0 = p0;
	var arr_1 = p1;
	var arr_2 = p2;
	var arr_3 = p3;
	var t = 0.0;
	var u = 1.;
	var u1 = 1.;
	v = { x : Math.pow(u,3) * arr_0.x + 3 * Math.pow(u,2) * 0.0 * arr_1.x + 3 * u * Math.pow(0.0,2) * arr_2.x + Math.pow(0.0,3) * arr_3.x, y : Math.pow(u1,3) * arr_0.y + 3 * Math.pow(u1,2) * 0.0 * arr_1.y + 3 * u1 * Math.pow(0.0,2) * arr_2.y + Math.pow(0.0,3) * arr_3.y};
	p.push({ x : v.x, y : v.y});
	t += step;
	while(t < 1) {
		var u2 = 1 - t;
		var u3 = 1 - t;
		v = { x : Math.pow(u2,3) * arr_0.x + 3 * Math.pow(u2,2) * t * arr_1.x + 3 * u2 * Math.pow(t,2) * arr_2.x + Math.pow(t,3) * arr_3.x, y : Math.pow(u3,3) * arr_0.y + 3 * Math.pow(u3,2) * t * arr_1.y + 3 * u3 * Math.pow(t,2) * arr_2.y + Math.pow(t,3) * arr_3.y};
		p.push({ x : v.x, y : v.y});
		t += step;
	}
	var u4 = 0.;
	var u5 = 0.;
	v = { x : Math.pow(u4,3) * arr_0.x + 3 * Math.pow(u4,2) * arr_1.x + 3 * u4 * Math.pow(1.0,2) * arr_2.x + Math.pow(1.0,3) * arr_3.x, y : Math.pow(u5,3) * arr_0.y + 3 * Math.pow(u5,2) * arr_1.y + 3 * u5 * Math.pow(1.0,2) * arr_2.y + Math.pow(1.0,3) * arr_3.y};
	p.push({ x : v.x, y : v.y});
	return p;
};
justTriangles_ShapePoints.distance = function(p0,p1) {
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	return Math.sqrt(x * x + y * y);
};
justTriangles_ShapePoints.quadraticBezier = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,2) * arr[0].x + 2 * u * t * arr[1].x + Math.pow(t,2) * arr[2].x, y : Math.pow(u1,2) * arr[0].y + 2 * u1 * t * arr[1].y + Math.pow(t,2) * arr[2].y};
};
justTriangles_ShapePoints._quadraticBezier = function(t,startPoint,controlPoint,endPoint) {
	var u = 1 - t;
	return Math.pow(u,2) * startPoint + 2 * u * t * controlPoint + Math.pow(t,2) * endPoint;
};
var justTriangles_StoreF6 = function() {
	this.count = 0;
	this.l = 0;
};
justTriangles_StoreF6.__name__ = true;
justTriangles_StoreF6.prototype = {
	clear: function() {
		this.l = 0;
		this.s0 = null;
		this.s1 = null;
		this.s2 = null;
		this.s3 = null;
		this.s4 = null;
		this.s5 = null;
	}
	,length: function() {
		return this.l;
	}
	,push: function(v) {
		var _g = this.l;
		switch(_g) {
		case 0:
			this.s0 = v;
			break;
		case 1:
			this.s1 = v;
			break;
		case 2:
			this.s2 = v;
			break;
		case 3:
			this.s3 = v;
			break;
		case 4:
			this.s4 = v;
			break;
		case 5:
			this.s5 = v;
			break;
		default:
		}
		this.l++;
	}
	,pop: function() {
		var out = null;
		var _g = this.l;
		switch(_g) {
		case 0:
			out = this.s0;
			this.s0 = null;
			break;
		case 1:
			out = this.s1;
			this.s1 = null;
			break;
		case 2:
			out = this.s2;
			this.s2 = null;
			break;
		case 3:
			out = this.s3;
			this.s3 = null;
			break;
		case 4:
			out = this.s4;
			this.s4 = null;
			break;
		case 5:
			out = this.s5;
			this.s5 = null;
			break;
		default:
		}
		this.l--;
		return out;
	}
	,unshift: function(v) {
		this.s5 = this.s4;
		this.s4 = this.s3;
		this.s3 = this.s2;
		this.s2 = this.s1;
		this.s0 = v;
		this.l++;
	}
	,shift: function() {
		var out = this.s0;
		if(this.l != 0) {
			this.s0 = this.s1;
			this.s1 = this.s2;
			this.s2 = this.s3;
			this.s3 = this.s4;
			this.s4 = this.s5;
			this.s5 = null;
			this.l--;
		}
		return out;
	}
	,toString: function() {
		return "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4 + ", " + this.s5;
	}
	,populatedToString: function() {
		var out = "";
		var _g = this.l - 1;
		switch(_g) {
		case 0:
			out = "" + this.s0;
			break;
		case 1:
			out = "" + this.s0 + ", " + this.s1;
			break;
		case 2:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2;
			break;
		case 3:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3;
			break;
		case 4:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4;
			break;
		case 5:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4 + ", " + this.s5;
			break;
		default:
		}
		return out;
	}
	,hasNext: function() {
		return this.count < this.l + 1;
	}
	,resetIterator: function() {
		this.count = 0;
	}
	,next: function() {
		var out = null;
		var _g = this.count;
		switch(_g) {
		case 0:
			out = this.s0;
			break;
		case 1:
			out = this.s1;
			break;
		case 2:
			out = this.s2;
			break;
		case 3:
			out = this.s3;
			break;
		case 4:
			out = this.s4;
			break;
		case 5:
			out = this.s5;
			break;
		default:
		}
		this.count++;
		return out;
	}
	,first: function() {
		return this.s0;
	}
	,last: function() {
		var out = null;
		var _g = this.l;
		switch(_g) {
		case 0:
			out = this.s0;
			break;
		case 1:
			out = this.s1;
			break;
		case 2:
			out = this.s2;
			break;
		case 3:
			out = this.s3;
			break;
		case 4:
			out = this.s4;
			break;
		case 5:
			out = this.s5;
			break;
		default:
		}
		return out;
	}
	,penultimate: function() {
		var out = null;
		var _g = this.l - 1;
		switch(_g) {
		case 0:
			out = this.s0;
			break;
		case 1:
			out = this.s1;
			break;
		case 2:
			out = this.s2;
			break;
		case 3:
			out = this.s3;
			break;
		case 4:
			out = this.s4;
			break;
		case 5:
			out = this.s5;
			break;
		default:
		}
		return out;
	}
	,toArray: function() {
		var arr = [];
		this.count = 0;
		var _g = this;
		while(_g.count < _g.l + 1) {
			var out = null;
			var _g1 = _g.count;
			switch(_g1) {
			case 0:
				out = _g.s0;
				break;
			case 1:
				out = _g.s1;
				break;
			case 2:
				out = _g.s2;
				break;
			case 3:
				out = _g.s3;
				break;
			case 4:
				out = _g.s4;
				break;
			case 5:
				out = _g.s5;
				break;
			default:
			}
			_g.count++;
			var i = out;
			arr.push(i);
		}
	}
	,__class__: justTriangles_StoreF6
};
var justTriangles_StoreF8 = function() {
	this.count = 0;
	this.l = 0;
};
justTriangles_StoreF8.__name__ = true;
justTriangles_StoreF8.prototype = {
	clear: function() {
		this.l = 0;
		this.s0 = null;
		this.s1 = null;
		this.s2 = null;
		this.s3 = null;
		this.s4 = null;
		this.s5 = null;
		this.s6 = null;
		this.s7 = null;
	}
	,length: function() {
		return this.l;
	}
	,push: function(v) {
		var _g = this.l;
		switch(_g) {
		case 0:
			this.s0 = v;
			break;
		case 1:
			this.s1 = v;
			break;
		case 2:
			this.s2 = v;
			break;
		case 3:
			this.s3 = v;
			break;
		case 4:
			this.s4 = v;
			break;
		case 5:
			this.s5 = v;
			break;
		case 6:
			this.s6 = v;
			break;
		case 7:
			this.s7 = v;
			break;
		default:
		}
		this.l++;
	}
	,pop: function() {
		var out = null;
		var _g = this.l;
		switch(_g) {
		case 0:
			out = this.s0;
			this.s0 = null;
			break;
		case 1:
			out = this.s1;
			this.s1 = null;
			break;
		case 2:
			out = this.s2;
			this.s2 = null;
			break;
		case 3:
			out = this.s3;
			this.s3 = null;
			break;
		case 4:
			out = this.s4;
			this.s4 = null;
			break;
		case 5:
			out = this.s5;
			this.s5 = null;
			break;
		case 6:
			out = this.s6;
			this.s6 = null;
			break;
		case 7:
			out = this.s7;
			this.s6 = null;
			break;
		default:
		}
		this.l--;
		return out;
	}
	,unshift: function(v) {
		this.s7 = this.s6;
		this.s6 = this.s5;
		this.s5 = this.s4;
		this.s4 = this.s3;
		this.s3 = this.s2;
		this.s2 = this.s1;
		this.s0 = v;
		this.l++;
	}
	,shift: function() {
		var out = this.s0;
		if(this.l != 0) {
			this.s0 = this.s1;
			this.s1 = this.s2;
			this.s2 = this.s3;
			this.s3 = this.s4;
			this.s4 = this.s5;
			this.s5 = this.s6;
			this.s6 = this.s7;
			this.s7 = null;
			this.l--;
		}
		return out;
	}
	,toString: function() {
		return "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4 + ", " + this.s5 + ", " + this.s6 + ", " + this.s7;
	}
	,populatedToString: function() {
		var out = "";
		var _g = this.l - 1;
		switch(_g) {
		case 0:
			out = "" + this.s0;
			break;
		case 1:
			out = "" + this.s0 + ", " + this.s1;
			break;
		case 2:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2;
			break;
		case 3:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3;
			break;
		case 4:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4;
			break;
		case 5:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4 + ", " + this.s5;
			break;
		case 6:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4 + ", " + this.s5 + ", " + this.s6;
			break;
		case 7:
			out = "" + this.s0 + ", " + this.s1 + ", " + this.s2 + ", " + this.s3 + ", " + this.s4 + ", " + this.s5 + ", " + this.s6 + ", " + this.s7;
			break;
		default:
		}
		return out;
	}
	,hasNext: function() {
		return this.count < this.l + 1;
	}
	,resetIterator: function() {
		this.count = 0;
	}
	,next: function() {
		var out = null;
		var _g = this.count;
		switch(_g) {
		case 0:
			out = this.s0;
			break;
		case 1:
			out = this.s1;
			break;
		case 2:
			out = this.s2;
			break;
		case 3:
			out = this.s3;
			break;
		case 4:
			out = this.s4;
			break;
		case 5:
			out = this.s5;
			break;
		case 6:
			out = this.s6;
			break;
		case 7:
			out = this.s7;
			break;
		default:
		}
		this.count++;
		return out;
	}
	,first: function() {
		return this.s0;
	}
	,last: function() {
		var out = null;
		var _g = this.l;
		switch(_g) {
		case 0:
			out = this.s0;
			break;
		case 1:
			out = this.s1;
			break;
		case 2:
			out = this.s2;
			break;
		case 3:
			out = this.s3;
			break;
		case 4:
			out = this.s4;
			break;
		case 5:
			out = this.s5;
			break;
		case 6:
			out = this.s6;
			break;
		case 7:
			out = this.s7;
			break;
		default:
		}
		return out;
	}
	,penultimate: function() {
		var out = null;
		var _g = this.l - 1;
		switch(_g) {
		case 0:
			out = this.s0;
			break;
		case 1:
			out = this.s1;
			break;
		case 2:
			out = this.s2;
			break;
		case 3:
			out = this.s3;
			break;
		case 4:
			out = this.s4;
			break;
		case 5:
			out = this.s5;
			break;
		case 6:
			out = this.s6;
			break;
		case 7:
			out = this.s7;
			break;
		default:
		}
		return out;
	}
	,toArray: function() {
		var arr = [];
		this.count = 0;
		var _g = this;
		while(_g.count < _g.l + 1) {
			var out = null;
			var _g1 = _g.count;
			switch(_g1) {
			case 0:
				out = _g.s0;
				break;
			case 1:
				out = _g.s1;
				break;
			case 2:
				out = _g.s2;
				break;
			case 3:
				out = _g.s3;
				break;
			case 4:
				out = _g.s4;
				break;
			case 5:
				out = _g.s5;
				break;
			case 6:
				out = _g.s6;
				break;
			case 7:
				out = _g.s7;
				break;
			default:
			}
			_g.count++;
			var i = out;
			arr.push(i);
		}
	}
	,__class__: justTriangles_StoreF8
};
var justTriangles_SvgPath = function(pathContext_) {
	this.sy = 1;
	this.sx = 1;
	this.dy = 0;
	this.dx = 0;
	this.lastY = 0;
	this.lastX = 0;
	this.pathContext = pathContext_;
};
justTriangles_SvgPath.__name__ = true;
justTriangles_SvgPath.prototype = {
	parse: function(str_,dx_,dy_,sx_,sy_) {
		if(sy_ == null) {
			sy_ = 1;
		}
		if(sx_ == null) {
			sx_ = 1;
		}
		if(dy_ == null) {
			dy_ = 0;
		}
		if(dx_ == null) {
			dx_ = 0;
		}
		this.str = str_;
		this.dx = dx_;
		this.dy = dy_;
		this.sx = sx_;
		this.sy = sy_;
		this.pos = 0;
		this.l = this.str.length;
		this.c = this.str.charCodeAt(this.pos++);
		var count = 0;
		this.store = new justTriangles_StoreF6();
		while(this.pos < this.l) {
			var _g = this.c;
			switch(_g) {
			case 65:
				console.log("elliptical_Arc - not implemented");
				this.extractArgs();
				break;
			case 66:
				console.log("bearing - not implemented");
				throw new js__$Boot_HaxeError("bearing not supported please remove");
				break;
			case 67:
				this.extractArgs();
				this.controlX = this.store.s2;
				this.controlY = this.store.s3;
				this.lastX = this.store.s4;
				this.lastY = this.store.s5;
				this.pathContext.curveTo(this.store.s0,this.store.s1,this.controlX,this.controlY,this.lastX,this.lastY);
				break;
			case 72:
				this.extractArgs(false);
				this.lastX = this.store.s0 * this.sx + this.dx;
				this.pathContext.lineTo(this.lastX,this.lastY);
				break;
			case 76:
				this.extractArgs();
				this.lastX = this.store.s0;
				this.lastY = this.store.s1;
				this.pathContext.lineTo(this.lastX,this.lastY);
				break;
			case 77:
				this.extractArgs();
				this.lastX = this.store.s0;
				this.lastY = this.store.s1;
				this.pathContext.moveTo(this.lastX,this.lastY);
				break;
			case 81:
				this.extractArgs();
				this.controlX = this.store.s0;
				this.controlY = this.store.s1;
				this.lastX = this.store.s2;
				this.lastY = this.store.s3;
				this.pathContext.quadTo(this.controlX,this.controlY,this.lastX,this.lastY);
				break;
			case 83:
				this.extractArgs();
				this.controlX = 2 * this.lastX - this.controlX;
				this.controlY = 2 * this.lastY - this.controlY;
				var endX = this.store.s2;
				var endY = this.store.s3;
				this.pathContext.curveTo(this.controlX,this.controlY,this.store.s0,this.store.s1,endX,endY);
				this.controlX = this.store.s0;
				this.controlY = this.store.s1;
				break;
			case 84:
				this.extractArgs();
				this.controlX = 2 * this.lastX - this.controlX;
				this.controlY = 2 * this.lastY - this.controlY;
				this.lastX = this.store.s0;
				this.lastY = this.store.s1;
				this.pathContext.quadTo(this.controlX,this.controlY,this.lastX,this.lastY);
				break;
			case 86:
				this.extractArgs(false);
				this.lastY = this.store.s0 * this.sy + this.dy;
				this.pathContext.lineTo(this.lastX,this.lastY);
				break;
			case 90:case 122:
				this.lastX = 0;
				this.lastY = 0;
				break;
			case 97:
				console.log("relative elliptical_Arc - not implemented");
				this.extractArgs();
				break;
			case 99:
				this.extractArgs();
				this.controlX = this.store.s2 + this.lastX;
				this.controlY = this.store.s3 + this.lastY;
				var endX1 = this.store.s4 + this.lastX;
				var endY1 = this.store.s5 + this.lastY;
				this.pathContext.curveTo(this.store.s0 + this.lastX,this.store.s1 + this.lastY,this.controlX,this.controlY,endX1,endY1);
				this.lastX = endX1;
				this.lastY = endY1;
				break;
			case 104:
				this.extractArgs(false);
				this.lastX = this.lastX + this.store.s0 * this.sx + this.dx;
				this.pathContext.lineTo(this.lastX,this.lastY);
				break;
			case 108:
				this.extractArgs();
				this.lastX = this.store.s0 + this.lastX;
				this.lastY = this.store.s1 + this.lastY;
				this.pathContext.lineTo(this.lastX,this.lastY);
				break;
			case 109:
				this.extractArgs();
				this.lastX = this.store.s0 + this.lastX;
				this.lastY = this.store.s1 + this.lastY;
				this.pathContext.moveTo(this.lastX,this.lastY);
				break;
			case 113:
				this.extractArgs();
				this.controlX = this.lastX + this.store.s0;
				this.controlY = this.lastY + this.store.s1;
				this.lastX = this.store.s0 + this.lastX;
				this.lastY = this.store.s1 + this.lastY;
				this.pathContext.quadTo(this.controlX,this.controlY,this.lastX,this.lastY);
				break;
			case 115:
				this.extractArgs();
				this.controlX = 2 * this.lastX - this.controlX;
				this.controlY = 2 * this.lastY - this.controlY;
				var endX2 = this.store.s2 + this.lastX;
				var endY2 = this.store.s3 + this.lastY;
				this.pathContext.curveTo(this.controlX,this.controlY,this.store.s0 + this.lastX,this.store.s1 + this.lastY,endX2,endY2);
				this.controlX = this.store.s0 + this.lastX;
				this.controlY = this.store.s1 + this.lastY;
				this.lastX = endX2;
				this.lastY = endY2;
				break;
			case 116:
				this.extractArgs();
				this.controlX = 2 * this.lastX - this.controlX;
				this.controlY = 2 * this.lastY - this.controlY;
				this.lastX = this.store.s0 + this.lastY;
				this.lastY = this.store.s1 + this.lastX;
				this.pathContext.quadTo(this.controlX,this.controlY,this.lastX,this.lastY);
				break;
			case 118:
				this.extractArgs(false);
				this.lastY = this.lastY + this.store.s0 * this.sy + this.dy;
				this.pathContext.lineTo(this.lastX,this.lastY);
				break;
			default:
				++count;
			}
			this.c = this.str.charCodeAt(this.pos++);
		}
		return str_;
	}
	,extractArgs: function(process) {
		if(process == null) {
			process = true;
		}
		var _this = this.store;
		_this.l = 0;
		_this.s0 = null;
		_this.s1 = null;
		_this.s2 = null;
		_this.s3 = null;
		_this.s4 = null;
		_this.s5 = null;
		this.c = this.str.charCodeAt(this.pos++);
		var count = 0;
		var temp = "";
		try {
			while(true) {
				var _g = this.c;
				switch(_g) {
				case 32:case 44:
					if(temp != "") {
						if(temp == "0") {
							temp = "0.1";
						}
						if(process) {
							if((this.store.l & 1) == 0) {
								var _this1 = this.store;
								var v = parseFloat(temp) * this.sx + this.dx;
								var _g1 = _this1.l;
								switch(_g1) {
								case 0:
									_this1.s0 = v;
									break;
								case 1:
									_this1.s1 = v;
									break;
								case 2:
									_this1.s2 = v;
									break;
								case 3:
									_this1.s3 = v;
									break;
								case 4:
									_this1.s4 = v;
									break;
								case 5:
									_this1.s5 = v;
									break;
								default:
								}
								_this1.l++;
							} else {
								var _this2 = this.store;
								var v1 = parseFloat(temp) * this.sy + this.dy;
								var _g2 = _this2.l;
								switch(_g2) {
								case 0:
									_this2.s0 = v1;
									break;
								case 1:
									_this2.s1 = v1;
									break;
								case 2:
									_this2.s2 = v1;
									break;
								case 3:
									_this2.s3 = v1;
									break;
								case 4:
									_this2.s4 = v1;
									break;
								case 5:
									_this2.s5 = v1;
									break;
								default:
								}
								_this2.l++;
							}
						} else {
							var _this3 = this.store;
							var v2 = parseFloat(temp);
							var _g3 = _this3.l;
							switch(_g3) {
							case 0:
								_this3.s0 = v2;
								break;
							case 1:
								_this3.s1 = v2;
								break;
							case 2:
								_this3.s2 = v2;
								break;
							case 3:
								_this3.s3 = v2;
								break;
							case 4:
								_this3.s4 = v2;
								break;
							case 5:
								_this3.s5 = v2;
								break;
							default:
							}
							_this3.l++;
						}
						temp = "";
					}
					break;
				case 45:
					if(temp != "") {
						if(temp == "0") {
							temp = "0.1";
						}
						if(process) {
							if((this.store.l & 1) == 0) {
								var _this4 = this.store;
								var v3 = parseFloat(temp) * this.sx + this.dx;
								var _g4 = _this4.l;
								switch(_g4) {
								case 0:
									_this4.s0 = v3;
									break;
								case 1:
									_this4.s1 = v3;
									break;
								case 2:
									_this4.s2 = v3;
									break;
								case 3:
									_this4.s3 = v3;
									break;
								case 4:
									_this4.s4 = v3;
									break;
								case 5:
									_this4.s5 = v3;
									break;
								default:
								}
								_this4.l++;
							} else {
								var _this5 = this.store;
								var v4 = parseFloat(temp) * this.sy + this.dy;
								var _g5 = _this5.l;
								switch(_g5) {
								case 0:
									_this5.s0 = v4;
									break;
								case 1:
									_this5.s1 = v4;
									break;
								case 2:
									_this5.s2 = v4;
									break;
								case 3:
									_this5.s3 = v4;
									break;
								case 4:
									_this5.s4 = v4;
									break;
								case 5:
									_this5.s5 = v4;
									break;
								default:
								}
								_this5.l++;
							}
						} else {
							var _this6 = this.store;
							var v5 = parseFloat(temp);
							var _g6 = _this6.l;
							switch(_g6) {
							case 0:
								_this6.s0 = v5;
								break;
							case 1:
								_this6.s1 = v5;
								break;
							case 2:
								_this6.s2 = v5;
								break;
							case 3:
								_this6.s3 = v5;
								break;
							case 4:
								_this6.s4 = v5;
								break;
							case 5:
								_this6.s5 = v5;
								break;
							default:
							}
							_this6.l++;
						}
					}
					temp = "-";
					break;
				case 46:
					temp += ".";
					break;
				case 48:
					temp += "0";
					break;
				case 49:
					temp += "1";
					break;
				case 50:
					temp += "2";
					break;
				case 51:
					temp += "3";
					break;
				case 52:
					temp += "4";
					break;
				case 53:
					temp += "5";
					break;
				case 54:
					temp += "6";
					break;
				case 55:
					temp += "7";
					break;
				case 56:
					temp += "8";
					break;
				case 57:
					temp += "9";
					break;
				default:
					if(temp != "") {
						if(temp == "0") {
							temp = "0.1";
						}
						if(process) {
							if((this.store.l & 1) == 0) {
								var _this7 = this.store;
								var v6 = parseFloat(temp) * this.sx + this.dx;
								var _g7 = _this7.l;
								switch(_g7) {
								case 0:
									_this7.s0 = v6;
									break;
								case 1:
									_this7.s1 = v6;
									break;
								case 2:
									_this7.s2 = v6;
									break;
								case 3:
									_this7.s3 = v6;
									break;
								case 4:
									_this7.s4 = v6;
									break;
								case 5:
									_this7.s5 = v6;
									break;
								default:
								}
								_this7.l++;
							} else {
								var _this8 = this.store;
								var v7 = parseFloat(temp) * this.sy + this.dy;
								var _g8 = _this8.l;
								switch(_g8) {
								case 0:
									_this8.s0 = v7;
									break;
								case 1:
									_this8.s1 = v7;
									break;
								case 2:
									_this8.s2 = v7;
									break;
								case 3:
									_this8.s3 = v7;
									break;
								case 4:
									_this8.s4 = v7;
									break;
								case 5:
									_this8.s5 = v7;
									break;
								default:
								}
								_this8.l++;
							}
						} else {
							var _this9 = this.store;
							var v8 = parseFloat(temp);
							var _g9 = _this9.l;
							switch(_g9) {
							case 0:
								_this9.s0 = v8;
								break;
							case 1:
								_this9.s1 = v8;
								break;
							case 2:
								_this9.s2 = v8;
								break;
							case 3:
								_this9.s3 = v8;
								break;
							case 4:
								_this9.s4 = v8;
								break;
							case 5:
								_this9.s5 = v8;
								break;
							default:
							}
							_this9.l++;
						}
						temp = "";
					}
					this.pos--;
					throw "__break__";
				}
				this.c = this.str.charCodeAt(this.pos++);
			}
		} catch( e ) { if( e != "__break__" ) throw e; }
	}
	,nextChar: function() {
		return this.str.charCodeAt(this.pos++);
	}
	,__class__: justTriangles_SvgPath
};
var justTriangles_Triangle = function(id_,outline_,A_,B_,C_,depth_,colorID_) {
	this.id = id_;
	this.outline = outline_;
	var p0_y;
	var p0_x = B_.x - A_.x;
	p0_y = B_.y - A_.y;
	var p1_y;
	var p1_x = C_.x - A_.x;
	p1_y = C_.y - A_.y;
	var val = !(p0_x * p1_y - p0_y * p1_x < 0);
	if(val) {
		this.ax = A_.x;
		this.ay = A_.y;
		this.bx = C_.x;
		this.by = C_.y;
		this.cx = B_.x;
		this.cy = B_.y;
	} else {
		this.ax = A_.x;
		this.ay = A_.y;
		this.bx = B_.x;
		this.by = B_.y;
		this.cx = C_.x;
		this.cy = C_.y;
	}
	this.depth = depth_;
	this.colorID = colorID_;
};
justTriangles_Triangle.__name__ = true;
justTriangles_Triangle.drawTri = function(id,outline,p0,p1,p2,colorID) {
	justTriangles_Triangle.triangles.push(new justTriangles_Triangle(id,outline,p0,p1,p2,0,colorID));
};
justTriangles_Triangle.adjustWinding = function(A_,B_,C_) {
	var p0_y;
	var p0_x = B_.x - A_.x;
	p0_y = B_.y - A_.y;
	var p1_y;
	var p1_x = C_.x - A_.x;
	p1_y = C_.y - A_.y;
	var val = !(p0_x * p1_y - p0_y * p1_x < 0);
	return val;
};
justTriangles_Triangle.subtract = function(p0,p1) {
	return { x : p0.x - p1.x, y : p0.y - p1.y};
};
justTriangles_Triangle.cross = function(p0,p1) {
	return p0.x * p1.y - p0.y * p1.x;
};
justTriangles_Triangle.prototype = {
	get_x: function() {
		return Math.min(Math.min(this.ax,this.bx),this.cx);
	}
	,set_x: function(x) {
		var dx = x - this.get_x();
		this.ax += dx;
		this.bx += dx;
		this.cx += dx;
		return x;
	}
	,get_y: function() {
		return Math.min(Math.min(this.ay,this.by),this.cy);
	}
	,set_y: function(y) {
		var dy = y - this.get_y();
		this.ay += dy;
		this.by += dy;
		this.cy += dy;
		return y;
	}
	,get_right: function() {
		return Math.max(Math.max(this.ax,this.bx),this.cx);
	}
	,get_bottom: function() {
		return Math.max(Math.max(this.ay,this.by),this.cy);
	}
	,moveDelta: function(dx,dy) {
		this.ax += dx;
		this.ay += dy;
		this.bx += dx;
		this.by += dy;
		this.cx += dx;
		this.cy += dy;
	}
	,hitTest: function(P) {
		var px = P.x;
		var py = P.y;
		if(px > this.get_x() && px < this.get_right() && py > this.get_y() && py < this.get_bottom()) {
			return true;
		}
		var planeAB = (this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py);
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		var planeCA = (this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py);
		if(this.sign(planeAB) == this.sign(planeBC)) {
			return this.sign(planeBC) == this.sign(planeCA);
		} else {
			return false;
		}
	}
	,sign: function(n) {
		return Math.abs(n) / n | 0;
	}
	,__class__: justTriangles_Triangle
};
var justTrianglesWebGL_Drawing = function(width_,height_,autoChild) {
	htmlHelper_webgl_WebGLSetup.call(this,width_,height_,autoChild);
};
justTrianglesWebGL_Drawing.__name__ = true;
justTrianglesWebGL_Drawing.create = function(dim_) {
	justTriangles_Draw.drawTri = justTriangles_Triangle.drawTri;
	var webgl = new justTrianglesWebGL_Drawing(dim_,dim_);
	webgl.setupProgram("attribute vec3 pos;" + "attribute vec4 color;" + "varying vec4 vcol;" + "uniform mat4 modelViewProjection;" + "void main(void) {" + " gl_Position = modelViewProjection * vec4(pos, 1.0);" + " vcol = color;" + "}","precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}");
	new htmlHelper_tools_CSSEnterFrame().onFrame = $bind(webgl,webgl.render);
	return webgl;
};
justTrianglesWebGL_Drawing.__super__ = htmlHelper_webgl_WebGLSetup;
justTrianglesWebGL_Drawing.prototype = $extend(htmlHelper_webgl_WebGLSetup.prototype,{
	render: function() {
		if(this.transformationFunc != null) {
			this.modelViewProjection = this.transformationFunc();
		}
		htmlHelper_webgl_WebGLSetup.prototype.render.call(this);
	}
	,setTriangles: function(triangles,triangleColors) {
		var rgb;
		var colorAlpha = 1.0;
		var tri;
		var count = 0;
		var _g1 = 0;
		var _g = triangles.length;
		while(_g1 < _g) {
			var i = _g1++;
			tri = triangles[i];
			this.vertices.push(tri.ax - 0.5);
			this.vertices.push(-tri.ay + 0.5);
			this.vertices.push(tri.depth);
			this.vertices.push(tri.bx - 0.5);
			this.vertices.push(-tri.by + 0.5);
			this.vertices.push(tri.depth);
			this.vertices.push(tri.cx - 0.5);
			this.vertices.push(-tri.cy + 0.5);
			this.vertices.push(tri.depth);
			var $int = triangleColors[tri.colorID];
			rgb = { r : ($int >> 16 & 255) / 255, g : ($int >> 8 & 255) / 255, b : ($int & 255) / 255};
			var _g2 = 0;
			while(_g2 < 3) {
				var k = _g2++;
				this.colors.push(rgb.r);
				this.colors.push(rgb.g);
				this.colors.push(rgb.b);
				this.colors.push(colorAlpha);
				this.indices.push(count++);
			}
		}
		var gl = this.gl;
		var program = this.program;
		var vertices = this.vertices;
		var colors = this.colors;
		var indices = this.indices;
		var vertexBuffer = gl.createBuffer();
		gl.bindBuffer(34962,vertexBuffer);
		gl.bufferData(34962,new Float32Array(vertices),35044);
		var position = gl.getAttribLocation(program,"pos");
		gl.vertexAttribPointer(position,3,5126,false,0,0);
		gl.enableVertexAttribArray(position);
		gl.bindBuffer(34962,null);
		var colorBuffer = gl.createBuffer();
		gl.bindBuffer(34962,colorBuffer);
		gl.bufferData(34962,new Float32Array(colors),35044);
		var col = gl.getAttribLocation(program,"color");
		gl.vertexAttribPointer(col,4,5126,false,0,0);
		gl.enableVertexAttribArray(col);
		gl.bindBuffer(34962,null);
	}
	,__class__: justTrianglesWebGL_Drawing
});
var justTrianglesWebGL_InteractionSurface = function(width_,height_,color_) {
	this.radius = 15;
	this.width = width_;
	this.height = height_;
	this.color = color_;
	this.doc = window.document;
	this.bg = this.doc.createElement("div");
	this.bg.style.backgroundColor = this.color;
	this.bg.style.width = Std.string(this.width) + "px";
	this.bg.style.height = Std.string(this.height) + "px";
	this.bg.style.position = "absolute";
	this.bg.style.left = "0px";
	this.bg.style.top = "0px";
	this.bg.style.zIndex = "-100";
	this.bg.style.cursor = "default";
	this.doc.body.appendChild(this.bg);
	this.bg.addEventListener("mousedown",$bind(this,this.makePointsDragable));
};
justTrianglesWebGL_InteractionSurface.__name__ = true;
justTrianglesWebGL_InteractionSurface.prototype = {
	setup: function(vertices_,transform_,draw_) {
		this.vertices = vertices_;
		this.transform = transform_;
		this.draw = draw_;
		this.limits = [];
		var l = this.vertices.length;
		var v;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			v = this.vertices[i];
			var x = v.x;
			var y = v.y;
			var p0 = this.transform(x - this.radius,y - this.radius);
			var p1 = this.transform(x + this.radius,y + this.radius);
			this.limits[i] = { left : p0.x, top : p0.y, right : p1.x, bottom : p1.y};
		}
	}
	,initVerticesHits: function() {
		this.limits = [];
		var l = this.vertices.length;
		var v;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			v = this.vertices[i];
			var x = v.x;
			var y = v.y;
			var p0 = this.transform(x - this.radius,y - this.radius);
			var p1 = this.transform(x + this.radius,y + this.radius);
			this.limits[i] = { left : p0.x, top : p0.y, right : p1.x, bottom : p1.y};
		}
	}
	,createBackground: function() {
		this.doc = window.document;
		this.bg = this.doc.createElement("div");
		this.bg.style.backgroundColor = this.color;
		this.bg.style.width = Std.string(this.width) + "px";
		this.bg.style.height = Std.string(this.height) + "px";
		this.bg.style.position = "absolute";
		this.bg.style.left = "0px";
		this.bg.style.top = "0px";
		this.bg.style.zIndex = "-100";
		this.bg.style.cursor = "default";
		this.doc.body.appendChild(this.bg);
		this.bg.addEventListener("mousedown",$bind(this,this.makePointsDragable));
	}
	,makePointsDragable: function(e) {
		var i = this.hitVertex(e.clientX * 2,e.clientY * 2);
		if(i != null) {
			this.currVertex = i;
			this.bg.style.cursor = "move";
			this.bg.addEventListener("mousemove",$bind(this,this.repositionVertex));
			this.bg.addEventListener("mouseup",$bind(this,this.killMouseMove));
		}
	}
	,hitVertex: function(x,y) {
		var aLimit;
		var p = this.transform(x,y);
		var _g1 = 0;
		var _g = this.limits.length;
		while(_g1 < _g) {
			var i = _g1++;
			aLimit = this.limits[i];
			if(p.x > aLimit.left && p.x < aLimit.right) {
				if(p.y > aLimit.top && p.y < aLimit.bottom) {
					return i;
				}
			}
		}
		return null;
	}
	,killMouseMove: function(e) {
		this.bg.style.cursor = "default";
		this.bg.removeEventListener("mousemove",$bind(this,this.repositionVertex));
		this.bg.removeEventListener("mouseup",$bind(this,this.killMouseMove));
	}
	,repositionVertex: function(e) {
		var x = e.clientX;
		var y = e.clientY;
		var i = this.currVertex;
		var p0 = this.transform(x - this.radius,y - this.radius);
		var p1 = this.transform(x + this.radius,y + this.radius);
		this.limits[i] = { left : p0.x, top : p0.y, right : p1.x, bottom : p1.y};
		var v = this.vertices[i];
		v.x = x * 2;
		v.y = y * 2;
		this.draw();
	}
	,moveVertex: function(i,x,y) {
		var p0 = this.transform(x - this.radius,y - this.radius);
		var p1 = this.transform(x + this.radius,y + this.radius);
		this.limits[i] = { left : p0.x, top : p0.y, right : p1.x, bottom : p1.y};
		var v = this.vertices[i];
		v.x = x * 2;
		v.y = y * 2;
		this.draw();
	}
	,setVertexLimit: function(i,x,y) {
		var p0 = this.transform(x - this.radius,y - this.radius);
		var p1 = this.transform(x + this.radius,y + this.radius);
		this.limits[i] = { left : p0.x, top : p0.y, right : p1.x, bottom : p1.y};
	}
	,__class__: justTrianglesWebGL_InteractionSurface
};
var justTrianglesWebGL_Shader = function() { };
justTrianglesWebGL_Shader.__name__ = true;
var khaMath_Matrix4 = function(_00,_10,_20,_30,_01,_11,_21,_31,_02,_12,_22,_32,_03,_13,_23,_33) {
	this._00 = _00;
	this._10 = _10;
	this._20 = _20;
	this._30 = _30;
	this._01 = _01;
	this._11 = _11;
	this._21 = _21;
	this._31 = _31;
	this._02 = _02;
	this._12 = _12;
	this._22 = _22;
	this._32 = _32;
	this._03 = _03;
	this._13 = _13;
	this._23 = _23;
	this._33 = _33;
};
khaMath_Matrix4.__name__ = true;
khaMath_Matrix4.orthogonalProjection = function(left,right,bottom,top,zn,zf) {
	var tx = -(right + left) / (right - left);
	var ty = -(top + bottom) / (top - bottom);
	var tz = -(zf + zn) / (zf - zn);
	return new khaMath_Matrix4(2 / (right - left),0,0,tx,0,2 / (top - bottom),0,ty,0,0,-2 / (zf - zn),tz,0,0,0,1);
};
khaMath_Matrix4.perspectiveProjection = function(fovY,aspect,zn,zf) {
	var uh = 1.0 / Math.tan(fovY / 2 * (Math.PI / 180));
	var uw = uh / aspect;
	return new khaMath_Matrix4(uw,0,0,0,0,uh,0,0,0,0,(zf + zn) / (zn - zf),2 * zf * zn / (zn - zf),0,0,-1,0);
};
khaMath_Matrix4.lookAt = function(eye,at,up) {
	var zaxis = new khaMath_Vector3(at.x - eye.x,at.y - eye.y,at.z - eye.z);
	zaxis.set_length(1);
	var _x = zaxis.y * up.z - zaxis.z * up.y;
	var _y = zaxis.z * up.x - zaxis.x * up.z;
	var _z = zaxis.x * up.y - zaxis.y * up.x;
	var xaxis = new khaMath_Vector3(_x,_y,_z);
	xaxis.set_length(1);
	var yaxis_z;
	var yaxis_y;
	var yaxis_x;
	var _x1 = xaxis.y * zaxis.z - xaxis.z * zaxis.y;
	var _y1 = xaxis.z * zaxis.x - xaxis.x * zaxis.z;
	var _z1 = xaxis.x * zaxis.y - xaxis.y * zaxis.x;
	yaxis_x = _x1;
	yaxis_y = _y1;
	yaxis_z = _z1;
	return new khaMath_Matrix4(xaxis.x,xaxis.y,xaxis.z,-(xaxis.x * eye.x + xaxis.y * eye.y + xaxis.z * eye.z),yaxis_x,yaxis_y,yaxis_z,-(yaxis_x * eye.x + yaxis_y * eye.y + yaxis_z * eye.z),-zaxis.x,-zaxis.y,-zaxis.z,zaxis.x * eye.x + zaxis.y * eye.y + zaxis.z * eye.z,0,0,0,1);
};
khaMath_Matrix4.prototype = {
	__class__: khaMath_Matrix4
};
var khaMath_Vector2 = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
khaMath_Vector2.__name__ = true;
khaMath_Vector2.prototype = {
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		return length;
	}
	,__class__: khaMath_Vector2
};
var khaMath_Vector3 = function(x,y,z) {
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
khaMath_Vector3.__name__ = true;
khaMath_Vector3.prototype = {
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		return length;
	}
	,__class__: khaMath_Vector3
};
var khaMath_Vector4 = function(x,y,z,w) {
	if(w == null) {
		w = 1;
	}
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
khaMath_Vector4.__name__ = true;
khaMath_Vector4.prototype = {
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		this.w *= mul;
		return length;
	}
	,__class__: khaMath_Vector4
};
var tests_MainTestSetup = function() {
	this.sceneMax = 7;
	this.scene = 0;
	this.theta = 0;
	this.rainbow = [0,16711680,16744192,16776960,65280,255,4915330,9699539,16777215];
	console.log("Testing Triangulations ");
	this.createFillData();
	justTriangles_Draw.drawTri = justTriangles_Triangle.drawTri;
	var webgl = new justTrianglesWebGL_Drawing(1024,1024);
	webgl.setupProgram("attribute vec3 pos;" + "attribute vec4 color;" + "varying vec4 vcol;" + "uniform mat4 modelViewProjection;" + "void main(void) {" + " gl_Position = modelViewProjection * vec4(pos, 1.0);" + " vcol = color;" + "}","precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}");
	new htmlHelper_tools_CSSEnterFrame().onFrame = $bind(webgl,webgl.render);
	this.webgl = webgl;
	var dom = this.webgl.canvas;
	dom.style.setProperty("pointer-events","none");
	this.interactionSurface = new justTrianglesWebGL_InteractionSurface(1024,1024,"0xcccccc");
	this.sceneSetup();
	window.document.onkeydown = $bind(this,this.keyDownHandler);
};
tests_MainTestSetup.__name__ = true;
tests_MainTestSetup.main = function() {
	new tests_MainTestSetup();
};
tests_MainTestSetup.drawSquare = function(i,ctx,v) {
	ctx.regularPoly(4,v.x,v.y,10,Math.PI / 4);
	ctx.moveTo(v.x,v.y);
};
tests_MainTestSetup.drawPoint = function(i,ctx,v) {
	ctx.regularPoly(20,v.x,v.y,5,0);
	ctx.moveTo(v.x,v.y);
};
tests_MainTestSetup.prototype = {
	createFillData: function() {
		var this1 = new triangulations_FillShape();
		this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[132.84375,99.5],[115.71875,183.78125],[45.71875,258.0625],[34.28125,372.375],[60.0,496.65625],[148.5625,612.375],[308.5625,653.78125],[432.84375,613.78125],[505.71875,525.21875],[480.0,489.5],[315.71875,459.5],[251.4375,410.9375],[241.4375,312.375],[215.71875,225.21875],[177.15625,189.5],[222.84375,123.78125]]);
		this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,0]]);
		var face = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
		this1.faces = [[face]];
		this.banana = this1;
		var this2 = new triangulations_FillShape();
		this2.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[217.8169,58.882041],[155.3191,60.502642],[110.5,91.90625],[54.46875,170.28125],[31.481076,274.72886],[35.4397,394.60211],[80.71875,467.6875],[143.40625,501.375],[209.625,498.25],[275.46875,474.75],[341.28125,438.3125],[407.5,422.21875],[484.64128,446.81954],[531.3706,452.99032],[563.84375,441.8125],[523.1787,416.13293],[478.43750000000006,369.34375],[483.92562000000004,320.25704],[539.5625,307.8125],[902.78125,307.8125],[969.0,328.1875],[995.25,348.96875],[1100.6562,336.03125],[1135.3072,349.75],[1176.6875,336.4375],[1199.7812,319.5625],[1203.3125,293.3125],[1137.875,267.0625],[1146.9062,251.78125],[1146.9062,242.0],[1140.625,239.25],[1133.1875,246.3125],[1130.0312,263.9375],[1111.25,256.09375],[1120.6562,241.21875],[1120.6562,231.40625],[1114.375,229.0625],[1107.7188,235.34375],[1104.1875,253.75],[1085.0,246.3125],[1094.7812,231.03125],[1094.0,221.21875],[1087.7188,218.875],[1079.9062000000001,224.34375],[1077.9375000000002,243.5625],[1057.9375000000002,234.9375],[1068.1250000000002,220.0625],[1067.7500000000002,210.65625],[1061.4688000000003,207.5],[1054.4375000000002,213.78125],[1051.6875000000002,232.96875],[1031.6875000000002,224.75],[1041.5000000000002,209.46875],[1041.8750000000002,199.6875],[1035.2188000000003,197.3125],[1027.3750000000002,204.375],[1024.2500000000002,221.625],[1005.4375000000002,213.78125],[1014.8438000000002,199.28125],[1015.2500000000002,189.09375],[1008.1875000000002,186.75],[1001.5312000000002,193.0],[998.3750000000002,211.03125],[956.0625000000002,194.1875],[942.7500000000002,196.9375],[939.2187500000002,243.5625],[605.7812500000002,243.9375],[572.8750000000002,240.8125],[534.4687500000002,204.375],[560.8635600000002,156.81206],[625.9934000000003,124.02377],[696.2812500000003,104.84375],[672.0,88.40625],[616.02112,82.925617],[540.34375,105.25],[473.71875,138.15625],[407.5,154.625],[342.0625,132.28125],[282.12543,89.292248],[218.0625,243.375],[234.125,259.4375],[250.0,243.5625],[275.0625,243.5625],[275.0625,309.78125],[250.78125,309.78125],[250.78125,293.3125],[234.125,309.96875],[217.84375,293.71875],[217.84375,310.15625],[193.1875,310.15625],[193.1875,243.5625],[368.625,243.5625],[368.625,283.75],[358.125,301.9375],[335.03125,309.78125],[312.34375,300.90625],[302.09375,283.125],[302.09375,243.9375],[143.40625,243.9375],[166.125,253.34375],[143.40625,276.875],[166.53125,299.96875],[143.40625,310.15625],[120.6875,299.59375],[110.875,276.46875],[120.6875,253.75]]);
		this2.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,24],[24,25],[25,26],[26,27],[27,28],[28,29],[29,30],[30,31],[31,32],[32,33],[33,34],[34,35],[35,36],[36,37],[37,38],[38,39],[39,40],[40,41],[41,42],[42,43],[43,44],[44,45],[45,46],[46,47],[47,48],[48,49],[49,50],[50,51],[51,52],[52,53],[53,54],[54,55],[55,56],[56,57],[57,58],[58,59],[59,60],[60,61],[61,62],[62,63],[63,64],[64,65],[65,66],[66,67],[67,68],[68,69],[69,70],[70,71],[71,72],[72,73],[73,74],[74,75],[75,76],[76,77],[77,78],[78,0],[79,80],[80,81],[81,82],[82,83],[83,84],[84,85],[85,86],[86,87],[87,88],[88,89],[89,90],[90,79],[91,92],[92,93],[93,94],[94,95],[95,96],[96,97],[97,91],[98,99],[99,100],[100,101],[101,102],[102,103],[103,104],[104,105],[105,98]]);
		var face0 = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78];
		var face1 = [79,80,81,82,83,84,85,86,87,88,89,90];
		var face2 = [91,92,93,94,95,96,97];
		var face3 = [98,99,100,101,102,103,104,105];
		this2.faces = [[face0,face1,face2,face3]];
		this.guitar = this2;
		var this3 = new triangulations_FillShape();
		this3.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[120.0,43.78125],[63.9375,55.21875],[53.5625,115.9375],[37.15625,120.5625],[20.71875,137.0],[9.65625,159.15625],[20.71875,181.65625],[36.78125,198.0625],[54.28125,203.0625],[65.0,264.15625],[118.5625,274.875],[174.28125,264.15625],[191.0625,197.71875],[488.9375,197.71875],[498.9375,187.71875],[498.9375,169.875],[515.59375,160.25],[506.9375,145.28125],[493.25,131.59375],[483.03125,141.8125],[476.4375,141.8125],[460.96875,126.375],[449.65625,126.375],[444.5,131.5],[432.84375,131.5],[427.9375,126.59375],[421.4375,126.59375],[411.03125,136.96875],[405.34375,136.96875],[394.84375,126.4375],[388.21875,126.4375],[383.65625,131.0],[373.5625,131.0],[368.53125,125.96875],[361.78125,125.96875],[345.5625,142.21875],[333.5625,142.21875],[328.84375,137.46875],[322.84375,137.46875],[312.0,148.3125],[301.78125,148.3125],[279.71875,126.21875],[268.9375,126.21875],[258.25,115.53125],[191.4375,115.53125],[175.03125,54.3125],[53.5625,137.71875],[70.34375,143.0625],[75.71875,159.15625],[69.65625,175.5625],[53.21875,180.9375],[37.5,175.9375],[31.0625,159.5],[37.5,142.71875]]);
		this3.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,24],[24,25],[25,26],[26,27],[27,28],[28,29],[29,30],[30,31],[31,32],[32,33],[33,34],[34,35],[35,36],[36,37],[37,38],[38,39],[39,40],[40,41],[41,42],[42,43],[43,44],[44,45],[45,0],[46,47],[47,48],[48,49],[49,50],[50,51],[51,52],[52,53],[53,46]]);
		var face01 = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45];
		var face11 = [46,47,48,49,50,51,52,53];
		this3.faces = [[face01,face11]];
		this.key = this3;
		var this4 = new triangulations_FillShape();
		this4.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[78.791898,339.19449],[640.43671,339.19449],[640.43671,352.32647],[640.43671,367.47875999999997],[640.43671,383.64119999999997],[640.43671,400.81379],[640.43671,415.46099999999996],[640.43671,432.12852],[640.43671,446.27065999999996],[640.43671,462.43309999999997],[640.43671,477.08030999999994],[640.43671,491.22243999999995],[640.43671,505.86965999999995],[640.43671,520.0117899999999],[640.43671,534.6589999999999],[640.43671,547.7909899999999],[640.43671,557.8925099999999],[78.79189899999994,557.8925099999999]]);
		this4.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,0]]);
		var face4 = [17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0];
		this4.faces = [[face4]];
		this.sheet = this4;
		var this5 = new triangulations_FillShape();
		this5.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[173.9375,349.15625],[169.78125,349.6875],[169.375,352.75],[171.5625,354.125],[171.5625,373.625],[169.375,375.0],[169.78125,378.0625],[178.96875,378.0625],[179.375,375.0],[177.1875,373.625],[177.1875,363.34375],[180.71875,362.0625],[183.25,362.84375],[183.96875,365.71875],[183.96875,373.625],[181.78125,375.0],[182.1875,378.0625],[191.375,378.0625],[191.78125,375.0],[189.5625,373.625],[189.5625,365.53125],[188.0625,359.6875],[182.5625,357.75],[179.71875,358.1875],[177.1875,359.28125],[177.1875,349.28125],[241.59375,349.15625],[237.4375,349.6875],[237.03125,352.75],[239.21875,354.125],[239.21875,373.625],[237.03125,375.0],[237.4375,378.0625],[246.625,378.0625],[247.03125,375.0],[244.84375,373.625],[244.84375,349.28125],[146.09375,350.53125],[146.09375,356.25],[148.59375,356.5625],[149.59375,354.875],[154.40625,354.875],[154.40625,373.4375],[152.21875,374.75],[152.59375,378.0625],[161.96875,378.0625],[162.375,374.75],[160.15625,373.4375],[160.15625,354.875],[164.96875,354.875],[165.96875,356.5625],[168.5,356.25],[168.5,350.53125],[218.03125,357.59375],[214.09375,358.0625],[213.6875,361.15625],[215.875,362.53125],[215.875,373.625],[213.6875,375.0],[214.09375,378.0625],[223.28125,378.0625],[223.6875,375.0],[221.46875,373.625],[221.46875,363.34375],[225.09375,362.0625],[227.5625,362.84375],[228.28125,365.71875],[228.28125,373.625],[226.09375,375.0],[226.46875,378.0625],[235.6875,378.0625],[236.09375,375.0],[233.875,373.625],[233.875,365.96875],[232.28125,359.59375],[226.8125,357.75],[223.59375,358.3125],[220.96875,359.6875],[220.96875,357.6875],[202.0625,357.75],[194.0625,359.75],[194.0,361.03125],[194.6875,364.625],[198.625,364.625],[199.09375,362.03125],[201.125,361.78125],[204.4375,364.90625],[204.4375,366.84375],[200.09375,366.84375],[194.78125,368.40625],[193.0,372.59375],[194.90625,376.84375],[199.5,378.40625],[205.71875,375.875],[206.40625,378.40625],[212.25,377.4375],[212.25,373.96875],[210.0625,373.28125],[210.0625,364.75],[208.1875,359.40625],[249.03125,358.0625],[248.625,361.15625],[249.59375,362.0],[245.1875,367.71875],[252.28125,378.0625],[258.65625,378.0625],[259.0625,375.0],[255.59375,373.28125],[251.0625,367.3125],[254.90625,362.90625],[258.21875,361.15625],[257.84375,358.0625],[201.65625,369.84375],[204.4375,369.84375],[204.4375,373.125],[201.21875,374.3125],[199.375,373.6875],[198.78125,372.03125],[169.71875,380.875],[169.34375,384.0],[171.90625,385.5],[178.4375,399.0625],[178.4375,403.65625],[176.21875,404.96875],[176.625,408.28125],[186.0,408.28125],[186.375,404.96875],[184.1875,403.65625],[184.1875,399.0625],[190.5,385.53125],[193.15625,384.0],[192.75,380.6875],[183.625,380.6875],[183.21875,384.0],[185.375,385.375],[184.09375,388.28125],[181.90625,394.34375],[181.3125,394.34375],[181.03125,393.53125],[179.03125,388.28125],[177.65625,385.21875],[179.5,384.0],[179.09375,380.6875],[216.84375,387.96875],[212.6875,388.46875],[212.3125,391.5625],[214.5,392.90625],[214.5,402.15625],[215.96875,407.25],[221.1875,408.78125],[227.6875,406.78125],[228.78125,408.78125],[234.8125,407.53125],[234.8125,404.34375],[232.625,403.6875],[232.625,388.0625],[229.375,387.9688],[225.21875,388.4688],[224.8125,391.56255],[227.03125,392.9063],[227.03125,403.12505],[223.375,404.4063],[220.75,403.7188],[220.09375,400.8438],[220.09375,388.06255],[201.5625,388.15625],[194.25,390.875],[191.71875,398.6875],[194.0,406.28125],[201.0,408.78125],[208.3125,406.0],[210.9375,398.0625],[208.59375,390.5625],[201.25,392.25],[205.15625,398.46875],[204.21875,403.28125],[201.3125,404.71875],[197.5,398.3125],[198.40625,393.625]]);
		this5.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,24],[24,25],[25,0],[26,27],[27,28],[28,29],[29,30],[30,31],[31,32],[32,33],[33,34],[34,35],[35,36],[36,26],[37,38],[38,39],[39,40],[40,41],[41,42],[42,43],[43,44],[44,45],[45,46],[46,47],[47,48],[48,49],[49,50],[50,51],[51,52],[52,37],[53,54],[54,55],[55,56],[56,57],[57,58],[58,59],[59,60],[60,61],[61,62],[62,63],[63,64],[64,65],[65,66],[66,67],[67,68],[68,69],[69,70],[70,71],[71,72],[72,73],[73,74],[74,75],[75,76],[76,77],[77,78],[78,53],[79,80],[80,81],[81,82],[82,83],[83,84],[84,85],[85,86],[86,87],[87,88],[88,89],[89,90],[90,91],[91,92],[92,93],[93,94],[94,95],[95,96],[96,97],[97,98],[98,99],[99,79],[100,101],[101,102],[102,103],[103,104],[104,105],[105,106],[106,107],[107,108],[108,109],[109,110],[110,111],[111,100],[112,113],[113,114],[114,115],[115,116],[116,117],[117,112],[118,119],[119,120],[120,121],[121,122],[122,123],[123,124],[124,125],[125,126],[126,127],[127,128],[128,129],[129,130],[130,131],[131,132],[132,133],[133,134],[134,135],[135,136],[136,137],[137,138],[138,139],[139,140],[140,141],[141,142],[142,118],[143,144],[144,145],[145,146],[146,147],[147,148],[148,149],[149,150],[150,151],[151,152],[152,153],[153,154],[154,155],[155,156],[156,157],[157,158],[158,159],[159,160],[160,161],[161,162],[162,163],[163,164],[164,143],[165,166],[166,167],[167,168],[168,169],[169,170],[170,171],[171,172],[172,165],[173,174],[174,175],[175,176],[176,177],[177,178],[178,173]]);
		var face_h = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
		var face_k0 = [26,27,28,29,30,31,32,33,34,35,36];
		var face_k1 = [100,101,102,103,104,105,106,107,108,109,110,111];
		var face_T = [37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52];
		var face_n = [53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78];
		var face_a0 = [79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99];
		var face_a1 = [112,113,114,115,116,117];
		var face_Y = [118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142];
		var face_u = [143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164];
		var face_o0 = [165,166,167,168,169,170,171,172];
		var face_o1 = [173,174,175,176,177,178];
		this5.faces = [[face_h],[face_k0,face_k1],[face_T],[face_n],[face_a0,face_a1],[face_Y],[face_u],[face_o0,face_o1]];
		this.ty = this5;
		var this6 = new triangulations_FillShape();
		this6.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[200.,200.],[100.,300.],[300.,200.],[200.,100.]]);
		this6.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[0,2],[0,3]]);
		var face5 = [];
		this6.faces = [[face5]];
		this.angleCompareShape = this6;
		var this7 = new triangulations_FillShape();
		this7.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
		this7.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
		var face02 = [0,1,2,3,4,5,6,7,8];
		var face12 = [9,10,11];
		this7.faces = [[face02,face12]];
		this.delaunayShape = this7;
		var this8 = new triangulations_FillShape();
		this8.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[10.,10.],[100.,100.],[100.,10.],[10.,100.]]);
		this8.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[2,3]]);
		var face6 = [];
		this8.faces = [[face6]];
		this.edgeIntersectShape = this8;
		var this9 = new triangulations_FillShape();
		this9.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
		this9.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
		var face03 = [0,1,2,3,4,5,6,7,8];
		var face13 = [9,10,11];
		this9.faces = [[face03,face13]];
		this.enclosingTriangle = this9;
		var this10 = new triangulations_FillShape();
		this10.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[50.,100.],[150.,50.],[150.,150.],[250.,50.],[250.,150.],[350.,100.],[450.,50.],[350.,150.],[350.,250.],[250.,250.],[150.,250.],[150.,350.]]);
		this10.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[0,2],[1,2],[3,4],[3,5],[4,5],[4,7],[4,9],[5,6],[7,8],[8,9],[10,11]]);
		var face7 = [];
		this10.faces = [[face7]];
		this.graphShape = this10;
		var this11 = new triangulations_FillShape();
		this11.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[500.,300.],[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.]]);
		this11.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[]]);
		var face8 = [1,2,3,4,5,6,7,8,9];
		this11.faces = [[face8]];
		this.pointInPolyShape = this11;
		var this12 = new triangulations_FillShape();
		this12.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[200.,200.],[100.,100.],[300.,200.],[200.,300.],[0.,0.]]);
		this12.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[]]);
		var face9 = [3,2,1];
		this12.faces = [[face9]];
		this.pointInTriangleShape = this12;
		var this13 = new triangulations_FillShape();
		this13.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,100.],[200.,100.],[200.,200.],[100.,200.],[50.,150.],[150.,50.],[250.,150.],[150.,250.]]);
		this13.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,0],[0,5],[5,1],[1,6],[6,2],[2,7],[7,3],[3,4],[4,0],[0,2]]);
		var face10 = [];
		this13.faces = [[face10]];
		this.quadEdgeShape = this13;
		var this14 = new triangulations_FillShape();
		this14.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
		this14.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
		var face04 = [0,1,2,3,4,5,6,7,8];
		var face14 = [9,10,11];
		this14.faces = [[face04,face14]];
		this.splitShape = this14;
		var this15 = new triangulations_FillShape();
		this15.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
		this15.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
		var face05 = [0,1,2,3,4,5,6,7,8];
		var face15 = [9,10,11];
		this15.faces = [[face05,face15]];
		this.triangulateShape = this15;
		var dataShapes = [this.banana,this.guitar,this.key,this.sheet,this.ty,this.angleCompareShape,this.delaunayShape,this.edgeIntersectShape,this.enclosingTriangle,this.graphShape,this.pointInPolyShape,this.pointInTriangleShape,this.quadEdgeShape,this.splitShape,this.triangulateShape];
		var l = dataShapes.length;
		var shape;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			shape = dataShapes[i];
			var this16 = shape.vertices;
			var xMin = Infinity;
			var xMax = -Infinity;
			var yMin = Infinity;
			var yMax = -Infinity;
			var l1 = this16.length;
			var _g11 = 0;
			var _g2 = this16.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var v = this16[i1];
				var x = v.x;
				var y = v.y;
				xMin = Math.min(x,xMin);
				xMax = Math.max(x,xMax);
				yMin = Math.min(y,yMin);
				yMax = Math.max(y,yMax);
			}
			var xdif = xMax - xMin;
			var ydif = yMax - yMin;
			var scaleX = 784 / xdif;
			var scaleY = 784 / ydif;
			var scale = Math.min(scaleX,scaleY);
			var marginX = (1024 - scale * xdif) / 2;
			var marginY = (1024 - scale * ydif) / 2;
			var _g12 = 0;
			var _g3 = this16.length;
			while(_g12 < _g3) {
				var i2 = _g12++;
				var v1 = this16[i2];
				v1.x = marginX + scale * (v1.x - xMin);
				v1.y = marginY + scale * (v1.y - yMin);
			}
			triangulations__$Edges_Edges_$Impl_$.set_fixedExternal(shape.edges,true);
		}
	}
	,spinForwards: function() {
		if(this.theta > Math.PI / 2) {
			this.webgl.transformationFunc = null;
			this.theta = 0;
			if(this.scene++ == this.sceneMax) {
				this.scene = 0;
			}
			window.document.onkeydown = $bind(this,this.keyDownHandler);
			this.sceneSetup();
		}
		var _this__33;
		var _this__32;
		var _this__31;
		var _this__30;
		var _this__23;
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__13;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__03;
		var _this__02;
		var _this__01;
		var _this__00;
		var alpha = this;
		var alpha1 = alpha.theta += Math.PI / 75;
		var ca = Math.cos(alpha1);
		var sa = Math.sin(alpha1);
		_this__00 = 1;
		_this__10 = 0;
		_this__20 = 0;
		_this__30 = 0;
		_this__01 = 0;
		_this__11 = ca;
		_this__21 = -sa;
		_this__31 = 0;
		_this__02 = 0;
		_this__12 = sa;
		_this__22 = ca;
		_this__32 = 0;
		_this__03 = 0;
		_this__13 = 0;
		_this__23 = 0;
		_this__33 = 1;
		var m__33;
		var m__32;
		var m__31;
		var m__30;
		var m__23;
		var m__22;
		var m__21;
		var m__20;
		var m__13;
		var m__12;
		var m__11;
		var m__10;
		var m__03;
		var m__02;
		var m__01;
		var m__00;
		var alpha2 = this.theta;
		var ca1 = Math.cos(alpha2);
		var sa1 = Math.sin(alpha2);
		m__00 = ca1;
		m__10 = 0;
		m__20 = sa1;
		m__30 = 0;
		m__01 = 0;
		m__11 = 1;
		m__21 = 0;
		m__31 = 0;
		m__02 = -sa1;
		m__12 = 0;
		m__22 = ca1;
		m__32 = 0;
		m__03 = 0;
		m__13 = 0;
		m__23 = 0;
		m__33 = 1;
		return new khaMath_Matrix4(_this__00 * m__00 + _this__10 * m__01 + _this__20 * m__02 + _this__30 * m__03,_this__00 * m__10 + _this__10 * m__11 + _this__20 * m__12 + _this__30 * m__13,_this__00 * m__20 + _this__10 * m__21 + _this__20 * m__22 + _this__30 * m__23,_this__00 * m__30 + _this__10 * m__31 + _this__20 * m__32 + _this__30 * m__33,_this__01 * m__00 + _this__11 * m__01 + _this__21 * m__02 + _this__31 * m__03,_this__01 * m__10 + _this__11 * m__11 + _this__21 * m__12 + _this__31 * m__13,_this__01 * m__20 + _this__11 * m__21 + _this__21 * m__22 + _this__31 * m__23,_this__01 * m__30 + _this__11 * m__31 + _this__21 * m__32 + _this__31 * m__33,_this__02 * m__00 + _this__12 * m__01 + _this__22 * m__02 + _this__32 * m__03,_this__02 * m__10 + _this__12 * m__11 + _this__22 * m__12 + _this__32 * m__13,_this__02 * m__20 + _this__12 * m__21 + _this__22 * m__22 + _this__32 * m__23,_this__02 * m__30 + _this__12 * m__31 + _this__22 * m__32 + _this__32 * m__33,_this__03 * m__00 + _this__13 * m__01 + _this__23 * m__02 + _this__33 * m__03,_this__03 * m__10 + _this__13 * m__11 + _this__23 * m__12 + _this__33 * m__13,_this__03 * m__20 + _this__13 * m__21 + _this__23 * m__22 + _this__33 * m__23,_this__03 * m__30 + _this__13 * m__31 + _this__23 * m__32 + _this__33 * m__33);
	}
	,spinBackwards: function() {
		if(this.theta > Math.PI / 2) {
			this.webgl.transformationFunc = null;
			this.theta = 0;
			if(this.scene-- == 0) {
				this.scene = this.sceneMax;
			}
			window.document.onkeydown = $bind(this,this.keyDownHandler);
			this.sceneSetup();
		}
		var _this__33;
		var _this__32;
		var _this__31;
		var _this__30;
		var _this__23;
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__13;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__03;
		var _this__02;
		var _this__01;
		var _this__00;
		var alpha = this;
		var alpha1 = alpha.theta += Math.PI / 75;
		var ca = Math.cos(alpha1);
		var sa = Math.sin(alpha1);
		_this__00 = ca;
		_this__10 = 0;
		_this__20 = sa;
		_this__30 = 0;
		_this__01 = 0;
		_this__11 = 1;
		_this__21 = 0;
		_this__31 = 0;
		_this__02 = -sa;
		_this__12 = 0;
		_this__22 = ca;
		_this__32 = 0;
		_this__03 = 0;
		_this__13 = 0;
		_this__23 = 0;
		_this__33 = 1;
		var m__33;
		var m__32;
		var m__31;
		var m__30;
		var m__23;
		var m__22;
		var m__21;
		var m__20;
		var m__13;
		var m__12;
		var m__11;
		var m__10;
		var m__03;
		var m__02;
		var m__01;
		var m__00;
		var alpha2 = this.theta;
		var ca1 = Math.cos(alpha2);
		var sa1 = Math.sin(alpha2);
		m__00 = 1;
		m__10 = 0;
		m__20 = 0;
		m__30 = 0;
		m__01 = 0;
		m__11 = ca1;
		m__21 = -sa1;
		m__31 = 0;
		m__02 = 0;
		m__12 = sa1;
		m__22 = ca1;
		m__32 = 0;
		m__03 = 0;
		m__13 = 0;
		m__23 = 0;
		m__33 = 1;
		return new khaMath_Matrix4(_this__00 * m__00 + _this__10 * m__01 + _this__20 * m__02 + _this__30 * m__03,_this__00 * m__10 + _this__10 * m__11 + _this__20 * m__12 + _this__30 * m__13,_this__00 * m__20 + _this__10 * m__21 + _this__20 * m__22 + _this__30 * m__23,_this__00 * m__30 + _this__10 * m__31 + _this__20 * m__32 + _this__30 * m__33,_this__01 * m__00 + _this__11 * m__01 + _this__21 * m__02 + _this__31 * m__03,_this__01 * m__10 + _this__11 * m__11 + _this__21 * m__12 + _this__31 * m__13,_this__01 * m__20 + _this__11 * m__21 + _this__21 * m__22 + _this__31 * m__23,_this__01 * m__30 + _this__11 * m__31 + _this__21 * m__32 + _this__31 * m__33,_this__02 * m__00 + _this__12 * m__01 + _this__22 * m__02 + _this__32 * m__03,_this__02 * m__10 + _this__12 * m__11 + _this__22 * m__12 + _this__32 * m__13,_this__02 * m__20 + _this__12 * m__21 + _this__22 * m__22 + _this__32 * m__23,_this__02 * m__30 + _this__12 * m__31 + _this__22 * m__32 + _this__32 * m__33,_this__03 * m__00 + _this__13 * m__01 + _this__23 * m__02 + _this__33 * m__03,_this__03 * m__10 + _this__13 * m__11 + _this__23 * m__12 + _this__33 * m__13,_this__03 * m__20 + _this__13 * m__21 + _this__23 * m__22 + _this__33 * m__23,_this__03 * m__30 + _this__13 * m__31 + _this__23 * m__32 + _this__33 * m__33);
	}
	,keyDownHandler: function(e) {
		e.preventDefault();
		if(e.keyCode == 37) {
			console.log("LEFT");
			this.webgl.transformationFunc = $bind(this,this.spinBackwards);
		} else if(e.keyCode == 39) {
			console.log("RIGHT");
			this.webgl.transformationFunc = $bind(this,this.spinForwards);
		}
		console.log(e.keyCode);
	}
	,sceneSetup: function() {
		var vert;
		var _g = this.scene;
		switch(_g) {
		case 0:
			console.log("banana test");
			vert = this.banana.vertices;
			break;
		case 1:
			console.log("edge intersect");
			vert = this.edgeIntersectShape.vertices;
			break;
		case 2:
			console.log("poly in point");
			vert = this.pointInPolyShape.vertices;
			break;
		case 3:
			console.log("angle compare");
			vert = this.angleCompareShape.vertices;
			break;
		case 4:
			console.log("angle compare");
			vert = this.pointInTriangleShape.vertices;
			break;
		case 5:
			console.log("triangulate test");
			vert = this.triangulateShape.vertices;
			break;
		case 6:
			console.log("quad edge test");
			vert = this.quadEdgeShape.vertices;
			break;
		case 7:
			console.log("delaunay test");
			vert = this.delaunayShape.vertices;
			break;
		default:
			console.log("no test");
			vert = null;
		}
		this.draw();
		this.interactionSurface.setup(vert,$bind(this,this.transform),$bind(this,this.draw));
	}
	,draw: function() {
		justTriangles_Triangle.triangles = [];
		var _g = this.scene;
		switch(_g) {
		case 0:
			this.bananaTest();
			break;
		case 1:
			this.edgeIntersectTest();
			break;
		case 2:
			this.pointInPolyTest();
			break;
		case 3:
			this.angleCompareTest();
			break;
		case 4:
			this.pointInTriangleTest();
			break;
		case 5:
			this.triangulateTest();
			break;
		case 6:
			this.quadEdgeTest();
			break;
		case 7:
			this.delaunayTest();
			break;
		default:
		}
		this.webgl.clearVerticesAndColors();
		this.webgl.setTriangles(justTriangles_Triangle.triangles,this.rainbow);
	}
	,pointInPolyTest: function() {
		var thick = 4;
		var shape = this.pointInPolyShape;
		var verts = shape.vertices;
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		this.ctx.setThickness(4);
		this.ctx.setColor(0,3);
		this.ctx.fill = true;
		this.ctx.lineType = justTriangles_LineType.TriangleJoinCurve;
		this.drawFaces(shape,this.ctx,false);
		this.ctx.fill = true;
		this.ctx.lineType = justTriangles_LineType.TriangleJoinCurve;
		var col = triangulations__$Vertices_Vertices_$Impl_$.pointInPolygon(verts,shape.faces[0][0],verts[0]) ? 4 : 1;
		this.ctx.setColor(col,col);
		var ctx = this.ctx;
		var v = verts[0];
		ctx.regularPoly(4,v.x,v.y,10,Math.PI / 4);
		ctx.moveTo(v.x,v.y);
		this.drawVerticesPoints(shape,this.ctx,0,col,5);
		this.ctx.render(thick,false);
	}
	,angleCompareTest: function() {
		var shape = this.angleCompareShape;
		var vert = shape.vertices;
		var v0 = vert[0];
		var v1 = vert[1];
		var v2 = vert[2];
		var v3 = vert[3];
		var c = v0;
		var cd_y;
		var cd_x = v1.x - c.x;
		cd_y = v1.y - c.y;
		var cmp = function(u,v) {
			var cu_y;
			var cu_x = u.x - c.x;
			cu_y = u.y - c.y;
			var cv_y;
			var cv_x = v.x - c.x;
			cv_y = v.y - c.y;
			var cvxcu = cv_x * cu_y - cv_y * cu_x;
			if(cvxcu == 0 && cu_x * cv_x + cu_y * cv_y >= 0) {
				return 0;
			}
			var cuxcd = cu_x * cd_y - cu_y * cd_x;
			var cvxcd = cv_x * cd_y - cv_y * cd_x;
			if(cuxcd == 0 && cd_x * cu_x + cd_y * cu_y >= 0) {
				return -1;
			}
			if(cvxcd == 0 && cd_x * cv_x + cd_y * cv_y >= 0) {
				return 1;
			}
			if(cuxcd * cvxcd >= 0) {
				return cvxcu;
			}
			return cuxcd;
		};
		var r = cmp(v2,v3);
		var thick = 4;
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		this.ctx.setThickness(4);
		this.ctx.setColor(0,3);
		this.ctx.fill = true;
		this.drawEdges(shape.edges,shape,this.ctx,true);
		this.drawVerticesPoints(shape,this.ctx,0,0,5);
		var c2 = r < 0 ? 1 : 0;
		var c3 = r > 0 ? 1 : 0;
		this.ctx.setColor(c2,c2);
		var ctx = this.ctx;
		ctx.regularPoly(4,v2.x,v2.y,10,Math.PI / 4);
		ctx.moveTo(v2.x,v2.y);
		this.ctx.setColor(c3,c3);
		var ctx1 = this.ctx;
		ctx1.regularPoly(4,v3.x,v3.y,10,Math.PI / 4);
		ctx1.moveTo(v3.x,v3.y);
		this.ctx.render(thick,false);
	}
	,pointInTriangleTest: function() {
		var shape = this.pointInTriangleShape;
		var vert = shape.vertices;
		var v0 = vert[0];
		var v1 = vert[1];
		var v2 = vert[2];
		var v3 = vert[3];
		var v4 = vert[4];
		var a = v1;
		var u_y;
		var u_x = v2.x - a.x;
		u_y = v2.y - a.y;
		var v_y;
		var v_x = v3.x - a.x;
		v_y = v3.y - a.y;
		var vxu = v_x * u_y - v_y * u_x;
		var uxv = -vxu;
		var inTriangle = function(p) {
			var w_y;
			var w_x = p.x - a.x;
			w_y = p.y - a.y;
			var vxw = v_x * w_y - v_y * w_x;
			if(vxu * vxw < 0) {
				return false;
			}
			var uxw = u_x * w_y - u_y * w_x;
			if(uxv * uxw < 0) {
				return false;
			}
			return Math.abs(uxw) + Math.abs(vxw) <= Math.abs(uxv);
		};
		var xa = v1.x;
		var ya = v1.y;
		var xb = v2.x;
		var yb = v2.y;
		var xc = v3.x;
		var yc = v3.y;
		var d = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
		var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
		var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
		var xp = ka * (yb - yc) - kb * (ya - yc);
		var yp = kb * (xa - xc) - ka * (xb - xc);
		vert[4] = new khaMath_Vector2(xp / d,yp / d);
		v4 = vert[4];
		var thick = 4;
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		this.ctx.setThickness(4);
		this.ctx.setColor(0,3);
		this.ctx.fill = false;
		var dx = v4.x - v1.x;
		var dy = v4.y - v1.y;
		this.ctx.regularPoly(60,v4.x,v4.y,Math.sqrt(dx * dx + dy * dy),0);
		this.ctx.moveTo(v4.x,v4.y);
		this.ctx.setColor(1,2);
		this.ctx.fill = true;
		this.drawFaces(shape,this.ctx,false);
		this.ctx.setColor(0,3);
		this.ctx.fill = true;
		this.drawVerticesPoints(shape,this.ctx,0,0,5);
		var c0 = inTriangle(v0) ? 1 : 4;
		this.ctx.setColor(c0,c0);
		var ctx = this.ctx;
		ctx.regularPoly(4,v0.x,v0.y,10,Math.PI / 4);
		ctx.moveTo(v0.x,v0.y);
		var u = v1;
		var uv_y;
		var uv_x = v2.x - u.x;
		uv_y = v2.y - u.y;
		var uvLenSq = uv_x * uv_x + uv_y * uv_y;
		console.log("d " + (function(p1) {
			var v_y1;
			var v_x1 = u.x - p1.x;
			v_y1 = u.y - p1.y;
			var uvxpu = uv_x * v_y1 - uv_y * v_x1;
			return uvxpu * uvxpu / uvLenSq;
		})(v0));
		this.ctx.render(thick,false);
	}
	,edgeIntersectTest: function() {
		var shape = this.edgeIntersectShape;
		var vert = shape.vertices;
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		var thick = 4;
		this.ctx.setThickness(4);
		this.ctx.fill = false;
		var v0 = vert[0];
		var v1 = vert[1];
		var v2 = vert[2];
		var v3 = vert[3];
		var out = true;
		var u_y;
		var u_x = v1.x - v0.x;
		u_y = v1.y - v0.y;
		var v_y;
		var v_x = v2.x - v0.x;
		v_y = v2.y - v0.y;
		var v_y1;
		var v_x1 = v3.x - v0.x;
		v_y1 = v3.y - v0.y;
		var su = (u_x * v_y - u_y * v_x) * (u_x * v_y1 - u_y * v_x1);
		if(su > 0) {
			out = false;
		} else {
			var v_y2;
			var v_x2 = v3.x - v2.x;
			v_y2 = v3.y - v2.y;
			var v_y3;
			var v_x3 = v0.x - v2.x;
			v_y3 = v0.y - v2.y;
			var v_y4;
			var v_x4 = v1.x - v2.x;
			v_y4 = v1.y - v2.y;
			var sv = (v_x2 * v_y3 - v_y2 * v_x3) * (v_x2 * v_y4 - v_y2 * v_x4);
			if(sv > 0) {
				out = false;
			} else if(su == 0 && sv == 0) {
				var dx = v0.x - v1.x;
				var dy = v0.y - v1.y;
				var abLenSq = dx * dx + dy * dy;
				var dx1 = v0.x - v2.x;
				var dy1 = v0.y - v2.y;
				if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
					var dx2 = v0.x - v3.x;
					var dy2 = v0.y - v3.y;
					out = dx2 * dx2 + dy2 * dy2 <= abLenSq;
				} else {
					out = true;
				}
			}
		}
		if(out == true) {
			this.ctx.setColor(1);
		} else {
			this.ctx.setColor(4);
		}
		this.drawEdges(shape.edges,shape,this.ctx,true);
		this.ctx.render(thick,false);
	}
	,triangulateTest: function() {
		var shape = this.triangulateShape;
		var vert = shape.vertices;
		var face = shape.faces;
		var face1 = face[0];
		var face2 = face1[0];
		var linkedPoly = new triangulations_DllNode(face2[0]);
		var node = linkedPoly;
		var l = face2.length;
		var _g1 = 1;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			var prevDllNode = node;
			node = new triangulations_DllNode(face2[i]);
			prevDllNode.next = node;
			node.prev = prevDllNode;
		}
		node.next = linkedPoly;
		linkedPoly.prev = node;
		var polies = [linkedPoly];
		var holes = [];
		var l1 = face1.length;
		var _g11 = 1;
		var _g2 = l1;
		while(_g11 < _g2) {
			var k = _g11++;
			var face3 = face1[k];
			var linkedPoly1 = new triangulations_DllNode(face3[0]);
			var node1 = linkedPoly1;
			var l2 = face3.length;
			var _g12 = 1;
			var _g3 = l2;
			while(_g12 < _g3) {
				var i1 = _g12++;
				var prevDllNode1 = node1;
				node1 = new triangulations_DllNode(face3[i1]);
				prevDllNode1.next = node1;
				node1.prev = prevDllNode1;
			}
			node1.next = linkedPoly1;
			linkedPoly1.prev = node1;
			holes.push(linkedPoly1);
		}
		var v = null;
		var this1;
		if(v == null) {
			v = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this1 = v;
		var diagonals = this1;
		while(polies.length > 0) {
			var poly = polies.pop();
			var node2 = poly;
			var a;
			var b;
			var c;
			var convex = false;
			while(true) {
				a = vert[node2.prev.value];
				b = vert[node2.value];
				c = vert[node2.next.value];
				var _this_y;
				var _this_x = b.x - a.x;
				_this_y = b.y - a.y;
				var v_y;
				var v_x = c.x - b.x;
				v_y = c.y - b.y;
				convex = _this_x * v_y - _this_y * v_x < 0;
				node2 = node2.next;
				if(!(!convex && node2 != poly)) {
					break;
				}
			}
			if(!convex) {
				continue;
			}
			var aDllNode = node2.prev.prev;
			var bDllNode = node2.prev;
			var cDllNode = node2;
			var acOK = true;
			var a1 = [a];
			var u_y = [];
			var u_x = [];
			var y = b.y - a1[0].y;
			u_x[0] = b.x - a1[0].x;
			u_y[0] = y;
			var v_y1 = [];
			var v_x1 = [];
			var y1 = c.y - a1[0].y;
			v_x1[0] = c.x - a1[0].x;
			v_y1[0] = y1;
			var vxu = [v_x1[0] * u_y[0] - v_y1[0] * u_x[0]];
			var uxv = [-vxu[0]];
			var inabc = (function(v_y2,v_x2,u_y1,u_x1,uxv1,vxu1,a2) {
				return function(p) {
					var w_y;
					var w_x = p.x - a2[0].x;
					w_y = p.y - a2[0].y;
					var vxw = v_x2[0] * w_y - v_y2[0] * w_x;
					if(vxu1[0] * vxw < 0) {
						return false;
					}
					var uxw = u_x1[0] * w_y - u_y1[0] * w_x;
					if(uxv1[0] * uxw < 0) {
						return false;
					}
					return Math.abs(uxw) + Math.abs(vxw) <= Math.abs(uxv1[0]);
				};
			})(v_y1,v_x1,u_y,u_x,uxv,vxu,a1);
			if(!inabc(vert[aDllNode.prev.value])) {
				acOK = !inabc(vert[cDllNode.next.value]);
			} else {
				acOK = false;
			}
			if(acOK) {
				var nodeBeg = cDllNode.next;
				var nodeEnd = aDllNode.prev;
				var out = false;
				if(nodeEnd == null) {
					var c1 = vert[nodeBeg.value];
					var d = vert[nodeBeg.next.value];
					var acOK1;
					if(c1 != a && c1 != c && d != a && d != c) {
						var out1 = true;
						var u_y2;
						var u_x2 = c.x - a.x;
						u_y2 = c.y - a.y;
						var v_y3;
						var v_x3 = c1.x - a.x;
						v_y3 = c1.y - a.y;
						var v_y4;
						var v_x4 = d.x - a.x;
						v_y4 = d.y - a.y;
						var su = (u_x2 * v_y3 - u_y2 * v_x3) * (u_x2 * v_y4 - u_y2 * v_x4);
						if(su > 0) {
							out1 = false;
						} else {
							var v_y5;
							var v_x5 = d.x - c1.x;
							v_y5 = d.y - c1.y;
							var v_y6;
							var v_x6 = a.x - c1.x;
							v_y6 = a.y - c1.y;
							var v_y7;
							var v_x7 = c.x - c1.x;
							v_y7 = c.y - c1.y;
							var sv = (v_x5 * v_y6 - v_y5 * v_x6) * (v_x5 * v_y7 - v_y5 * v_x7);
							if(sv > 0) {
								out1 = false;
							} else if(su == 0 && sv == 0) {
								var dx = a.x - c.x;
								var dy = a.y - c.y;
								var abLenSq = dx * dx + dy * dy;
								var dx1 = a.x - c1.x;
								var dy1 = a.y - c1.y;
								if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
									var dx2 = a.x - d.x;
									var dy2 = a.y - d.y;
									out1 = dx2 * dx2 + dy2 * dy2 <= abLenSq;
								} else {
									out1 = true;
								}
							}
						}
						acOK1 = out1;
					} else {
						acOK1 = false;
					}
					if(acOK1) {
						out = true;
					} else {
						nodeEnd = nodeBeg;
						nodeBeg = nodeBeg.next;
					}
				}
				if(out != true) {
					var node3 = nodeBeg;
					while(node3 != nodeEnd) {
						var c2 = vert[node3.value];
						var d1 = vert[node3.next.value];
						var acOK2;
						if(c2 != a && c2 != c && d1 != a && d1 != c) {
							var out2 = true;
							var u_y3;
							var u_x3 = c.x - a.x;
							u_y3 = c.y - a.y;
							var v_y8;
							var v_x8 = c2.x - a.x;
							v_y8 = c2.y - a.y;
							var v_y9;
							var v_x9 = d1.x - a.x;
							v_y9 = d1.y - a.y;
							var su1 = (u_x3 * v_y8 - u_y3 * v_x8) * (u_x3 * v_y9 - u_y3 * v_x9);
							if(su1 > 0) {
								out2 = false;
							} else {
								var v_y10;
								var v_x10 = d1.x - c2.x;
								v_y10 = d1.y - c2.y;
								var v_y11;
								var v_x11 = a.x - c2.x;
								v_y11 = a.y - c2.y;
								var v_y12;
								var v_x12 = c.x - c2.x;
								v_y12 = c.y - c2.y;
								var sv1 = (v_x10 * v_y11 - v_y10 * v_x11) * (v_x10 * v_y12 - v_y10 * v_x12);
								if(sv1 > 0) {
									out2 = false;
								} else if(su1 == 0 && sv1 == 0) {
									var dx3 = a.x - c.x;
									var dy3 = a.y - c.y;
									var abLenSq1 = dx3 * dx3 + dy3 * dy3;
									var dx4 = a.x - c2.x;
									var dy4 = a.y - c2.y;
									if(!(dx4 * dx4 + dy4 * dy4 <= abLenSq1)) {
										var dx5 = a.x - d1.x;
										var dy5 = a.y - d1.y;
										out2 = dx5 * dx5 + dy5 * dy5 <= abLenSq1;
									} else {
										out2 = true;
									}
								}
							}
							acOK2 = out2;
						} else {
							acOK2 = false;
						}
						if(acOK2) {
							out = true;
							break;
						} else {
							node3 = node3.next;
						}
					}
				}
				acOK = !out;
			}
			var holesLen = holes.length;
			var _g13 = 0;
			var _g4 = holesLen;
			while(_g13 < _g4) {
				var l3 = _g13++;
				var nodeBeg1 = holes[l3];
				var nodeEnd1 = null;
				var out3 = false;
				if(nodeEnd1 == null) {
					var c3 = vert[nodeBeg1.value];
					var d2 = vert[nodeBeg1.next.value];
					var acOK3;
					if(c3 != a && c3 != c && d2 != a && d2 != c) {
						var out4 = true;
						var u_y4;
						var u_x4 = c.x - a.x;
						u_y4 = c.y - a.y;
						var v_y13;
						var v_x13 = c3.x - a.x;
						v_y13 = c3.y - a.y;
						var v_y14;
						var v_x14 = d2.x - a.x;
						v_y14 = d2.y - a.y;
						var su2 = (u_x4 * v_y13 - u_y4 * v_x13) * (u_x4 * v_y14 - u_y4 * v_x14);
						if(su2 > 0) {
							out4 = false;
						} else {
							var v_y15;
							var v_x15 = d2.x - c3.x;
							v_y15 = d2.y - c3.y;
							var v_y16;
							var v_x16 = a.x - c3.x;
							v_y16 = a.y - c3.y;
							var v_y17;
							var v_x17 = c.x - c3.x;
							v_y17 = c.y - c3.y;
							var sv2 = (v_x15 * v_y16 - v_y15 * v_x16) * (v_x15 * v_y17 - v_y15 * v_x17);
							if(sv2 > 0) {
								out4 = false;
							} else if(su2 == 0 && sv2 == 0) {
								var dx6 = a.x - c.x;
								var dy6 = a.y - c.y;
								var abLenSq2 = dx6 * dx6 + dy6 * dy6;
								var dx7 = a.x - c3.x;
								var dy7 = a.y - c3.y;
								if(!(dx7 * dx7 + dy7 * dy7 <= abLenSq2)) {
									var dx8 = a.x - d2.x;
									var dy8 = a.y - d2.y;
									out4 = dx8 * dx8 + dy8 * dy8 <= abLenSq2;
								} else {
									out4 = true;
								}
							}
						}
						acOK3 = out4;
					} else {
						acOK3 = false;
					}
					if(acOK3) {
						out3 = true;
					} else {
						nodeEnd1 = nodeBeg1;
						nodeBeg1 = nodeBeg1.next;
					}
				}
				if(out3 != true) {
					var node4 = nodeBeg1;
					while(node4 != nodeEnd1) {
						var c4 = vert[node4.value];
						var d3 = vert[node4.next.value];
						var acOK4;
						if(c4 != a && c4 != c && d3 != a && d3 != c) {
							var out5 = true;
							var u_y5;
							var u_x5 = c.x - a.x;
							u_y5 = c.y - a.y;
							var v_y18;
							var v_x18 = c4.x - a.x;
							v_y18 = c4.y - a.y;
							var v_y19;
							var v_x19 = d3.x - a.x;
							v_y19 = d3.y - a.y;
							var su3 = (u_x5 * v_y18 - u_y5 * v_x18) * (u_x5 * v_y19 - u_y5 * v_x19);
							if(su3 > 0) {
								out5 = false;
							} else {
								var v_y20;
								var v_x20 = d3.x - c4.x;
								v_y20 = d3.y - c4.y;
								var v_y21;
								var v_x21 = a.x - c4.x;
								v_y21 = a.y - c4.y;
								var v_y22;
								var v_x22 = c.x - c4.x;
								v_y22 = c.y - c4.y;
								var sv3 = (v_x20 * v_y21 - v_y20 * v_x21) * (v_x20 * v_y22 - v_y20 * v_x22);
								if(sv3 > 0) {
									out5 = false;
								} else if(su3 == 0 && sv3 == 0) {
									var dx9 = a.x - c.x;
									var dy9 = a.y - c.y;
									var abLenSq3 = dx9 * dx9 + dy9 * dy9;
									var dx10 = a.x - c4.x;
									var dy10 = a.y - c4.y;
									if(!(dx10 * dx10 + dy10 * dy10 <= abLenSq3)) {
										var dx11 = a.x - d3.x;
										var dy11 = a.y - d3.y;
										out5 = dx11 * dx11 + dy11 * dy11 <= abLenSq3;
									} else {
										out5 = true;
									}
								}
							}
							acOK4 = out5;
						} else {
							acOK4 = false;
						}
						if(acOK4) {
							out3 = true;
							break;
						} else {
							node4 = node4.next;
						}
					}
				}
				acOK = !out3;
				if(!acOK) {
					break;
				}
			}
			var split;
			var fromDllNode;
			var toDllNode;
			if(acOK) {
				fromDllNode = cDllNode;
				toDllNode = aDllNode;
				split = true;
			} else {
				var a3 = [a];
				var b1 = [b];
				var c5 = [c];
				var a4 = [a3[0]];
				var u_y6 = [];
				var u_x6 = [];
				var y2 = b1[0].y - a4[0].y;
				u_x6[0] = b1[0].x - a4[0].x;
				u_y6[0] = y2;
				var v_y23 = [];
				var v_x23 = [];
				var y3 = c5[0].y - a4[0].y;
				v_x23[0] = c5[0].x - a4[0].x;
				v_y23[0] = y3;
				var vxu2 = [v_x23[0] * u_y6[0] - v_y23[0] * u_x6[0]];
				var uxv2 = [-vxu2[0]];
				var inabc1 = [(function(v_y24,v_x24,u_y7,u_x7,uxv3,vxu3,a5) {
					return function(p1) {
						var w_y1;
						var w_x1 = p1.x - a5[0].x;
						w_y1 = p1.y - a5[0].y;
						var vxw1 = v_x24[0] * w_y1 - v_y24[0] * w_x1;
						if(vxu3[0] * vxw1 < 0) {
							return false;
						}
						var uxw1 = u_x7[0] * w_y1 - u_y7[0] * w_x1;
						if(uxv3[0] * uxw1 < 0) {
							return false;
						}
						return Math.abs(uxw1) + Math.abs(vxw1) <= Math.abs(uxv3[0]);
					};
				})(v_y23,v_x23,u_y6,u_x6,uxv2,vxu2,a4)];
				var u = [a3[0]];
				var uv_y = [];
				var uv_x = [];
				var y4 = c5[0].y - u[0].y;
				uv_x[0] = c5[0].x - u[0].x;
				uv_y[0] = y4;
				var uvLenSq = [uv_x[0] * uv_x[0] + uv_y[0] * uv_y[0]];
				var acDistSq = [(function(uv_y1,uv_x1,uvLenSq1,u1) {
					return function(p2) {
						var v_y25;
						var v_x25 = u1[0].x - p2.x;
						v_y25 = u1[0].y - p2.y;
						var uvxpu = uv_x1[0] * v_y25 - uv_y1[0] * v_x25;
						return uvxpu * uvxpu / uvLenSq1[0];
					};
				})(uv_y,uv_x,uvLenSq,u)];
				var findBest = (function(acDistSq1,inabc2,c6,b2,a6) {
					return function(vertices,nodeBeg2,nodeEnd2,bestDllNode) {
						var v1;
						var maxDepthSq;
						if(bestDllNode != null) {
							v1 = bestDllNode.value;
							maxDepthSq = acDistSq1[0](vertices[v1]);
						} else {
							maxDepthSq = -1;
						}
						var node5 = nodeBeg2;
						while(true) {
							var v2 = vertices[node5.value];
							if(v2 != a6[0] && v2 != b2[0] && v2 != c6[0] && inabc2[0](v2)) {
								var depthSq = acDistSq1[0](v2);
								if(depthSq > maxDepthSq) {
									maxDepthSq = depthSq;
									bestDllNode = node5;
								}
							}
							node5 = node5.next;
							if(!(node5 != nodeEnd2)) {
								break;
							}
						}
						return bestDllNode;
					};
				})(acDistSq,inabc1,c5,b1,a3);
				var best = cDllNode.next != aDllNode ? findBest(vert,cDllNode.next,aDllNode) : null;
				var lHole = -1;
				var holesLen1 = holes.length;
				var _g14 = 0;
				var _g5 = holesLen1;
				while(_g14 < _g5) {
					var l4 = _g14++;
					var newBest = findBest(vert,holes[l4],holes[l4],best);
					if(newBest != best) {
						lHole = l4;
					}
					best = newBest;
				}
				fromDllNode = bDllNode;
				toDllNode = best;
				if(lHole < 0) {
					split = true;
				} else {
					holes.splice(lHole,1);
					split = false;
				}
			}
			if(toDllNode == null) {
				continue;
			}
			diagonals.push(new triangulations_Edge(fromDllNode.value,toDllNode.value));
			var poly1 = new triangulations_DllNode(fromDllNode.value);
			poly1.next = fromDllNode.next;
			var tempDllNode = new triangulations_DllNode(toDllNode.value);
			tempDllNode.prev = toDllNode.prev;
			tempDllNode.next = poly1;
			poly1.prev = tempDllNode;
			fromDllNode.next.prev = poly1;
			toDllNode.prev.next = poly1.prev;
			fromDllNode.next = toDllNode;
			toDllNode.prev = fromDllNode;
			var poly2 = fromDllNode;
			if(split) {
				polies.push(poly1);
				polies.push(poly2);
			} else {
				polies.push(poly2);
			}
		}
		var diags = diagonals;
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		var thick = 4;
		this.ctx.setThickness(4);
		this.ctx.fill = true;
		this.ctx.setColor(0,3);
		this.drawFaces(shape,this.ctx,false);
		this.ctx.fill = false;
		this.ctx.setColor(4,3);
		this.ctx.moveTo(0,0);
		var this2 = shape.edges;
		var v3 = null;
		var this3;
		if(v3 == null) {
			v3 = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this3 = v3;
		var e = this3;
		var l5 = this2.length;
		var tempIn;
		var tempOut;
		var _g15 = 0;
		var _g6 = l5;
		while(_g15 < _g6) {
			var i2 = _g15++;
			var _this = this2[i2];
			var e1 = new triangulations_Edge(_this.p,_this.q);
			e1.fixed = _this.fixed;
			e1.external = _this.external;
			e[i2] = e1;
		}
		var this4 = e;
		var l6 = this4.length;
		var el = diags.length;
		var _g16 = 0;
		var _g7 = el;
		while(_g16 < _g7) {
			var i3 = _g16++;
			this4[l6 + i3] = diags[i3];
		}
		var edges = this4;
		this.drawEdges(edges,shape,this.ctx,true);
		this.ctx.setColor(0,3);
		this.drawFaces(shape,this.ctx,false);
		this.ctx.render(thick,false);
	}
	,quadEdgeTest: function() {
		var shape = this.quadEdgeShape;
		var vert = shape.vertices;
		var face = shape.faces;
		var edges = shape.edges;
		var v = null;
		var this1;
		if(v == null) {
			v = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this1 = v;
		var coEdges = this1;
		var sideEdges = [];
		triangulations_Triangulate.makeQuadEdge(vert,edges,coEdges,sideEdges);
		console.log(" coEdges " + triangulations__$Edges_Edges_$Impl_$.toString(coEdges));
		console.log(" edges " + triangulations__$Edges_Edges_$Impl_$.toString(edges));
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		var thick = 4;
		this.ctx.setThickness(4);
		this.ctx.fill = true;
		this.ctx.setColor(0,3);
		this.ctx.moveTo(0,0);
		this.drawEdges(edges,shape,this.ctx,true);
		this.ctx.fill = true;
		this.ctx.setColor(5,2);
		this.ctx.moveTo(0,0);
		var _this = edges[12];
		var e = new triangulations_Edge(_this.p,_this.q);
		e.fixed = _this.fixed;
		e.external = _this.external;
		var edge = e;
		var coEdge = coEdges[12];
		var se = sideEdges[12];
		var j0 = se.a;
		var j1 = se.b;
		var j2 = se.c;
		var j3 = se.d;
		var _this1 = coEdges[j0];
		var y = coEdge.q;
		if(_this1 != null) {
			if(_this1.p == edge.p) {
				_this1.p = y;
			} else {
				_this1.p = y;
			}
		}
		se = sideEdges[j0];
		if(se != null) {
			if(12 == se.a) {
				se.a = j1;
			} else if(12 == se.b) {
				se.b = j1;
			} else if(12 == se.c) {
				se.c = j1;
			} else {
				se.d = j1;
			}
		}
		if(se != null) {
			if(j3 == se.a) {
				se.a = 12;
			} else if(j3 == se.b) {
				se.b = 12;
			} else if(j3 == se.c) {
				se.c = 12;
			} else {
				se.d = 12;
			}
		}
		var _this2 = coEdges[j1];
		var y1 = coEdge.p;
		if(_this2 != null) {
			if(_this2.p == edge.p) {
				_this2.p = y1;
			} else {
				_this2.p = y1;
			}
		}
		se = sideEdges[j1];
		if(se != null) {
			if(12 == se.a) {
				se.a = j0;
			} else if(12 == se.b) {
				se.b = j0;
			} else if(12 == se.c) {
				se.c = j0;
			} else {
				se.d = j0;
			}
		}
		if(se != null) {
			if(j2 == se.a) {
				se.a = 12;
			} else if(j2 == se.b) {
				se.b = 12;
			} else if(j2 == se.c) {
				se.c = 12;
			} else {
				se.d = 12;
			}
		}
		var _this3 = coEdges[j2];
		var y2 = coEdge.p;
		if(_this3 != null) {
			if(_this3.p == edge.q) {
				_this3.p = y2;
			} else {
				_this3.p = y2;
			}
		}
		se = sideEdges[j2];
		if(se != null) {
			if(12 == se.a) {
				se.a = j3;
			} else if(12 == se.b) {
				se.b = j3;
			} else if(12 == se.c) {
				se.c = j3;
			} else {
				se.d = j3;
			}
		}
		if(se != null) {
			if(j1 == se.a) {
				se.a = 12;
			} else if(j1 == se.b) {
				se.b = 12;
			} else if(j1 == se.c) {
				se.c = 12;
			} else {
				se.d = 12;
			}
		}
		var _this4 = coEdges[j3];
		var y3 = coEdge.q;
		if(_this4 != null) {
			if(_this4.p == edge.q) {
				_this4.p = y3;
			} else {
				_this4.p = y3;
			}
		}
		se = sideEdges[j3];
		if(se != null) {
			if(12 == se.a) {
				se.a = j2;
			} else if(12 == se.b) {
				se.b = j2;
			} else if(12 == se.c) {
				se.c = j2;
			} else {
				se.d = j2;
			}
		}
		if(se != null) {
			if(j0 == se.a) {
				se.a = 12;
			} else if(j0 == se.b) {
				se.b = 12;
			} else if(j0 == se.c) {
				se.c = 12;
			} else {
				se.d = 12;
			}
		}
		edges[12] = coEdges[12];
		coEdges[12] = edge;
		var tmp = sideEdges[12].a;
		sideEdges[12].a = sideEdges[12].c;
		sideEdges[12].c = tmp;
		this.drawEdges(edges,shape,this.ctx,true);
		this.ctx.render(thick,false);
	}
	,delaunayTest: function() {
		var shape = this.delaunayShape;
		var vert = shape.vertices;
		var face = shape.faces;
		var edges = shape.edges;
		var face1 = face[0];
		var face2 = face1[0];
		var linkedPoly = new triangulations_DllNode(face2[0]);
		var node = linkedPoly;
		var l = face2.length;
		var _g1 = 1;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			var prevDllNode = node;
			node = new triangulations_DllNode(face2[i]);
			prevDllNode.next = node;
			node.prev = prevDllNode;
		}
		node.next = linkedPoly;
		linkedPoly.prev = node;
		var polies = [linkedPoly];
		var holes = [];
		var l1 = face1.length;
		var _g11 = 1;
		var _g2 = l1;
		while(_g11 < _g2) {
			var k = _g11++;
			var face3 = face1[k];
			var linkedPoly1 = new triangulations_DllNode(face3[0]);
			var node1 = linkedPoly1;
			var l2 = face3.length;
			var _g12 = 1;
			var _g3 = l2;
			while(_g12 < _g3) {
				var i1 = _g12++;
				var prevDllNode1 = node1;
				node1 = new triangulations_DllNode(face3[i1]);
				prevDllNode1.next = node1;
				node1.prev = prevDllNode1;
			}
			node1.next = linkedPoly1;
			linkedPoly1.prev = node1;
			holes.push(linkedPoly1);
		}
		var v = null;
		var this1;
		if(v == null) {
			v = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this1 = v;
		var diagonals = this1;
		while(polies.length > 0) {
			var poly = polies.pop();
			var node2 = poly;
			var a;
			var b;
			var c;
			var convex = false;
			while(true) {
				a = vert[node2.prev.value];
				b = vert[node2.value];
				c = vert[node2.next.value];
				var _this_y;
				var _this_x = b.x - a.x;
				_this_y = b.y - a.y;
				var v_y;
				var v_x = c.x - b.x;
				v_y = c.y - b.y;
				convex = _this_x * v_y - _this_y * v_x < 0;
				node2 = node2.next;
				if(!(!convex && node2 != poly)) {
					break;
				}
			}
			if(!convex) {
				continue;
			}
			var aDllNode = node2.prev.prev;
			var bDllNode = node2.prev;
			var cDllNode = node2;
			var acOK = true;
			var a1 = [a];
			var u_y = [];
			var u_x = [];
			var y = b.y - a1[0].y;
			u_x[0] = b.x - a1[0].x;
			u_y[0] = y;
			var v_y1 = [];
			var v_x1 = [];
			var y1 = c.y - a1[0].y;
			v_x1[0] = c.x - a1[0].x;
			v_y1[0] = y1;
			var vxu = [v_x1[0] * u_y[0] - v_y1[0] * u_x[0]];
			var uxv = [-vxu[0]];
			var inabc = (function(v_y2,v_x2,u_y1,u_x1,uxv1,vxu1,a2) {
				return function(p) {
					var w_y;
					var w_x = p.x - a2[0].x;
					w_y = p.y - a2[0].y;
					var vxw = v_x2[0] * w_y - v_y2[0] * w_x;
					if(vxu1[0] * vxw < 0) {
						return false;
					}
					var uxw = u_x1[0] * w_y - u_y1[0] * w_x;
					if(uxv1[0] * uxw < 0) {
						return false;
					}
					return Math.abs(uxw) + Math.abs(vxw) <= Math.abs(uxv1[0]);
				};
			})(v_y1,v_x1,u_y,u_x,uxv,vxu,a1);
			if(!inabc(vert[aDllNode.prev.value])) {
				acOK = !inabc(vert[cDllNode.next.value]);
			} else {
				acOK = false;
			}
			if(acOK) {
				var nodeBeg = cDllNode.next;
				var nodeEnd = aDllNode.prev;
				var out = false;
				if(nodeEnd == null) {
					var c1 = vert[nodeBeg.value];
					var d = vert[nodeBeg.next.value];
					var acOK1;
					if(c1 != a && c1 != c && d != a && d != c) {
						var out1 = true;
						var u_y2;
						var u_x2 = c.x - a.x;
						u_y2 = c.y - a.y;
						var v_y3;
						var v_x3 = c1.x - a.x;
						v_y3 = c1.y - a.y;
						var v_y4;
						var v_x4 = d.x - a.x;
						v_y4 = d.y - a.y;
						var su = (u_x2 * v_y3 - u_y2 * v_x3) * (u_x2 * v_y4 - u_y2 * v_x4);
						if(su > 0) {
							out1 = false;
						} else {
							var v_y5;
							var v_x5 = d.x - c1.x;
							v_y5 = d.y - c1.y;
							var v_y6;
							var v_x6 = a.x - c1.x;
							v_y6 = a.y - c1.y;
							var v_y7;
							var v_x7 = c.x - c1.x;
							v_y7 = c.y - c1.y;
							var sv = (v_x5 * v_y6 - v_y5 * v_x6) * (v_x5 * v_y7 - v_y5 * v_x7);
							if(sv > 0) {
								out1 = false;
							} else if(su == 0 && sv == 0) {
								var dx = a.x - c.x;
								var dy = a.y - c.y;
								var abLenSq = dx * dx + dy * dy;
								var dx1 = a.x - c1.x;
								var dy1 = a.y - c1.y;
								if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
									var dx2 = a.x - d.x;
									var dy2 = a.y - d.y;
									out1 = dx2 * dx2 + dy2 * dy2 <= abLenSq;
								} else {
									out1 = true;
								}
							}
						}
						acOK1 = out1;
					} else {
						acOK1 = false;
					}
					if(acOK1) {
						out = true;
					} else {
						nodeEnd = nodeBeg;
						nodeBeg = nodeBeg.next;
					}
				}
				if(out != true) {
					var node3 = nodeBeg;
					while(node3 != nodeEnd) {
						var c2 = vert[node3.value];
						var d1 = vert[node3.next.value];
						var acOK2;
						if(c2 != a && c2 != c && d1 != a && d1 != c) {
							var out2 = true;
							var u_y3;
							var u_x3 = c.x - a.x;
							u_y3 = c.y - a.y;
							var v_y8;
							var v_x8 = c2.x - a.x;
							v_y8 = c2.y - a.y;
							var v_y9;
							var v_x9 = d1.x - a.x;
							v_y9 = d1.y - a.y;
							var su1 = (u_x3 * v_y8 - u_y3 * v_x8) * (u_x3 * v_y9 - u_y3 * v_x9);
							if(su1 > 0) {
								out2 = false;
							} else {
								var v_y10;
								var v_x10 = d1.x - c2.x;
								v_y10 = d1.y - c2.y;
								var v_y11;
								var v_x11 = a.x - c2.x;
								v_y11 = a.y - c2.y;
								var v_y12;
								var v_x12 = c.x - c2.x;
								v_y12 = c.y - c2.y;
								var sv1 = (v_x10 * v_y11 - v_y10 * v_x11) * (v_x10 * v_y12 - v_y10 * v_x12);
								if(sv1 > 0) {
									out2 = false;
								} else if(su1 == 0 && sv1 == 0) {
									var dx3 = a.x - c.x;
									var dy3 = a.y - c.y;
									var abLenSq1 = dx3 * dx3 + dy3 * dy3;
									var dx4 = a.x - c2.x;
									var dy4 = a.y - c2.y;
									if(!(dx4 * dx4 + dy4 * dy4 <= abLenSq1)) {
										var dx5 = a.x - d1.x;
										var dy5 = a.y - d1.y;
										out2 = dx5 * dx5 + dy5 * dy5 <= abLenSq1;
									} else {
										out2 = true;
									}
								}
							}
							acOK2 = out2;
						} else {
							acOK2 = false;
						}
						if(acOK2) {
							out = true;
							break;
						} else {
							node3 = node3.next;
						}
					}
				}
				acOK = !out;
			}
			var holesLen = holes.length;
			var _g13 = 0;
			var _g4 = holesLen;
			while(_g13 < _g4) {
				var l3 = _g13++;
				var nodeBeg1 = holes[l3];
				var nodeEnd1 = null;
				var out3 = false;
				if(nodeEnd1 == null) {
					var c3 = vert[nodeBeg1.value];
					var d2 = vert[nodeBeg1.next.value];
					var acOK3;
					if(c3 != a && c3 != c && d2 != a && d2 != c) {
						var out4 = true;
						var u_y4;
						var u_x4 = c.x - a.x;
						u_y4 = c.y - a.y;
						var v_y13;
						var v_x13 = c3.x - a.x;
						v_y13 = c3.y - a.y;
						var v_y14;
						var v_x14 = d2.x - a.x;
						v_y14 = d2.y - a.y;
						var su2 = (u_x4 * v_y13 - u_y4 * v_x13) * (u_x4 * v_y14 - u_y4 * v_x14);
						if(su2 > 0) {
							out4 = false;
						} else {
							var v_y15;
							var v_x15 = d2.x - c3.x;
							v_y15 = d2.y - c3.y;
							var v_y16;
							var v_x16 = a.x - c3.x;
							v_y16 = a.y - c3.y;
							var v_y17;
							var v_x17 = c.x - c3.x;
							v_y17 = c.y - c3.y;
							var sv2 = (v_x15 * v_y16 - v_y15 * v_x16) * (v_x15 * v_y17 - v_y15 * v_x17);
							if(sv2 > 0) {
								out4 = false;
							} else if(su2 == 0 && sv2 == 0) {
								var dx6 = a.x - c.x;
								var dy6 = a.y - c.y;
								var abLenSq2 = dx6 * dx6 + dy6 * dy6;
								var dx7 = a.x - c3.x;
								var dy7 = a.y - c3.y;
								if(!(dx7 * dx7 + dy7 * dy7 <= abLenSq2)) {
									var dx8 = a.x - d2.x;
									var dy8 = a.y - d2.y;
									out4 = dx8 * dx8 + dy8 * dy8 <= abLenSq2;
								} else {
									out4 = true;
								}
							}
						}
						acOK3 = out4;
					} else {
						acOK3 = false;
					}
					if(acOK3) {
						out3 = true;
					} else {
						nodeEnd1 = nodeBeg1;
						nodeBeg1 = nodeBeg1.next;
					}
				}
				if(out3 != true) {
					var node4 = nodeBeg1;
					while(node4 != nodeEnd1) {
						var c4 = vert[node4.value];
						var d3 = vert[node4.next.value];
						var acOK4;
						if(c4 != a && c4 != c && d3 != a && d3 != c) {
							var out5 = true;
							var u_y5;
							var u_x5 = c.x - a.x;
							u_y5 = c.y - a.y;
							var v_y18;
							var v_x18 = c4.x - a.x;
							v_y18 = c4.y - a.y;
							var v_y19;
							var v_x19 = d3.x - a.x;
							v_y19 = d3.y - a.y;
							var su3 = (u_x5 * v_y18 - u_y5 * v_x18) * (u_x5 * v_y19 - u_y5 * v_x19);
							if(su3 > 0) {
								out5 = false;
							} else {
								var v_y20;
								var v_x20 = d3.x - c4.x;
								v_y20 = d3.y - c4.y;
								var v_y21;
								var v_x21 = a.x - c4.x;
								v_y21 = a.y - c4.y;
								var v_y22;
								var v_x22 = c.x - c4.x;
								v_y22 = c.y - c4.y;
								var sv3 = (v_x20 * v_y21 - v_y20 * v_x21) * (v_x20 * v_y22 - v_y20 * v_x22);
								if(sv3 > 0) {
									out5 = false;
								} else if(su3 == 0 && sv3 == 0) {
									var dx9 = a.x - c.x;
									var dy9 = a.y - c.y;
									var abLenSq3 = dx9 * dx9 + dy9 * dy9;
									var dx10 = a.x - c4.x;
									var dy10 = a.y - c4.y;
									if(!(dx10 * dx10 + dy10 * dy10 <= abLenSq3)) {
										var dx11 = a.x - d3.x;
										var dy11 = a.y - d3.y;
										out5 = dx11 * dx11 + dy11 * dy11 <= abLenSq3;
									} else {
										out5 = true;
									}
								}
							}
							acOK4 = out5;
						} else {
							acOK4 = false;
						}
						if(acOK4) {
							out3 = true;
							break;
						} else {
							node4 = node4.next;
						}
					}
				}
				acOK = !out3;
				if(!acOK) {
					break;
				}
			}
			var split;
			var fromDllNode;
			var toDllNode;
			if(acOK) {
				fromDllNode = cDllNode;
				toDllNode = aDllNode;
				split = true;
			} else {
				var a3 = [a];
				var b1 = [b];
				var c5 = [c];
				var a4 = [a3[0]];
				var u_y6 = [];
				var u_x6 = [];
				var y2 = b1[0].y - a4[0].y;
				u_x6[0] = b1[0].x - a4[0].x;
				u_y6[0] = y2;
				var v_y23 = [];
				var v_x23 = [];
				var y3 = c5[0].y - a4[0].y;
				v_x23[0] = c5[0].x - a4[0].x;
				v_y23[0] = y3;
				var vxu2 = [v_x23[0] * u_y6[0] - v_y23[0] * u_x6[0]];
				var uxv2 = [-vxu2[0]];
				var inabc1 = [(function(v_y24,v_x24,u_y7,u_x7,uxv3,vxu3,a5) {
					return function(p1) {
						var w_y1;
						var w_x1 = p1.x - a5[0].x;
						w_y1 = p1.y - a5[0].y;
						var vxw1 = v_x24[0] * w_y1 - v_y24[0] * w_x1;
						if(vxu3[0] * vxw1 < 0) {
							return false;
						}
						var uxw1 = u_x7[0] * w_y1 - u_y7[0] * w_x1;
						if(uxv3[0] * uxw1 < 0) {
							return false;
						}
						return Math.abs(uxw1) + Math.abs(vxw1) <= Math.abs(uxv3[0]);
					};
				})(v_y23,v_x23,u_y6,u_x6,uxv2,vxu2,a4)];
				var u = [a3[0]];
				var uv_y = [];
				var uv_x = [];
				var y4 = c5[0].y - u[0].y;
				uv_x[0] = c5[0].x - u[0].x;
				uv_y[0] = y4;
				var uvLenSq = [uv_x[0] * uv_x[0] + uv_y[0] * uv_y[0]];
				var acDistSq = [(function(uv_y1,uv_x1,uvLenSq1,u1) {
					return function(p2) {
						var v_y25;
						var v_x25 = u1[0].x - p2.x;
						v_y25 = u1[0].y - p2.y;
						var uvxpu = uv_x1[0] * v_y25 - uv_y1[0] * v_x25;
						return uvxpu * uvxpu / uvLenSq1[0];
					};
				})(uv_y,uv_x,uvLenSq,u)];
				var findBest = (function(acDistSq1,inabc2,c6,b2,a6) {
					return function(vertices,nodeBeg2,nodeEnd2,bestDllNode) {
						var v1;
						var maxDepthSq;
						if(bestDllNode != null) {
							v1 = bestDllNode.value;
							maxDepthSq = acDistSq1[0](vertices[v1]);
						} else {
							maxDepthSq = -1;
						}
						var node5 = nodeBeg2;
						while(true) {
							var v2 = vertices[node5.value];
							if(v2 != a6[0] && v2 != b2[0] && v2 != c6[0] && inabc2[0](v2)) {
								var depthSq = acDistSq1[0](v2);
								if(depthSq > maxDepthSq) {
									maxDepthSq = depthSq;
									bestDllNode = node5;
								}
							}
							node5 = node5.next;
							if(!(node5 != nodeEnd2)) {
								break;
							}
						}
						return bestDllNode;
					};
				})(acDistSq,inabc1,c5,b1,a3);
				var best = cDllNode.next != aDllNode ? findBest(vert,cDllNode.next,aDllNode) : null;
				var lHole = -1;
				var holesLen1 = holes.length;
				var _g14 = 0;
				var _g5 = holesLen1;
				while(_g14 < _g5) {
					var l4 = _g14++;
					var newBest = findBest(vert,holes[l4],holes[l4],best);
					if(newBest != best) {
						lHole = l4;
					}
					best = newBest;
				}
				fromDllNode = bDllNode;
				toDllNode = best;
				if(lHole < 0) {
					split = true;
				} else {
					holes.splice(lHole,1);
					split = false;
				}
			}
			if(toDllNode == null) {
				continue;
			}
			diagonals.push(new triangulations_Edge(fromDllNode.value,toDllNode.value));
			var poly1 = new triangulations_DllNode(fromDllNode.value);
			poly1.next = fromDllNode.next;
			var tempDllNode = new triangulations_DllNode(toDllNode.value);
			tempDllNode.prev = toDllNode.prev;
			tempDllNode.next = poly1;
			poly1.prev = tempDllNode;
			fromDllNode.next.prev = poly1;
			toDllNode.prev.next = poly1.prev;
			fromDllNode.next = toDllNode;
			toDllNode.prev = fromDllNode;
			var poly2 = fromDllNode;
			if(split) {
				polies.push(poly1);
				polies.push(poly2);
			} else {
				polies.push(poly2);
			}
		}
		var diags = diagonals;
		console.log("diags " + triangulations__$Edges_Edges_$Impl_$.toString(diags));
		var v3 = null;
		var this2;
		if(v3 == null) {
			v3 = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this2 = v3;
		var e = this2;
		var l5 = edges.length;
		var tempIn;
		var tempOut;
		var _g15 = 0;
		var _g6 = l5;
		while(_g15 < _g6) {
			var i2 = _g15++;
			var _this = edges[i2];
			var e1 = new triangulations_Edge(_this.p,_this.q);
			e1.fixed = _this.fixed;
			e1.external = _this.external;
			e[i2] = e1;
		}
		var this3 = e;
		var l6 = this3.length;
		var el = diags.length;
		var _g16 = 0;
		var _g7 = el;
		while(_g16 < _g7) {
			var i3 = _g16++;
			this3[l6 + i3] = diags[i3];
		}
		var all = this3;
		var v4 = null;
		var this4;
		if(v4 == null) {
			v4 = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this4 = v4;
		var coEdges = this4;
		var sideEdges = [];
		triangulations_Triangulate.makeQuadEdge(vert,all,coEdges,sideEdges);
		var unsureEdges = [];
		var l7 = all.length;
		var lu = 0;
		var _g17 = 0;
		var _g8 = l7;
		while(_g17 < _g8) {
			var j = _g17++;
			if(!all[j].fixed) {
				unsureEdges[lu] = j;
				++lu;
			}
		}
		var unsureEdges1 = unsureEdges;
		console.log("unsureEdges " + Std.string(unsureEdges1));
		(triangulations_Triangulate.get_delaunay())(vert,all,coEdges,sideEdges,unsureEdges1);
		console.log("all " + triangulations__$Edges_Edges_$Impl_$.toString(all));
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		var thick = 4;
		this.ctx.setThickness(4);
		this.ctx.setColor(4,0);
		this.ctx.fill = false;
		var _g18 = edges.length;
		var _g9 = all.length;
		while(_g18 < _g9) {
			var j1 = _g18++;
			var edge = all[j1];
			var coEdge = coEdges[j1];
			var w = vert[edge.p];
			var y5 = vert[edge.q];
			var x = vert[coEdge.p];
			var z = vert[coEdge.q];
			var p_y;
			var p_x;
			var xa = w.x;
			var ya = w.y;
			var xb = y5.x;
			var yb = y5.y;
			var xc = x.x;
			var yc = x.y;
			var d4 = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
			var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
			var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
			var xp = ka * (yb - yc) - kb * (ya - yc);
			var yp = kb * (xa - xc) - ka * (xb - xc);
			p_x = xp / d4;
			p_y = yp / d4;
			var dx12 = w.x - p_x;
			var dy12 = w.y - p_y;
			var r = Math.sqrt(dx12 * dx12 + dy12 * dy12);
			this.ctx.regularPoly(60,p_x,p_y,r,0);
		}
		this.ctx.fill = false;
		this.ctx.setColor(0,3);
		this.ctx.moveTo(0,0);
		this.drawEdges(all,shape,this.ctx,true);
		this.ctx.setColor(1,3);
		this.ctx.moveTo(0,0);
		this.drawEdges(edges,shape,this.ctx,true);
		this.ctx.render(thick,false);
	}
	,bananaTest: function() {
		var thick = 4;
		this.ctx = new justTriangles_PathContext(1,1024,0,0);
		this.ctx.setThickness(4);
		this.ctx.setColor(0,3);
		this.ctx.fill = true;
		this.ctx.lineType = justTriangles_LineType.TriangleJoinCurve;
		this.drawVertices(this.banana,this.ctx,false);
		this.ctx.setColor(0);
		this.ctx.fill = true;
		this.ctx.lineType = justTriangles_LineType.TriangleJoinCurve;
		this.drawVerticesPoints(this.banana,this.ctx,-1,1,5);
		this.ctx.render(thick,false);
	}
	,transform: function(x,y) {
		var _this = this.ctx;
		var x0 = _this.s * (x - _this.dw + _this.tx);
		var y0 = _this.s * (y - _this.dw + _this.ty);
		if(x0 < _this.minX) {
			_this.minX = x0;
		}
		if(x0 < _this.minY) {
			_this.minY = y0;
		}
		if(x0 > _this.maxX) {
			_this.maxX = x0;
		}
		if(y0 > _this.maxY) {
			_this.maxY = y0;
		}
		return { x : x0, y : y0};
	}
	,drawFaces: function(fillShape,ctx_,showPoints) {
		if(showPoints == null) {
			showPoints = true;
		}
		var faces = fillShape.faces;
		var somefaces;
		var face;
		var _g1 = 0;
		var _g = faces.length;
		while(_g1 < _g) {
			var j = _g1++;
			somefaces = faces[j];
			var _g3 = 0;
			var _g2 = somefaces.length;
			while(_g3 < _g2) {
				var k = _g3++;
				face = somefaces[k];
				var _g5 = 0;
				var _g4 = face.length;
				while(_g5 < _g4) {
					var i = _g5++;
					this.drawFace(face,fillShape,ctx_,showPoints);
				}
			}
		}
	}
	,drawFace: function(face,fillShape,ctx_,showPoints) {
		if(showPoints == null) {
			showPoints = true;
		}
		var verts = fillShape.vertices;
		var l = face.length;
		var f0 = face[0];
		var v0 = verts[f0];
		var f;
		ctx_.moveTo(v0.x,v0.y);
		if(showPoints) {
			ctx_.regularPoly(20,v0.x,v0.y,5,0);
			ctx_.moveTo(v0.x,v0.y);
		}
		var v;
		var _g1 = 1;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			f = face[i];
			v = verts[f];
			ctx_.lineTo(v.x,v.y);
			if(showPoints) {
				ctx_.regularPoly(20,v.x,v.y,5,0);
				ctx_.moveTo(v.x,v.y);
			}
		}
		ctx_.lineTo(v0.x,v0.y);
	}
	,drawEdges: function(edges,fillShape,ctx,showPoints) {
		if(showPoints == null) {
			showPoints = true;
		}
		var verts = fillShape.vertices;
		var l = edges.length;
		var e;
		var v;
		var p;
		var q;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			e = edges[i];
			if(e.p == null && e.q == null) {
				continue;
			}
			p = e.p;
			q = e.q;
			v = verts[p];
			if(v == null) {
				continue;
			}
			ctx.moveTo(v.x,v.y);
			if(showPoints) {
				ctx.regularPoly(20,v.x,v.y,5,0);
				ctx.moveTo(v.x,v.y);
			}
			v = verts[q];
			if(v == null) {
				continue;
			}
			ctx.lineTo(v.x,v.y);
			if(showPoints) {
				ctx.regularPoly(20,v.x,v.y,5,0);
				ctx.moveTo(v.x,v.y);
			}
		}
	}
	,drawVerticesPoints: function(fillShape,ctx,specialPoint,specialColor,normalColor) {
		if(specialPoint == null) {
			specialPoint = -1;
		}
		this.verts = fillShape.vertices;
		var v;
		var v0 = this.verts[0];
		if(specialPoint == 0) {
			ctx.setColor(specialColor,specialColor);
			ctx.regularPoly(20,v0.x,v0.y,5,0);
			ctx.moveTo(v0.x,v0.y);
		} else {
			ctx.setColor(normalColor,normalColor);
			ctx.regularPoly(20,v0.x,v0.y,5,0);
			ctx.moveTo(v0.x,v0.y);
		}
		var l = this.verts.length;
		var _g1 = 1;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			v = this.verts[i];
			if(specialPoint == i) {
				ctx.setColor(specialColor,specialColor);
				ctx.regularPoly(20,v.x,v.y,5,0);
				ctx.moveTo(v.x,v.y);
			} else {
				ctx.setColor(normalColor,normalColor);
				ctx.regularPoly(20,v.x,v.y,5,0);
				ctx.moveTo(v.x,v.y);
			}
		}
	}
	,drawVertices: function(fillShape,ctx,showPoints) {
		if(showPoints == null) {
			showPoints = true;
		}
		this.verts = fillShape.vertices;
		var v0 = this.verts[0];
		var v;
		ctx.moveTo(v0.x,v0.y);
		if(showPoints) {
			ctx.regularPoly(20,v0.x,v0.y,5,0);
			ctx.moveTo(v0.x,v0.y);
		}
		var l = this.verts.length;
		var _g1 = 1;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			v = this.verts[i];
			ctx.lineTo(v.x,v.y);
			if(showPoints) {
				ctx.regularPoly(20,v.x,v.y,5,0);
				ctx.moveTo(v.x,v.y);
			}
		}
		ctx.lineTo(v0.x,v0.y);
	}
	,__class__: tests_MainTestSetup
};
var tests_fillShapes__$Banana_Banana_$Impl_$ = {};
tests_fillShapes__$Banana_Banana_$Impl_$.__name__ = true;
tests_fillShapes__$Banana_Banana_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[132.84375,99.5],[115.71875,183.78125],[45.71875,258.0625],[34.28125,372.375],[60.0,496.65625],[148.5625,612.375],[308.5625,653.78125],[432.84375,613.78125],[505.71875,525.21875],[480.0,489.5],[315.71875,459.5],[251.4375,410.9375],[241.4375,312.375],[215.71875,225.21875],[177.15625,189.5],[222.84375,123.78125]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,0]]);
	var face = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$Guitar_Guitar_$Impl_$ = {};
tests_fillShapes__$Guitar_Guitar_$Impl_$.__name__ = true;
tests_fillShapes__$Guitar_Guitar_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[217.8169,58.882041],[155.3191,60.502642],[110.5,91.90625],[54.46875,170.28125],[31.481076,274.72886],[35.4397,394.60211],[80.71875,467.6875],[143.40625,501.375],[209.625,498.25],[275.46875,474.75],[341.28125,438.3125],[407.5,422.21875],[484.64128,446.81954],[531.3706,452.99032],[563.84375,441.8125],[523.1787,416.13293],[478.43750000000006,369.34375],[483.92562000000004,320.25704],[539.5625,307.8125],[902.78125,307.8125],[969.0,328.1875],[995.25,348.96875],[1100.6562,336.03125],[1135.3072,349.75],[1176.6875,336.4375],[1199.7812,319.5625],[1203.3125,293.3125],[1137.875,267.0625],[1146.9062,251.78125],[1146.9062,242.0],[1140.625,239.25],[1133.1875,246.3125],[1130.0312,263.9375],[1111.25,256.09375],[1120.6562,241.21875],[1120.6562,231.40625],[1114.375,229.0625],[1107.7188,235.34375],[1104.1875,253.75],[1085.0,246.3125],[1094.7812,231.03125],[1094.0,221.21875],[1087.7188,218.875],[1079.9062000000001,224.34375],[1077.9375000000002,243.5625],[1057.9375000000002,234.9375],[1068.1250000000002,220.0625],[1067.7500000000002,210.65625],[1061.4688000000003,207.5],[1054.4375000000002,213.78125],[1051.6875000000002,232.96875],[1031.6875000000002,224.75],[1041.5000000000002,209.46875],[1041.8750000000002,199.6875],[1035.2188000000003,197.3125],[1027.3750000000002,204.375],[1024.2500000000002,221.625],[1005.4375000000002,213.78125],[1014.8438000000002,199.28125],[1015.2500000000002,189.09375],[1008.1875000000002,186.75],[1001.5312000000002,193.0],[998.3750000000002,211.03125],[956.0625000000002,194.1875],[942.7500000000002,196.9375],[939.2187500000002,243.5625],[605.7812500000002,243.9375],[572.8750000000002,240.8125],[534.4687500000002,204.375],[560.8635600000002,156.81206],[625.9934000000003,124.02377],[696.2812500000003,104.84375],[672.0,88.40625],[616.02112,82.925617],[540.34375,105.25],[473.71875,138.15625],[407.5,154.625],[342.0625,132.28125],[282.12543,89.292248],[218.0625,243.375],[234.125,259.4375],[250.0,243.5625],[275.0625,243.5625],[275.0625,309.78125],[250.78125,309.78125],[250.78125,293.3125],[234.125,309.96875],[217.84375,293.71875],[217.84375,310.15625],[193.1875,310.15625],[193.1875,243.5625],[368.625,243.5625],[368.625,283.75],[358.125,301.9375],[335.03125,309.78125],[312.34375,300.90625],[302.09375,283.125],[302.09375,243.9375],[143.40625,243.9375],[166.125,253.34375],[143.40625,276.875],[166.53125,299.96875],[143.40625,310.15625],[120.6875,299.59375],[110.875,276.46875],[120.6875,253.75]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,24],[24,25],[25,26],[26,27],[27,28],[28,29],[29,30],[30,31],[31,32],[32,33],[33,34],[34,35],[35,36],[36,37],[37,38],[38,39],[39,40],[40,41],[41,42],[42,43],[43,44],[44,45],[45,46],[46,47],[47,48],[48,49],[49,50],[50,51],[51,52],[52,53],[53,54],[54,55],[55,56],[56,57],[57,58],[58,59],[59,60],[60,61],[61,62],[62,63],[63,64],[64,65],[65,66],[66,67],[67,68],[68,69],[69,70],[70,71],[71,72],[72,73],[73,74],[74,75],[75,76],[76,77],[77,78],[78,0],[79,80],[80,81],[81,82],[82,83],[83,84],[84,85],[85,86],[86,87],[87,88],[88,89],[89,90],[90,79],[91,92],[92,93],[93,94],[94,95],[95,96],[96,97],[97,91],[98,99],[99,100],[100,101],[101,102],[102,103],[103,104],[104,105],[105,98]]);
	var face0 = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78];
	var face1 = [79,80,81,82,83,84,85,86,87,88,89,90];
	var face2 = [91,92,93,94,95,96,97];
	var face3 = [98,99,100,101,102,103,104,105];
	this1.faces = [[face0,face1,face2,face3]];
	return this1;
};
var tests_fillShapes__$Key_Key_$Impl_$ = {};
tests_fillShapes__$Key_Key_$Impl_$.__name__ = true;
tests_fillShapes__$Key_Key_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[120.0,43.78125],[63.9375,55.21875],[53.5625,115.9375],[37.15625,120.5625],[20.71875,137.0],[9.65625,159.15625],[20.71875,181.65625],[36.78125,198.0625],[54.28125,203.0625],[65.0,264.15625],[118.5625,274.875],[174.28125,264.15625],[191.0625,197.71875],[488.9375,197.71875],[498.9375,187.71875],[498.9375,169.875],[515.59375,160.25],[506.9375,145.28125],[493.25,131.59375],[483.03125,141.8125],[476.4375,141.8125],[460.96875,126.375],[449.65625,126.375],[444.5,131.5],[432.84375,131.5],[427.9375,126.59375],[421.4375,126.59375],[411.03125,136.96875],[405.34375,136.96875],[394.84375,126.4375],[388.21875,126.4375],[383.65625,131.0],[373.5625,131.0],[368.53125,125.96875],[361.78125,125.96875],[345.5625,142.21875],[333.5625,142.21875],[328.84375,137.46875],[322.84375,137.46875],[312.0,148.3125],[301.78125,148.3125],[279.71875,126.21875],[268.9375,126.21875],[258.25,115.53125],[191.4375,115.53125],[175.03125,54.3125],[53.5625,137.71875],[70.34375,143.0625],[75.71875,159.15625],[69.65625,175.5625],[53.21875,180.9375],[37.5,175.9375],[31.0625,159.5],[37.5,142.71875]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,24],[24,25],[25,26],[26,27],[27,28],[28,29],[29,30],[30,31],[31,32],[32,33],[33,34],[34,35],[35,36],[36,37],[37,38],[38,39],[39,40],[40,41],[41,42],[42,43],[43,44],[44,45],[45,0],[46,47],[47,48],[48,49],[49,50],[50,51],[51,52],[52,53],[53,46]]);
	var face0 = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45];
	var face1 = [46,47,48,49,50,51,52,53];
	this1.faces = [[face0,face1]];
	return this1;
};
var tests_fillShapes__$Sheet_Sheet_$Impl_$ = {};
tests_fillShapes__$Sheet_Sheet_$Impl_$.__name__ = true;
tests_fillShapes__$Sheet_Sheet_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[78.791898,339.19449],[640.43671,339.19449],[640.43671,352.32647],[640.43671,367.47875999999997],[640.43671,383.64119999999997],[640.43671,400.81379],[640.43671,415.46099999999996],[640.43671,432.12852],[640.43671,446.27065999999996],[640.43671,462.43309999999997],[640.43671,477.08030999999994],[640.43671,491.22243999999995],[640.43671,505.86965999999995],[640.43671,520.0117899999999],[640.43671,534.6589999999999],[640.43671,547.7909899999999],[640.43671,557.8925099999999],[78.79189899999994,557.8925099999999]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,0]]);
	var face = [17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$TestAngleCompareShape_TestAngleCompareShape_$Impl_$ = {};
tests_fillShapes__$TestAngleCompareShape_TestAngleCompareShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestAngleCompareShape_TestAngleCompareShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[200.,200.],[100.,300.],[300.,200.],[200.,100.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[0,2],[0,3]]);
	var face = [];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$TestDelaunayShape_TestDelaunayShape_$Impl_$ = {};
tests_fillShapes__$TestDelaunayShape_TestDelaunayShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestDelaunayShape_TestDelaunayShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
	var face0 = [0,1,2,3,4,5,6,7,8];
	var face1 = [9,10,11];
	this1.faces = [[face0,face1]];
	return this1;
};
var tests_fillShapes__$TestEdgeIntersectShape_TestEdgeIntersectShape_$Impl_$ = {};
tests_fillShapes__$TestEdgeIntersectShape_TestEdgeIntersectShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestEdgeIntersectShape_TestEdgeIntersectShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[10.,10.],[100.,100.],[100.,10.],[10.,100.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[2,3]]);
	var face = [];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$TestEnclosingTriangleShape_TestEnclosingTriangleShape_$Impl_$ = {};
tests_fillShapes__$TestEnclosingTriangleShape_TestEnclosingTriangleShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestEnclosingTriangleShape_TestEnclosingTriangleShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
	var face0 = [0,1,2,3,4,5,6,7,8];
	var face1 = [9,10,11];
	this1.faces = [[face0,face1]];
	return this1;
};
var tests_fillShapes__$TestGraphShape_TestGraphShape_$Impl_$ = {};
tests_fillShapes__$TestGraphShape_TestGraphShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestGraphShape_TestGraphShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[50.,100.],[150.,50.],[150.,150.],[250.,50.],[250.,150.],[350.,100.],[450.,50.],[350.,150.],[350.,250.],[250.,250.],[150.,250.],[150.,350.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[0,2],[1,2],[3,4],[3,5],[4,5],[4,7],[4,9],[5,6],[7,8],[8,9],[10,11]]);
	var face = [];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$TestPointInPolyShape_TestPointInPolyShape_$Impl_$ = {};
tests_fillShapes__$TestPointInPolyShape_TestPointInPolyShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestPointInPolyShape_TestPointInPolyShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[500.,300.],[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[]]);
	var face = [1,2,3,4,5,6,7,8,9];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$TestPointInTriangleShape_TestPointInTriangleShape_$Impl_$ = {};
tests_fillShapes__$TestPointInTriangleShape_TestPointInTriangleShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestPointInTriangleShape_TestPointInTriangleShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[200.,200.],[100.,100.],[300.,200.],[200.,300.],[0.,0.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[]]);
	var face = [3,2,1];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$TestQuadEdgeShape_TestQuadEdgeShape_$Impl_$ = {};
tests_fillShapes__$TestQuadEdgeShape_TestQuadEdgeShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestQuadEdgeShape_TestQuadEdgeShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,100.],[200.,100.],[200.,200.],[100.,200.],[50.,150.],[150.,50.],[250.,150.],[150.,250.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,0],[0,5],[5,1],[1,6],[6,2],[2,7],[7,3],[3,4],[4,0],[0,2]]);
	var face = [];
	this1.faces = [[face]];
	return this1;
};
var tests_fillShapes__$TestSplitShape_TestSplitShape_$Impl_$ = {};
tests_fillShapes__$TestSplitShape_TestSplitShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestSplitShape_TestSplitShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
	var face0 = [0,1,2,3,4,5,6,7,8];
	var face1 = [9,10,11];
	this1.faces = [[face0,face1]];
	return this1;
};
var tests_fillShapes__$TestTriangulateShape_TestTriangulateShape_$Impl_$ = {};
tests_fillShapes__$TestTriangulateShape_TestTriangulateShape_$Impl_$.__name__ = true;
tests_fillShapes__$TestTriangulateShape_TestTriangulateShape_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[100.,200.],[100.,300.],[300.,400.],[300.,300.],[400.,200.],[300.,200.],[300.,100.],[200.,200.],[200.,100.],[150.,200.],[250.,300.],[150.,300.]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,0],[9,10],[10,11],[11,9]]);
	var face0 = [0,1,2,3,4,5,6,7,8];
	var face1 = [9,10,11];
	this1.faces = [[face0,face1]];
	return this1;
};
var tests_fillShapes__$Ty_Ty_$Impl_$ = {};
tests_fillShapes__$Ty_Ty_$Impl_$.__name__ = true;
tests_fillShapes__$Ty_Ty_$Impl_$._new = function() {
	var this1 = new triangulations_FillShape();
	this1.vertices = triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray([[173.9375,349.15625],[169.78125,349.6875],[169.375,352.75],[171.5625,354.125],[171.5625,373.625],[169.375,375.0],[169.78125,378.0625],[178.96875,378.0625],[179.375,375.0],[177.1875,373.625],[177.1875,363.34375],[180.71875,362.0625],[183.25,362.84375],[183.96875,365.71875],[183.96875,373.625],[181.78125,375.0],[182.1875,378.0625],[191.375,378.0625],[191.78125,375.0],[189.5625,373.625],[189.5625,365.53125],[188.0625,359.6875],[182.5625,357.75],[179.71875,358.1875],[177.1875,359.28125],[177.1875,349.28125],[241.59375,349.15625],[237.4375,349.6875],[237.03125,352.75],[239.21875,354.125],[239.21875,373.625],[237.03125,375.0],[237.4375,378.0625],[246.625,378.0625],[247.03125,375.0],[244.84375,373.625],[244.84375,349.28125],[146.09375,350.53125],[146.09375,356.25],[148.59375,356.5625],[149.59375,354.875],[154.40625,354.875],[154.40625,373.4375],[152.21875,374.75],[152.59375,378.0625],[161.96875,378.0625],[162.375,374.75],[160.15625,373.4375],[160.15625,354.875],[164.96875,354.875],[165.96875,356.5625],[168.5,356.25],[168.5,350.53125],[218.03125,357.59375],[214.09375,358.0625],[213.6875,361.15625],[215.875,362.53125],[215.875,373.625],[213.6875,375.0],[214.09375,378.0625],[223.28125,378.0625],[223.6875,375.0],[221.46875,373.625],[221.46875,363.34375],[225.09375,362.0625],[227.5625,362.84375],[228.28125,365.71875],[228.28125,373.625],[226.09375,375.0],[226.46875,378.0625],[235.6875,378.0625],[236.09375,375.0],[233.875,373.625],[233.875,365.96875],[232.28125,359.59375],[226.8125,357.75],[223.59375,358.3125],[220.96875,359.6875],[220.96875,357.6875],[202.0625,357.75],[194.0625,359.75],[194.0,361.03125],[194.6875,364.625],[198.625,364.625],[199.09375,362.03125],[201.125,361.78125],[204.4375,364.90625],[204.4375,366.84375],[200.09375,366.84375],[194.78125,368.40625],[193.0,372.59375],[194.90625,376.84375],[199.5,378.40625],[205.71875,375.875],[206.40625,378.40625],[212.25,377.4375],[212.25,373.96875],[210.0625,373.28125],[210.0625,364.75],[208.1875,359.40625],[249.03125,358.0625],[248.625,361.15625],[249.59375,362.0],[245.1875,367.71875],[252.28125,378.0625],[258.65625,378.0625],[259.0625,375.0],[255.59375,373.28125],[251.0625,367.3125],[254.90625,362.90625],[258.21875,361.15625],[257.84375,358.0625],[201.65625,369.84375],[204.4375,369.84375],[204.4375,373.125],[201.21875,374.3125],[199.375,373.6875],[198.78125,372.03125],[169.71875,380.875],[169.34375,384.0],[171.90625,385.5],[178.4375,399.0625],[178.4375,403.65625],[176.21875,404.96875],[176.625,408.28125],[186.0,408.28125],[186.375,404.96875],[184.1875,403.65625],[184.1875,399.0625],[190.5,385.53125],[193.15625,384.0],[192.75,380.6875],[183.625,380.6875],[183.21875,384.0],[185.375,385.375],[184.09375,388.28125],[181.90625,394.34375],[181.3125,394.34375],[181.03125,393.53125],[179.03125,388.28125],[177.65625,385.21875],[179.5,384.0],[179.09375,380.6875],[216.84375,387.96875],[212.6875,388.46875],[212.3125,391.5625],[214.5,392.90625],[214.5,402.15625],[215.96875,407.25],[221.1875,408.78125],[227.6875,406.78125],[228.78125,408.78125],[234.8125,407.53125],[234.8125,404.34375],[232.625,403.6875],[232.625,388.0625],[229.375,387.9688],[225.21875,388.4688],[224.8125,391.56255],[227.03125,392.9063],[227.03125,403.12505],[223.375,404.4063],[220.75,403.7188],[220.09375,400.8438],[220.09375,388.06255],[201.5625,388.15625],[194.25,390.875],[191.71875,398.6875],[194.0,406.28125],[201.0,408.78125],[208.3125,406.0],[210.9375,398.0625],[208.59375,390.5625],[201.25,392.25],[205.15625,398.46875],[204.21875,403.28125],[201.3125,404.71875],[197.5,398.3125],[198.40625,393.625]]);
	this1.edges = triangulations__$Edges_Edges_$Impl_$.fromArrayArray([[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,24],[24,25],[25,0],[26,27],[27,28],[28,29],[29,30],[30,31],[31,32],[32,33],[33,34],[34,35],[35,36],[36,26],[37,38],[38,39],[39,40],[40,41],[41,42],[42,43],[43,44],[44,45],[45,46],[46,47],[47,48],[48,49],[49,50],[50,51],[51,52],[52,37],[53,54],[54,55],[55,56],[56,57],[57,58],[58,59],[59,60],[60,61],[61,62],[62,63],[63,64],[64,65],[65,66],[66,67],[67,68],[68,69],[69,70],[70,71],[71,72],[72,73],[73,74],[74,75],[75,76],[76,77],[77,78],[78,53],[79,80],[80,81],[81,82],[82,83],[83,84],[84,85],[85,86],[86,87],[87,88],[88,89],[89,90],[90,91],[91,92],[92,93],[93,94],[94,95],[95,96],[96,97],[97,98],[98,99],[99,79],[100,101],[101,102],[102,103],[103,104],[104,105],[105,106],[106,107],[107,108],[108,109],[109,110],[110,111],[111,100],[112,113],[113,114],[114,115],[115,116],[116,117],[117,112],[118,119],[119,120],[120,121],[121,122],[122,123],[123,124],[124,125],[125,126],[126,127],[127,128],[128,129],[129,130],[130,131],[131,132],[132,133],[133,134],[134,135],[135,136],[136,137],[137,138],[138,139],[139,140],[140,141],[141,142],[142,118],[143,144],[144,145],[145,146],[146,147],[147,148],[148,149],[149,150],[150,151],[151,152],[152,153],[153,154],[154,155],[155,156],[156,157],[157,158],[158,159],[159,160],[160,161],[161,162],[162,163],[163,164],[164,143],[165,166],[166,167],[167,168],[168,169],[169,170],[170,171],[171,172],[172,165],[173,174],[174,175],[175,176],[176,177],[177,178],[178,173]]);
	var face_h = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
	var face_k0 = [26,27,28,29,30,31,32,33,34,35,36];
	var face_k1 = [100,101,102,103,104,105,106,107,108,109,110,111];
	var face_T = [37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52];
	var face_n = [53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78];
	var face_a0 = [79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99];
	var face_a1 = [112,113,114,115,116,117];
	var face_Y = [118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142];
	var face_u = [143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164];
	var face_o0 = [165,166,167,168,169,170,171,172];
	var face_o1 = [173,174,175,176,177,178];
	this1.faces = [[face_h],[face_k0,face_k1],[face_T],[face_n],[face_a0,face_a1],[face_Y],[face_u],[face_o0,face_o1]];
	return this1;
};
var triangulations_DllNode = function(value_) {
	this.value = value_;
};
triangulations_DllNode.__name__ = true;
triangulations_DllNode.prototype = {
	toString: function() {
		var p = this.prev.value;
		var n = this.next.value;
		return "" + Std.string(p) + " -> " + Std.string(this.value) + " -> " + Std.string(n);
	}
	,__class__: triangulations_DllNode
};
var triangulations_Edge = function(p_,q_) {
	this.external = false;
	this.fixed = false;
	this.q = null;
	this.p = null;
	this.p = p_;
	this.q = q_;
};
triangulations_Edge.__name__ = true;
triangulations_Edge.Null = function() {
	return new triangulations_Edge(null,null);
};
triangulations_Edge.fromArray = function(arr) {
	return new triangulations_Edge(arr[0],arr[1]);
};
triangulations_Edge.prototype = {
	isNull: function() {
		if(this.p == null) {
			return this.q == null;
		} else {
			return false;
		}
	}
	,clone: function() {
		var e = new triangulations_Edge(this.p,this.q);
		e.fixed = this.fixed;
		e.external = this.external;
		return e;
	}
	,substitute: function(x,y) {
		if(this.p == x) {
			this.p = y;
		} else {
			this.p = y;
		}
	}
	,push: function(val) {
		if(this.p == null) {
			this.p = val;
		} else if(this.q == null) {
			this.q = val;
		} else {
			throw new js__$Boot_HaxeError("Edge already full can't push");
		}
	}
	,toString: function() {
		var p0 = this.p;
		var q0 = this.q;
		var out = "";
		if(this.fixed == true && this.external == true) {
			out = "Edge( " + p0 + "," + q0 + " ";
			if(this.fixed) {
				out += "fixed ";
			}
			if(this.external) {
				out += "external ";
			}
			out += " )";
		} else {
			out = "Edge( " + p0 + "," + q0 + " )";
		}
		return out;
	}
	,__class__: triangulations_Edge
};
var triangulations__$Edges_Edges_$Impl_$ = {};
triangulations__$Edges_Edges_$Impl_$.__name__ = true;
triangulations__$Edges_Edges_$Impl_$._new = function(v) {
	var this1;
	if(v == null) {
		v = triangulations__$Edges_Edges_$Impl_$._new([]);
	}
	this1 = v;
	return this1;
};
triangulations__$Edges_Edges_$Impl_$.getEmpty = function() {
	return triangulations__$Edges_Edges_$Impl_$._new([]);
};
triangulations__$Edges_Edges_$Impl_$.set_fixedExternal = function(this1,val) {
	var _g = 0;
	while(_g < this1.length) {
		var e = this1[_g];
		++_g;
		e.fixed = val;
		e.external = val;
	}
	return val;
};
triangulations__$Edges_Edges_$Impl_$.clone = function(this1) {
	var v = null;
	var this2;
	if(v == null) {
		v = triangulations__$Edges_Edges_$Impl_$._new([]);
	}
	this2 = v;
	var e = this2;
	var l = this1.length;
	var tempIn;
	var tempOut;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var _this = this1[i];
		var e1 = new triangulations_Edge(_this.p,_this.q);
		e1.fixed = _this.fixed;
		e1.external = _this.external;
		e[i] = e1;
	}
	return e;
};
triangulations__$Edges_Edges_$Impl_$.getUnsure = function(this1) {
	var unsureEdges = [];
	var l = this1.length;
	var lu = 0;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var j = _g1++;
		if(!this1[j].fixed) {
			unsureEdges[lu] = j;
			++lu;
		}
	}
	return unsureEdges;
};
triangulations__$Edges_Edges_$Impl_$.add = function(this1,e) {
	var l = this1.length;
	var el = e.length;
	var _g1 = 0;
	var _g = el;
	while(_g1 < _g) {
		var i = _g1++;
		this1[l + i] = e[i];
	}
	return this1;
};
triangulations__$Edges_Edges_$Impl_$.fromArrayArray = function(arr) {
	var edges = triangulations__$Edges_Edges_$Impl_$._new([]);
	var l = arr.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var arr1 = arr[i];
		edges[i] = new triangulations_Edge(arr1[0],arr1[1]);
	}
	return edges;
};
triangulations__$Edges_Edges_$Impl_$.flipEdge = function(this1,coEdges,sideEdges,j) {
	var _this = this1[j];
	var e = new triangulations_Edge(_this.p,_this.q);
	e.fixed = _this.fixed;
	e.external = _this.external;
	var edge = e;
	var coEdge = coEdges[j];
	var se = sideEdges[j];
	var j0 = se.a;
	var j1 = se.b;
	var j2 = se.c;
	var j3 = se.d;
	var _this1 = coEdges[j0];
	var y = coEdge.q;
	if(_this1 != null) {
		if(_this1.p == edge.p) {
			_this1.p = y;
		} else {
			_this1.p = y;
		}
	}
	se = sideEdges[j0];
	if(se != null) {
		if(j == se.a) {
			se.a = j1;
		} else if(j == se.b) {
			se.b = j1;
		} else if(j == se.c) {
			se.c = j1;
		} else {
			se.d = j1;
		}
	}
	if(se != null) {
		if(j3 == se.a) {
			se.a = j;
		} else if(j3 == se.b) {
			se.b = j;
		} else if(j3 == se.c) {
			se.c = j;
		} else {
			se.d = j;
		}
	}
	var _this2 = coEdges[j1];
	var y1 = coEdge.p;
	if(_this2 != null) {
		if(_this2.p == edge.p) {
			_this2.p = y1;
		} else {
			_this2.p = y1;
		}
	}
	se = sideEdges[j1];
	if(se != null) {
		if(j == se.a) {
			se.a = j0;
		} else if(j == se.b) {
			se.b = j0;
		} else if(j == se.c) {
			se.c = j0;
		} else {
			se.d = j0;
		}
	}
	if(se != null) {
		if(j2 == se.a) {
			se.a = j;
		} else if(j2 == se.b) {
			se.b = j;
		} else if(j2 == se.c) {
			se.c = j;
		} else {
			se.d = j;
		}
	}
	var _this3 = coEdges[j2];
	var y2 = coEdge.p;
	if(_this3 != null) {
		if(_this3.p == edge.q) {
			_this3.p = y2;
		} else {
			_this3.p = y2;
		}
	}
	se = sideEdges[j2];
	if(se != null) {
		if(j == se.a) {
			se.a = j3;
		} else if(j == se.b) {
			se.b = j3;
		} else if(j == se.c) {
			se.c = j3;
		} else {
			se.d = j3;
		}
	}
	if(se != null) {
		if(j1 == se.a) {
			se.a = j;
		} else if(j1 == se.b) {
			se.b = j;
		} else if(j1 == se.c) {
			se.c = j;
		} else {
			se.d = j;
		}
	}
	var _this4 = coEdges[j3];
	var y3 = coEdge.q;
	if(_this4 != null) {
		if(_this4.p == edge.q) {
			_this4.p = y3;
		} else {
			_this4.p = y3;
		}
	}
	se = sideEdges[j3];
	if(se != null) {
		if(j == se.a) {
			se.a = j2;
		} else if(j == se.b) {
			se.b = j2;
		} else if(j == se.c) {
			se.c = j2;
		} else {
			se.d = j2;
		}
	}
	if(se != null) {
		if(j0 == se.a) {
			se.a = j;
		} else if(j0 == se.b) {
			se.b = j;
		} else if(j0 == se.c) {
			se.c = j;
		} else {
			se.d = j;
		}
	}
	this1[j] = coEdges[j];
	coEdges[j] = edge;
	var tmp = sideEdges[j].a;
	sideEdges[j].a = sideEdges[j].c;
	sideEdges[j].c = tmp;
};
triangulations__$Edges_Edges_$Impl_$.toString = function(this1) {
	var out = "Edges( ";
	var e;
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		e = this1[i];
		out += e.toString() + ",";
	}
	out = HxOverrides.substr(out,0,out.length - 1);
	out += " )";
	return out;
};
var triangulations__$Face_Face_$Impl_$ = {};
triangulations__$Face_Face_$Impl_$.__name__ = true;
triangulations__$Face_Face_$Impl_$._new = function(v) {
	var this1;
	if(v == null) {
		v = triangulations__$Face_Face_$Impl_$._new([]);
	}
	this1 = v;
	return this1;
};
triangulations__$Face_Face_$Impl_$.getEmpty = function() {
	return triangulations__$Face_Face_$Impl_$._new([]);
};
var triangulations_FillShape = function() {
};
triangulations_FillShape.__name__ = true;
triangulations_FillShape.prototype = {
	scale: function(s) {
		var this1 = this.vertices;
		var l = this1.length;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			var _this = this1[i];
			this1[i] = new khaMath_Vector2(_this.x * s,_this.y * s);
		}
	}
	,translate: function(x,y) {
		var this1 = this.vertices;
		var t_y;
		var t_x = x;
		t_y = y;
		var l = this1.length;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			var _this = this1[i];
			this1[i] = new khaMath_Vector2(_this.x + t_x,_this.y + t_y);
		}
	}
	,fit: function(w,h,margin) {
		if(margin == null) {
			margin = 10;
		}
		var this1 = this.vertices;
		var xMin = Infinity;
		var xMax = -Infinity;
		var yMin = Infinity;
		var yMax = -Infinity;
		var l = this1.length;
		var _g1 = 0;
		var _g = this1.length;
		while(_g1 < _g) {
			var i = _g1++;
			var v = this1[i];
			var x = v.x;
			var y = v.y;
			xMin = Math.min(x,xMin);
			xMax = Math.max(x,xMax);
			yMin = Math.min(y,yMin);
			yMax = Math.max(y,yMax);
		}
		var xdif = xMax - xMin;
		var ydif = yMax - yMin;
		var scaleX = (w - 2 * margin) / xdif;
		var scaleY = (h - 2 * margin) / ydif;
		var scale = Math.min(scaleX,scaleY);
		var marginX = (w - scale * xdif) / 2;
		var marginY = (h - scale * ydif) / 2;
		var _g11 = 0;
		var _g2 = this1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var v1 = this1[i1];
			v1.x = marginX + scale * (v1.x - xMin);
			v1.y = marginY + scale * (v1.y - yMin);
		}
	}
	,set_fixedExternal: function(val) {
		triangulations__$Edges_Edges_$Impl_$.set_fixedExternal(this.edges,val);
	}
	,__class__: triangulations_FillShape
};
var triangulations_Geom2 = function() { };
triangulations_Geom2.__name__ = true;
triangulations_Geom2.inSegment = function(a,b,p) {
	var out = false;
	if(a.x != b.x) {
		if(a.x <= p.x && p.x <= b.x) {
			out = true;
		} else if(a.x >= p.x && p.x >= b.x) {
			out = true;
		}
	} else if(a.y <= p.y && p.y <= b.y) {
		out = true;
	} else if(a.y >= p.y && p.y >= b.y) {
		out = true;
	}
	return out;
};
triangulations_Geom2.pointEncroachesEdge = function(a,b,p) {
	var c_y;
	var c_x = (a.x + b.x) / 2;
	c_y = (a.y + b.y) / 2;
	var dx = c_x - p.x;
	var dy = c_y - p.y;
	var dx1 = c_x - a.x;
	var dy1 = c_y - a.y;
	return dx * dx + dy * dy <= dx1 * dx1 + dy1 * dy1;
};
triangulations_Geom2.triangleArea = function(a,b,c) {
	return (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) / 2;
};
triangulations_Geom2.triangleIsBad = function(minAngle,maxArea) {
	minAngle *= Math.PI / 180;
	var sinSqMinAngle = Math.sin(minAngle);
	sinSqMinAngle *= sinSqMinAngle;
	return function(a,b,c) {
		if((a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) / 2 > maxArea) {
			return true;
		}
		var ab_y;
		var ab_x = b.x - a.x;
		ab_y = b.y - a.y;
		var abLenSq = ab_x * ab_x + ab_y * ab_y;
		var ca_y;
		var ca_x = a.x - c.x;
		ca_y = a.y - c.y;
		var caLenSq = ca_x * ca_x + ca_y * ca_y;
		var abxca = ab_x * ca_y - ab_y * ca_x;
		var sinSqcab = abxca * abxca / (abLenSq * caLenSq);
		if(abxca * abxca < sinSqMinAngle * abLenSq * caLenSq) {
			return true;
		}
		var bc_y;
		var bc_x = c.x - b.x;
		bc_y = c.y - b.y;
		var bcLenSq = bc_x * bc_x + bc_y * bc_y;
		var abxbc = ab_x * ab_y - ab_y * ab_x;
		if(abxbc * abxbc < sinSqMinAngle * abLenSq * bcLenSq) {
			return true;
		}
		var bcxca = bc_x * ca_y - bc_y * ca_x;
		return bcxca * bcxca < sinSqMinAngle * bcLenSq * caLenSq;
	};
};
triangulations_Geom2.circumcenter = function(a,b,c) {
	var xa = a.x;
	var ya = a.y;
	var xb = b.x;
	var yb = b.y;
	var xc = c.x;
	var yc = c.y;
	var d = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
	var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
	var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
	var xp = ka * (yb - yc) - kb * (ya - yc);
	var yp = kb * (xa - xc) - ka * (xb - xc);
	return new khaMath_Vector2(xp / d,yp / d);
};
triangulations_Geom2.pointInCircumcircle = function(a,b,c,v) {
	var p_y;
	var p_x;
	var xa = a.x;
	var ya = a.y;
	var xb = b.x;
	var yb = b.y;
	var xc = c.x;
	var yc = c.y;
	var d = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
	var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
	var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
	var xp = ka * (yb - yc) - kb * (ya - yc);
	var yp = kb * (xa - xc) - ka * (xb - xc);
	p_x = xp / d;
	p_y = yp / d;
	var dx = p_x - v.x;
	var dy = p_y - v.y;
	var dx1 = a.x - p_x;
	var dy1 = a.y - p_y;
	return dx * dx + dy * dy < dx1 * dx1 + dy1 * dy1;
};
triangulations_Geom2.edgeVSRay = function(u,v,y) {
	var val;
	if(u.y > v.y) {
		var tmp = u;
		u = v;
		v = tmp;
	}
	if(y <= u.y || v.y < y) {
		val = null;
	} else {
		var t = (y - u.y) / (v.y - u.y);
		val = u.x + t * (v.x - u.x);
	}
	return val;
};
triangulations_Geom2.edgesIntersect = function(a,b,c,d) {
	var out = true;
	var u_y;
	var u_x = b.x - a.x;
	u_y = b.y - a.y;
	var v_y;
	var v_x = c.x - a.x;
	v_y = c.y - a.y;
	var v_y1;
	var v_x1 = d.x - a.x;
	v_y1 = d.y - a.y;
	var su = (u_x * v_y - u_y * v_x) * (u_x * v_y1 - u_y * v_x1);
	if(su > 0) {
		out = false;
	} else {
		var v_y2;
		var v_x2 = d.x - c.x;
		v_y2 = d.y - c.y;
		var v_y3;
		var v_x3 = a.x - c.x;
		v_y3 = a.y - c.y;
		var v_y4;
		var v_x4 = b.x - c.x;
		v_y4 = b.y - c.y;
		var sv = (v_x2 * v_y3 - v_y2 * v_x3) * (v_x2 * v_y4 - v_y2 * v_x4);
		if(sv > 0) {
			out = false;
		} else if(su == 0 && sv == 0) {
			var dx = a.x - b.x;
			var dy = a.y - b.y;
			var abLenSq = dx * dx + dy * dy;
			var dx1 = a.x - c.x;
			var dy1 = a.y - c.y;
			if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
				var dx2 = a.x - d.x;
				var dy2 = a.y - d.y;
				out = dx2 * dx2 + dy2 * dy2 <= abLenSq;
			} else {
				out = true;
			}
		}
	}
	return out;
};
triangulations_Geom2.pointInTriangle = function(a,b,c) {
	var u_y;
	var u_x = b.x - a.x;
	u_y = b.y - a.y;
	var v_y;
	var v_x = c.x - a.x;
	v_y = c.y - a.y;
	var vxu = v_x * u_y - v_y * u_x;
	var uxv = -vxu;
	return function(p) {
		var w_y;
		var w_x = p.x - a.x;
		w_y = p.y - a.y;
		var vxw = v_x * w_y - v_y * w_x;
		if(vxu * vxw < 0) {
			return false;
		}
		var uxw = u_x * w_y - u_y * w_x;
		if(uxv * uxw < 0) {
			return false;
		}
		return Math.abs(uxw) + Math.abs(vxw) <= Math.abs(uxv);
	};
};
triangulations_Geom2.pointToEdgeDistSq = function(u,v) {
	var uv_y;
	var uv_x = v.x - u.x;
	uv_y = v.y - u.y;
	var uvLenSq = uv_x * uv_x + uv_y * uv_y;
	return function(p) {
		var v_y;
		var v_x = u.x - p.x;
		v_y = u.y - p.y;
		var uvxpu = uv_x * v_y - uv_y * v_x;
		return uvxpu * uvxpu / uvLenSq;
	};
};
triangulations_Geom2.angleCompare = function(c,d) {
	var cd_y;
	var cd_x = d.x - c.x;
	cd_y = d.y - c.y;
	return function(u,v) {
		var cu_y;
		var cu_x = u.x - c.x;
		cu_y = u.y - c.y;
		var cv_y;
		var cv_x = v.x - c.x;
		cv_y = v.y - c.y;
		var cvxcu = cv_x * cu_y - cv_y * cu_x;
		if(cvxcu == 0 && cu_x * cv_x + cu_y * cv_y >= 0) {
			return 0;
		}
		var cuxcd = cu_x * cd_y - cu_y * cd_x;
		var cvxcd = cv_x * cd_y - cv_y * cd_x;
		if(cuxcd == 0 && cd_x * cu_x + cd_y * cu_y >= 0) {
			return -1;
		}
		if(cvxcd == 0 && cd_x * cv_x + cd_y * cv_y >= 0) {
			return 1;
		}
		if(cuxcd * cvxcd >= 0) {
			return cvxcu;
		}
		return cuxcd;
	};
};
var triangulations_Graph = function(vertices_,edges_,faces_) {
	if(vertices_ == null) {
		var v = null;
		var this1;
		if(v == null) {
			v = triangulations__$Vertices_Vertices_$Impl_$._new([]);
		}
		this1 = v;
		vertices_ = this1;
	}
	if(edges_ == null) {
		var v1 = null;
		var this2;
		if(v1 == null) {
			v1 = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this2 = v1;
		edges_ = this2;
	}
	if(faces_ == null) {
		faces_ = [];
	}
	if(faces_[0] == null) {
		faces_[0] = [];
	}
	if(faces_[0][0] == null) {
		faces_[0][0] = [];
	}
	this.vertices = vertices_;
	this.edges = edges_;
	this.faces = faces_;
};
triangulations_Graph.__name__ = true;
triangulations_Graph.prototype = {
	faceOrientation: function(k) {
		var face = this.faces[k];
		var outerPoly = face[0];
		var xMin = this.vertices[outerPoly[0]].x;
		var _g1 = 0;
		var _g = face.length;
		while(_g1 < _g) {
			var l = _g1++;
			var poly = face[l];
			var _g3 = 0;
			var _g2 = poly.length;
			while(_g3 < _g2) {
				var m = _g3++;
				var i = poly[m];
				var x = this.vertices[i].x;
				if(x < xMin) {
					outerPoly = poly;
					break;
				}
			}
		}
		var this1 = this.vertices;
		var area = 0.;
		var l1 = outerPoly.length;
		var v = this1[outerPoly[l1 - 1]];
		var _g11 = 0;
		var _g4 = l1;
		while(_g11 < _g4) {
			var i1 = _g11++;
			var u = v;
			v = this1[outerPoly[i1]];
			area += (u.x + v.x) * (u.y - v.y);
		}
		if(area > 0) {
			return 1;
		} else if(area < 0) {
			return -1;
		} else {
			return 0;
		}
	}
	,computeFaces: function() {
		var vertices = this.vertices;
		var this1 = this.edges;
		var v = null;
		var this2;
		if(v == null) {
			v = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this2 = v;
		var e = this2;
		var l = this1.length;
		var tempIn;
		var tempOut;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			var _this = this1[i];
			var e1 = new triangulations_Edge(_this.p,_this.q);
			e1.fixed = _this.fixed;
			e1.external = _this.external;
			e[i] = e1;
		}
		var edges = e;
		var n = vertices.length;
		var m = edges.length;
		var _g11 = 0;
		var _g2 = m;
		while(_g11 < _g2) {
			var j = _g11++;
			var e2 = edges[j];
			edges.push(new triangulations_Edge(e2.p,e2.q));
		}
		m *= 2;
		var outEdges = [];
		var _g12 = 0;
		var _g3 = n;
		while(_g12 < _g3) {
			var i1 = _g12++;
			outEdges[i1] = [];
		}
		var _g13 = 0;
		var _g4 = m;
		while(_g13 < _g4) {
			var j1 = _g13++;
			var e3 = edges[j1];
			outEdges[e3.p].push(j1);
		}
		var _g14 = 0;
		var _g5 = n;
		while(_g14 < _g5) {
			var i2 = _g14++;
			if(outEdges[i2].length == 0) {
				edges.push(new triangulations_Edge(i2,i2));
				outEdges[i2].push(m);
				++m;
			}
		}
		var taken = [];
		var _g15 = 0;
		var _g6 = m;
		while(_g15 < _g6) {
			var j2 = _g15++;
			taken[j2] = false;
		}
		var polies = [];
		var _g16 = 0;
		var _g7 = m;
		while(_g16 < _g7) {
			var j0 = _g16++;
			if(taken[j0]) {
				continue;
			}
			var iPrev = edges[j0].p;
			var i3 = edges[j0].q;
			var iFirst = iPrev;
			var poly = [iPrev];
			while(i3 != iFirst) {
				var c = [vertices[i3]];
				var d = vertices[iPrev];
				var cd_y = [];
				var cd_x = [];
				var y = d.y - c[0].y;
				cd_x[0] = d.x - c[0].x;
				cd_y[0] = y;
				var cmp = (function(cd_y1,cd_x1,c1) {
					return function(u,v1) {
						var cu_y;
						var cu_x = u.x - c1[0].x;
						cu_y = u.y - c1[0].y;
						var cv_y;
						var cv_x = v1.x - c1[0].x;
						cv_y = v1.y - c1[0].y;
						var cvxcu = cv_x * cu_y - cv_y * cu_x;
						if(cvxcu == 0 && cu_x * cv_x + cu_y * cv_y >= 0) {
							return 0;
						}
						var cuxcd = cu_x * cd_y1[0] - cu_y * cd_x1[0];
						var cvxcd = cv_x * cd_y1[0] - cv_y * cd_x1[0];
						if(cuxcd == 0 && cd_x1[0] * cu_x + cd_y1[0] * cu_y >= 0) {
							return -1;
						}
						if(cvxcd == 0 && cd_x1[0] * cv_x + cd_y1[0] * cv_y >= 0) {
							return 1;
						}
						if(cuxcd * cvxcd >= 0) {
							return cvxcu;
						}
						return cuxcd;
					};
				})(cd_y,cd_x,c);
				var kBest = -1;
				var vBest = null;
				var _g31 = 0;
				var _g21 = outEdges[i3].length;
				while(_g31 < _g21) {
					var k = _g31++;
					var j3 = outEdges[i3][k];
					if(edges[j3].q == iPrev) {
						continue;
					}
					var v2 = vertices[edges[j3].q];
					if(kBest < 0 || cmp(v2,vBest) < 0) {
						kBest = k;
						vBest = v2;
					}
				}
				if(kBest < 0) {
					kBest = 0;
				}
				var jBest = outEdges[i3][kBest];
				taken[jBest] = true;
				outEdges[i3][kBest] = outEdges[i3].pop();
				poly.push(i3);
				iPrev = i3;
				i3 = edges[jBest].q;
			}
			polies.push(poly);
		}
		var faces = [];
		var holes = [];
		var _g17 = 0;
		var _g8 = polies.length;
		while(_g17 < _g8) {
			var k1 = _g17++;
			var poly1 = polies[k1];
			var area = 0.;
			var l1 = poly1.length;
			var v3 = vertices[poly1[l1 - 1]];
			var _g18 = 0;
			var _g9 = l1;
			while(_g18 < _g9) {
				var i4 = _g18++;
				var u1 = v3;
				v3 = vertices[poly1[i4]];
				area += (u1.x + v3.x) * (u1.y - v3.y);
			}
			if((area > 0 ? 1 : area < 0 ? -1 : 0) > 0) {
				faces.push([polies[k1]]);
			} else {
				holes.push(polies[k1]);
			}
		}
		var outerFace = [];
		var _g19 = 0;
		var _g10 = holes.length;
		while(_g19 < _g10) {
			var l2 = _g19++;
			var hole = holes[l2];
			var v4 = vertices[hole[0]];
			var foundFace = false;
			var _g32 = 0;
			var _g22 = faces.length;
			while(_g32 < _g22) {
				var k2 = _g32++;
				var poly2 = faces[k2][0];
				if(triangulations__$Vertices_Vertices_$Impl_$.pointInPolygon(vertices,poly2,v4)) {
					faces[k2].push(hole);
					foundFace = true;
					break;
				}
			}
			if(!foundFace) {
				outerFace.push(hole);
			}
		}
		faces.push(outerFace);
		this.faces = faces;
	}
	,__class__: triangulations_Graph
};
var triangulations_Queue = function() {
	this.offset = 0;
	this.queue = [];
	this.queue = [];
};
triangulations_Queue.__name__ = true;
triangulations_Queue.prototype = {
	getLength: function() {
		return this.queue.length - this.offset;
	}
	,isEmpty: function() {
		return this.queue.length == 0;
	}
	,equeue: function(item) {
		this.queue.push(item);
	}
	,dequeue: function() {
		var item = null;
		if(this.queue.length == 0) {
			item = null;
		} else {
			item = this.queue[this.offset];
			if(++this.offset * 2 >= this.queue.length) {
				this.queue = this.queue.slice(this.offset);
				this.offset = 0;
			}
		}
		return item;
	}
	,peak: function() {
		if(this.queue.length > 0) {
			return this.queue[this.offset];
		} else {
			return null;
		}
	}
	,__class__: triangulations_Queue
};
var triangulations_Settings = function() {
	var v = null;
	var this1;
	if(v == null) {
		v = triangulations__$Vertices_Vertices_$Impl_$._new([]);
	}
	this1 = v;
	this.vertices = this1;
	var v1 = null;
	var this2;
	if(v1 == null) {
		v1 = triangulations__$Edges_Edges_$Impl_$._new([]);
	}
	this2 = v1;
	this.edges = this2;
	this.defaults();
};
triangulations_Settings.__name__ = true;
triangulations_Settings.prototype = {
	defaults: function() {
		this.k = 10;
		this.g = 10;
		this.d = 0.5;
		this.yMax = 100;
		this.maxSteinerPoints = 50;
		this.minAngle = 20;
		this.maxArea = 1e30;
	}
	,__class__: triangulations_Settings
};
var triangulations_SideEdge = function(a_,b_,c_,d_) {
	this.count = 0;
	this.length = 4;
	this.a = a_;
	this.b = b_;
	this.c = c_;
	this.d = d_;
};
triangulations_SideEdge.__name__ = true;
triangulations_SideEdge.getEmpty = function() {
	var sideEdge = new triangulations_SideEdge(null,null,null,null);
	return sideEdge;
};
triangulations_SideEdge.prototype = {
	iterator: function() {
		this.count = 0;
		return this;
	}
	,push: function(val) {
		if(this.a == null) {
			this.a = val;
		} else if(this.b == null) {
			this.b = val;
		} else if(this.c == null) {
			this.c = val;
		} else if(this.d == null) {
			this.d = val;
		} else {
			throw new js__$Boot_HaxeError("Error SideEdge already full can't push");
		}
	}
	,hasNext: function() {
		return this.count < this.length;
	}
	,next: function() {
		var out;
		var _g = this.count;
		switch(_g) {
		case 0:
			out = this.a;
			break;
		case 1:
			out = this.b;
			break;
		case 2:
			out = this.c;
			break;
		case 3:
			out = this.d;
			break;
		default:
			out = this.a;
		}
		this.count++;
		return out;
	}
	,getByIndex: function(i) {
		var out;
		var _g = this.count;
		switch(_g) {
		case 0:
			out = this.a;
			break;
		case 1:
			out = this.b;
			break;
		case 2:
			out = this.c;
			break;
		case 3:
			out = this.d;
			break;
		default:
			out = this.a;
		}
		return out;
	}
	,substitute: function(x,y) {
		if(x == this.a) {
			this.a = y;
		} else if(x == this.b) {
			this.b = y;
		} else if(x == this.c) {
			this.c = y;
		} else {
			this.d = y;
		}
	}
	,__class__: triangulations_SideEdge
};
var triangulations_Triangulate = function() { };
triangulations_Triangulate.__name__ = true;
triangulations_Triangulate.triangulateSimple = function(vertices,edges,face) {
	var _g1 = 0;
	var _g = face.length;
	while(_g1 < _g) {
		var k = _g1++;
		var face1 = face[k];
		var face2 = face1[0];
		var linkedPoly = new triangulations_DllNode(face2[0]);
		var node = linkedPoly;
		var l = face2.length;
		var _g11 = 1;
		var _g2 = l;
		while(_g11 < _g2) {
			var i = _g11++;
			var prevDllNode = node;
			node = new triangulations_DllNode(face2[i]);
			prevDllNode.next = node;
			node.prev = prevDllNode;
		}
		node.next = linkedPoly;
		linkedPoly.prev = node;
		var polies = [linkedPoly];
		var holes = [];
		var l1 = face1.length;
		var _g12 = 1;
		var _g3 = l1;
		while(_g12 < _g3) {
			var k1 = _g12++;
			var face3 = face1[k1];
			var linkedPoly1 = new triangulations_DllNode(face3[0]);
			var node1 = linkedPoly1;
			var l2 = face3.length;
			var _g13 = 1;
			var _g4 = l2;
			while(_g13 < _g4) {
				var i1 = _g13++;
				var prevDllNode1 = node1;
				node1 = new triangulations_DllNode(face3[i1]);
				prevDllNode1.next = node1;
				node1.prev = prevDllNode1;
			}
			node1.next = linkedPoly1;
			linkedPoly1.prev = node1;
			holes.push(linkedPoly1);
		}
		var v = null;
		var this1;
		if(v == null) {
			v = triangulations__$Edges_Edges_$Impl_$._new([]);
		}
		this1 = v;
		var diagonals = this1;
		while(polies.length > 0) {
			var poly = polies.pop();
			var node2 = poly;
			var a;
			var b;
			var c;
			var convex = false;
			while(true) {
				a = vertices[node2.prev.value];
				b = vertices[node2.value];
				c = vertices[node2.next.value];
				var _this_y;
				var _this_x = b.x - a.x;
				_this_y = b.y - a.y;
				var v_y;
				var v_x = c.x - b.x;
				v_y = c.y - b.y;
				convex = _this_x * v_y - _this_y * v_x < 0;
				node2 = node2.next;
				if(!(!convex && node2 != poly)) {
					break;
				}
			}
			if(!convex) {
				continue;
			}
			var aDllNode = node2.prev.prev;
			var bDllNode = node2.prev;
			var cDllNode = node2;
			var acOK = true;
			var a1 = [a];
			var u_y = [];
			var u_x = [];
			var y = b.y - a1[0].y;
			u_x[0] = b.x - a1[0].x;
			u_y[0] = y;
			var v_y1 = [];
			var v_x1 = [];
			var y1 = c.y - a1[0].y;
			v_x1[0] = c.x - a1[0].x;
			v_y1[0] = y1;
			var vxu = [v_x1[0] * u_y[0] - v_y1[0] * u_x[0]];
			var uxv = [-vxu[0]];
			var inabc = (function(v_y2,v_x2,u_y1,u_x1,uxv1,vxu1,a2) {
				return function(p) {
					var w_y;
					var w_x = p.x - a2[0].x;
					w_y = p.y - a2[0].y;
					var vxw = v_x2[0] * w_y - v_y2[0] * w_x;
					if(vxu1[0] * vxw < 0) {
						return false;
					}
					var uxw = u_x1[0] * w_y - u_y1[0] * w_x;
					if(uxv1[0] * uxw < 0) {
						return false;
					}
					return Math.abs(uxw) + Math.abs(vxw) <= Math.abs(uxv1[0]);
				};
			})(v_y1,v_x1,u_y,u_x,uxv,vxu,a1);
			if(!inabc(vertices[aDllNode.prev.value])) {
				acOK = !inabc(vertices[cDllNode.next.value]);
			} else {
				acOK = false;
			}
			if(acOK) {
				var nodeBeg = cDllNode.next;
				var nodeEnd = aDllNode.prev;
				var out = false;
				if(nodeEnd == null) {
					var c1 = vertices[nodeBeg.value];
					var d = vertices[nodeBeg.next.value];
					var acOK1;
					if(c1 != a && c1 != c && d != a && d != c) {
						var out1 = true;
						var u_y2;
						var u_x2 = c.x - a.x;
						u_y2 = c.y - a.y;
						var v_y3;
						var v_x3 = c1.x - a.x;
						v_y3 = c1.y - a.y;
						var v_y4;
						var v_x4 = d.x - a.x;
						v_y4 = d.y - a.y;
						var su = (u_x2 * v_y3 - u_y2 * v_x3) * (u_x2 * v_y4 - u_y2 * v_x4);
						if(su > 0) {
							out1 = false;
						} else {
							var v_y5;
							var v_x5 = d.x - c1.x;
							v_y5 = d.y - c1.y;
							var v_y6;
							var v_x6 = a.x - c1.x;
							v_y6 = a.y - c1.y;
							var v_y7;
							var v_x7 = c.x - c1.x;
							v_y7 = c.y - c1.y;
							var sv = (v_x5 * v_y6 - v_y5 * v_x6) * (v_x5 * v_y7 - v_y5 * v_x7);
							if(sv > 0) {
								out1 = false;
							} else if(su == 0 && sv == 0) {
								var dx = a.x - c.x;
								var dy = a.y - c.y;
								var abLenSq = dx * dx + dy * dy;
								var dx1 = a.x - c1.x;
								var dy1 = a.y - c1.y;
								if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
									var dx2 = a.x - d.x;
									var dy2 = a.y - d.y;
									out1 = dx2 * dx2 + dy2 * dy2 <= abLenSq;
								} else {
									out1 = true;
								}
							}
						}
						acOK1 = out1;
					} else {
						acOK1 = false;
					}
					if(acOK1) {
						out = true;
					} else {
						nodeEnd = nodeBeg;
						nodeBeg = nodeBeg.next;
					}
				}
				if(out != true) {
					var node3 = nodeBeg;
					while(node3 != nodeEnd) {
						var c2 = vertices[node3.value];
						var d1 = vertices[node3.next.value];
						var acOK2;
						if(c2 != a && c2 != c && d1 != a && d1 != c) {
							var out2 = true;
							var u_y3;
							var u_x3 = c.x - a.x;
							u_y3 = c.y - a.y;
							var v_y8;
							var v_x8 = c2.x - a.x;
							v_y8 = c2.y - a.y;
							var v_y9;
							var v_x9 = d1.x - a.x;
							v_y9 = d1.y - a.y;
							var su1 = (u_x3 * v_y8 - u_y3 * v_x8) * (u_x3 * v_y9 - u_y3 * v_x9);
							if(su1 > 0) {
								out2 = false;
							} else {
								var v_y10;
								var v_x10 = d1.x - c2.x;
								v_y10 = d1.y - c2.y;
								var v_y11;
								var v_x11 = a.x - c2.x;
								v_y11 = a.y - c2.y;
								var v_y12;
								var v_x12 = c.x - c2.x;
								v_y12 = c.y - c2.y;
								var sv1 = (v_x10 * v_y11 - v_y10 * v_x11) * (v_x10 * v_y12 - v_y10 * v_x12);
								if(sv1 > 0) {
									out2 = false;
								} else if(su1 == 0 && sv1 == 0) {
									var dx3 = a.x - c.x;
									var dy3 = a.y - c.y;
									var abLenSq1 = dx3 * dx3 + dy3 * dy3;
									var dx4 = a.x - c2.x;
									var dy4 = a.y - c2.y;
									if(!(dx4 * dx4 + dy4 * dy4 <= abLenSq1)) {
										var dx5 = a.x - d1.x;
										var dy5 = a.y - d1.y;
										out2 = dx5 * dx5 + dy5 * dy5 <= abLenSq1;
									} else {
										out2 = true;
									}
								}
							}
							acOK2 = out2;
						} else {
							acOK2 = false;
						}
						if(acOK2) {
							out = true;
							break;
						} else {
							node3 = node3.next;
						}
					}
				}
				acOK = !out;
			}
			var holesLen = holes.length;
			var _g14 = 0;
			var _g5 = holesLen;
			while(_g14 < _g5) {
				var l3 = _g14++;
				var nodeBeg1 = holes[l3];
				var nodeEnd1 = null;
				var out3 = false;
				if(nodeEnd1 == null) {
					var c3 = vertices[nodeBeg1.value];
					var d2 = vertices[nodeBeg1.next.value];
					var acOK3;
					if(c3 != a && c3 != c && d2 != a && d2 != c) {
						var out4 = true;
						var u_y4;
						var u_x4 = c.x - a.x;
						u_y4 = c.y - a.y;
						var v_y13;
						var v_x13 = c3.x - a.x;
						v_y13 = c3.y - a.y;
						var v_y14;
						var v_x14 = d2.x - a.x;
						v_y14 = d2.y - a.y;
						var su2 = (u_x4 * v_y13 - u_y4 * v_x13) * (u_x4 * v_y14 - u_y4 * v_x14);
						if(su2 > 0) {
							out4 = false;
						} else {
							var v_y15;
							var v_x15 = d2.x - c3.x;
							v_y15 = d2.y - c3.y;
							var v_y16;
							var v_x16 = a.x - c3.x;
							v_y16 = a.y - c3.y;
							var v_y17;
							var v_x17 = c.x - c3.x;
							v_y17 = c.y - c3.y;
							var sv2 = (v_x15 * v_y16 - v_y15 * v_x16) * (v_x15 * v_y17 - v_y15 * v_x17);
							if(sv2 > 0) {
								out4 = false;
							} else if(su2 == 0 && sv2 == 0) {
								var dx6 = a.x - c.x;
								var dy6 = a.y - c.y;
								var abLenSq2 = dx6 * dx6 + dy6 * dy6;
								var dx7 = a.x - c3.x;
								var dy7 = a.y - c3.y;
								if(!(dx7 * dx7 + dy7 * dy7 <= abLenSq2)) {
									var dx8 = a.x - d2.x;
									var dy8 = a.y - d2.y;
									out4 = dx8 * dx8 + dy8 * dy8 <= abLenSq2;
								} else {
									out4 = true;
								}
							}
						}
						acOK3 = out4;
					} else {
						acOK3 = false;
					}
					if(acOK3) {
						out3 = true;
					} else {
						nodeEnd1 = nodeBeg1;
						nodeBeg1 = nodeBeg1.next;
					}
				}
				if(out3 != true) {
					var node4 = nodeBeg1;
					while(node4 != nodeEnd1) {
						var c4 = vertices[node4.value];
						var d3 = vertices[node4.next.value];
						var acOK4;
						if(c4 != a && c4 != c && d3 != a && d3 != c) {
							var out5 = true;
							var u_y5;
							var u_x5 = c.x - a.x;
							u_y5 = c.y - a.y;
							var v_y18;
							var v_x18 = c4.x - a.x;
							v_y18 = c4.y - a.y;
							var v_y19;
							var v_x19 = d3.x - a.x;
							v_y19 = d3.y - a.y;
							var su3 = (u_x5 * v_y18 - u_y5 * v_x18) * (u_x5 * v_y19 - u_y5 * v_x19);
							if(su3 > 0) {
								out5 = false;
							} else {
								var v_y20;
								var v_x20 = d3.x - c4.x;
								v_y20 = d3.y - c4.y;
								var v_y21;
								var v_x21 = a.x - c4.x;
								v_y21 = a.y - c4.y;
								var v_y22;
								var v_x22 = c.x - c4.x;
								v_y22 = c.y - c4.y;
								var sv3 = (v_x20 * v_y21 - v_y20 * v_x21) * (v_x20 * v_y22 - v_y20 * v_x22);
								if(sv3 > 0) {
									out5 = false;
								} else if(su3 == 0 && sv3 == 0) {
									var dx9 = a.x - c.x;
									var dy9 = a.y - c.y;
									var abLenSq3 = dx9 * dx9 + dy9 * dy9;
									var dx10 = a.x - c4.x;
									var dy10 = a.y - c4.y;
									if(!(dx10 * dx10 + dy10 * dy10 <= abLenSq3)) {
										var dx11 = a.x - d3.x;
										var dy11 = a.y - d3.y;
										out5 = dx11 * dx11 + dy11 * dy11 <= abLenSq3;
									} else {
										out5 = true;
									}
								}
							}
							acOK4 = out5;
						} else {
							acOK4 = false;
						}
						if(acOK4) {
							out3 = true;
							break;
						} else {
							node4 = node4.next;
						}
					}
				}
				acOK = !out3;
				if(!acOK) {
					break;
				}
			}
			var split;
			var fromDllNode;
			var toDllNode;
			if(acOK) {
				fromDllNode = cDllNode;
				toDllNode = aDllNode;
				split = true;
			} else {
				var a3 = [a];
				var b1 = [b];
				var c5 = [c];
				var a4 = [a3[0]];
				var u_y6 = [];
				var u_x6 = [];
				var y2 = b1[0].y - a4[0].y;
				u_x6[0] = b1[0].x - a4[0].x;
				u_y6[0] = y2;
				var v_y23 = [];
				var v_x23 = [];
				var y3 = c5[0].y - a4[0].y;
				v_x23[0] = c5[0].x - a4[0].x;
				v_y23[0] = y3;
				var vxu2 = [v_x23[0] * u_y6[0] - v_y23[0] * u_x6[0]];
				var uxv2 = [-vxu2[0]];
				var inabc1 = [(function(v_y24,v_x24,u_y7,u_x7,uxv3,vxu3,a5) {
					return function(p1) {
						var w_y1;
						var w_x1 = p1.x - a5[0].x;
						w_y1 = p1.y - a5[0].y;
						var vxw1 = v_x24[0] * w_y1 - v_y24[0] * w_x1;
						if(vxu3[0] * vxw1 < 0) {
							return false;
						}
						var uxw1 = u_x7[0] * w_y1 - u_y7[0] * w_x1;
						if(uxv3[0] * uxw1 < 0) {
							return false;
						}
						return Math.abs(uxw1) + Math.abs(vxw1) <= Math.abs(uxv3[0]);
					};
				})(v_y23,v_x23,u_y6,u_x6,uxv2,vxu2,a4)];
				var u = [a3[0]];
				var uv_y = [];
				var uv_x = [];
				var y4 = c5[0].y - u[0].y;
				uv_x[0] = c5[0].x - u[0].x;
				uv_y[0] = y4;
				var uvLenSq = [uv_x[0] * uv_x[0] + uv_y[0] * uv_y[0]];
				var acDistSq = [(function(uv_y1,uv_x1,uvLenSq1,u1) {
					return function(p2) {
						var v_y25;
						var v_x25 = u1[0].x - p2.x;
						v_y25 = u1[0].y - p2.y;
						var uvxpu = uv_x1[0] * v_y25 - uv_y1[0] * v_x25;
						return uvxpu * uvxpu / uvLenSq1[0];
					};
				})(uv_y,uv_x,uvLenSq,u)];
				var findBest = (function(acDistSq1,inabc2,c6,b2,a6) {
					return function(vertices1,nodeBeg2,nodeEnd2,bestDllNode) {
						var v1;
						var maxDepthSq;
						if(bestDllNode != null) {
							v1 = bestDllNode.value;
							maxDepthSq = acDistSq1[0](vertices1[v1]);
						} else {
							maxDepthSq = -1;
						}
						var node5 = nodeBeg2;
						while(true) {
							var v2 = vertices1[node5.value];
							if(v2 != a6[0] && v2 != b2[0] && v2 != c6[0] && inabc2[0](v2)) {
								var depthSq = acDistSq1[0](v2);
								if(depthSq > maxDepthSq) {
									maxDepthSq = depthSq;
									bestDllNode = node5;
								}
							}
							node5 = node5.next;
							if(!(node5 != nodeEnd2)) {
								break;
							}
						}
						return bestDllNode;
					};
				})(acDistSq,inabc1,c5,b1,a3);
				var best = cDllNode.next != aDllNode ? findBest(vertices,cDllNode.next,aDllNode) : null;
				var lHole = -1;
				var holesLen1 = holes.length;
				var _g15 = 0;
				var _g6 = holesLen1;
				while(_g15 < _g6) {
					var l4 = _g15++;
					var newBest = findBest(vertices,holes[l4],holes[l4],best);
					if(newBest != best) {
						lHole = l4;
					}
					best = newBest;
				}
				fromDllNode = bDllNode;
				toDllNode = best;
				if(lHole < 0) {
					split = true;
				} else {
					holes.splice(lHole,1);
					split = false;
				}
			}
			if(toDllNode == null) {
				continue;
			}
			diagonals.push(new triangulations_Edge(fromDllNode.value,toDllNode.value));
			var poly1 = new triangulations_DllNode(fromDllNode.value);
			poly1.next = fromDllNode.next;
			var tempDllNode = new triangulations_DllNode(toDllNode.value);
			tempDllNode.prev = toDllNode.prev;
			tempDllNode.next = poly1;
			poly1.prev = tempDllNode;
			fromDllNode.next.prev = poly1;
			toDllNode.prev.next = poly1.prev;
			fromDllNode.next = toDllNode;
			toDllNode.prev = fromDllNode;
			var poly2 = fromDllNode;
			if(split) {
				polies.push(poly1);
				polies.push(poly2);
			} else {
				polies.push(poly2);
			}
		}
		var diags = diagonals;
		var l5 = edges.length;
		var el = diags.length;
		var _g16 = 0;
		var _g7 = el;
		while(_g16 < _g7) {
			var i2 = _g16++;
			edges[l5 + i2] = diags[i2];
		}
	}
};
triangulations_Triangulate.triangulateFace = function(vertices,face) {
	var face1 = face[0];
	var linkedPoly = new triangulations_DllNode(face1[0]);
	var node = linkedPoly;
	var l = face1.length;
	var _g1 = 1;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var prevDllNode = node;
		node = new triangulations_DllNode(face1[i]);
		prevDllNode.next = node;
		node.prev = prevDllNode;
	}
	node.next = linkedPoly;
	linkedPoly.prev = node;
	var polies = [linkedPoly];
	var holes = [];
	var l1 = face.length;
	var _g11 = 1;
	var _g2 = l1;
	while(_g11 < _g2) {
		var k = _g11++;
		var face2 = face[k];
		var linkedPoly1 = new triangulations_DllNode(face2[0]);
		var node1 = linkedPoly1;
		var l2 = face2.length;
		var _g12 = 1;
		var _g3 = l2;
		while(_g12 < _g3) {
			var i1 = _g12++;
			var prevDllNode1 = node1;
			node1 = new triangulations_DllNode(face2[i1]);
			prevDllNode1.next = node1;
			node1.prev = prevDllNode1;
		}
		node1.next = linkedPoly1;
		linkedPoly1.prev = node1;
		holes.push(linkedPoly1);
	}
	var v = null;
	var this1;
	if(v == null) {
		v = triangulations__$Edges_Edges_$Impl_$._new([]);
	}
	this1 = v;
	var diagonals = this1;
	while(polies.length > 0) {
		var poly = polies.pop();
		var node2 = poly;
		var a;
		var b;
		var c;
		var convex = false;
		while(true) {
			a = vertices[node2.prev.value];
			b = vertices[node2.value];
			c = vertices[node2.next.value];
			var _this_y;
			var _this_x = b.x - a.x;
			_this_y = b.y - a.y;
			var v_y;
			var v_x = c.x - b.x;
			v_y = c.y - b.y;
			convex = _this_x * v_y - _this_y * v_x < 0;
			node2 = node2.next;
			if(!(!convex && node2 != poly)) {
				break;
			}
		}
		if(!convex) {
			continue;
		}
		var aDllNode = node2.prev.prev;
		var bDllNode = node2.prev;
		var cDllNode = node2;
		var acOK = true;
		var a1 = [a];
		var u_y = [];
		var u_x = [];
		var y = b.y - a1[0].y;
		u_x[0] = b.x - a1[0].x;
		u_y[0] = y;
		var v_y1 = [];
		var v_x1 = [];
		var y1 = c.y - a1[0].y;
		v_x1[0] = c.x - a1[0].x;
		v_y1[0] = y1;
		var vxu = [v_x1[0] * u_y[0] - v_y1[0] * u_x[0]];
		var uxv = [-vxu[0]];
		var inabc = (function(v_y2,v_x2,u_y1,u_x1,uxv1,vxu1,a2) {
			return function(p) {
				var w_y;
				var w_x = p.x - a2[0].x;
				w_y = p.y - a2[0].y;
				var vxw = v_x2[0] * w_y - v_y2[0] * w_x;
				if(vxu1[0] * vxw < 0) {
					return false;
				}
				var uxw = u_x1[0] * w_y - u_y1[0] * w_x;
				if(uxv1[0] * uxw < 0) {
					return false;
				}
				return Math.abs(uxw) + Math.abs(vxw) <= Math.abs(uxv1[0]);
			};
		})(v_y1,v_x1,u_y,u_x,uxv,vxu,a1);
		if(!inabc(vertices[aDllNode.prev.value])) {
			acOK = !inabc(vertices[cDllNode.next.value]);
		} else {
			acOK = false;
		}
		if(acOK) {
			var nodeBeg = cDllNode.next;
			var nodeEnd = aDllNode.prev;
			var out = false;
			if(nodeEnd == null) {
				var c1 = vertices[nodeBeg.value];
				var d = vertices[nodeBeg.next.value];
				var acOK1;
				if(c1 != a && c1 != c && d != a && d != c) {
					var out1 = true;
					var u_y2;
					var u_x2 = c.x - a.x;
					u_y2 = c.y - a.y;
					var v_y3;
					var v_x3 = c1.x - a.x;
					v_y3 = c1.y - a.y;
					var v_y4;
					var v_x4 = d.x - a.x;
					v_y4 = d.y - a.y;
					var su = (u_x2 * v_y3 - u_y2 * v_x3) * (u_x2 * v_y4 - u_y2 * v_x4);
					if(su > 0) {
						out1 = false;
					} else {
						var v_y5;
						var v_x5 = d.x - c1.x;
						v_y5 = d.y - c1.y;
						var v_y6;
						var v_x6 = a.x - c1.x;
						v_y6 = a.y - c1.y;
						var v_y7;
						var v_x7 = c.x - c1.x;
						v_y7 = c.y - c1.y;
						var sv = (v_x5 * v_y6 - v_y5 * v_x6) * (v_x5 * v_y7 - v_y5 * v_x7);
						if(sv > 0) {
							out1 = false;
						} else if(su == 0 && sv == 0) {
							var dx = a.x - c.x;
							var dy = a.y - c.y;
							var abLenSq = dx * dx + dy * dy;
							var dx1 = a.x - c1.x;
							var dy1 = a.y - c1.y;
							if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
								var dx2 = a.x - d.x;
								var dy2 = a.y - d.y;
								out1 = dx2 * dx2 + dy2 * dy2 <= abLenSq;
							} else {
								out1 = true;
							}
						}
					}
					acOK1 = out1;
				} else {
					acOK1 = false;
				}
				if(acOK1) {
					out = true;
				} else {
					nodeEnd = nodeBeg;
					nodeBeg = nodeBeg.next;
				}
			}
			if(out != true) {
				var node3 = nodeBeg;
				while(node3 != nodeEnd) {
					var c2 = vertices[node3.value];
					var d1 = vertices[node3.next.value];
					var acOK2;
					if(c2 != a && c2 != c && d1 != a && d1 != c) {
						var out2 = true;
						var u_y3;
						var u_x3 = c.x - a.x;
						u_y3 = c.y - a.y;
						var v_y8;
						var v_x8 = c2.x - a.x;
						v_y8 = c2.y - a.y;
						var v_y9;
						var v_x9 = d1.x - a.x;
						v_y9 = d1.y - a.y;
						var su1 = (u_x3 * v_y8 - u_y3 * v_x8) * (u_x3 * v_y9 - u_y3 * v_x9);
						if(su1 > 0) {
							out2 = false;
						} else {
							var v_y10;
							var v_x10 = d1.x - c2.x;
							v_y10 = d1.y - c2.y;
							var v_y11;
							var v_x11 = a.x - c2.x;
							v_y11 = a.y - c2.y;
							var v_y12;
							var v_x12 = c.x - c2.x;
							v_y12 = c.y - c2.y;
							var sv1 = (v_x10 * v_y11 - v_y10 * v_x11) * (v_x10 * v_y12 - v_y10 * v_x12);
							if(sv1 > 0) {
								out2 = false;
							} else if(su1 == 0 && sv1 == 0) {
								var dx3 = a.x - c.x;
								var dy3 = a.y - c.y;
								var abLenSq1 = dx3 * dx3 + dy3 * dy3;
								var dx4 = a.x - c2.x;
								var dy4 = a.y - c2.y;
								if(!(dx4 * dx4 + dy4 * dy4 <= abLenSq1)) {
									var dx5 = a.x - d1.x;
									var dy5 = a.y - d1.y;
									out2 = dx5 * dx5 + dy5 * dy5 <= abLenSq1;
								} else {
									out2 = true;
								}
							}
						}
						acOK2 = out2;
					} else {
						acOK2 = false;
					}
					if(acOK2) {
						out = true;
						break;
					} else {
						node3 = node3.next;
					}
				}
			}
			acOK = !out;
		}
		var holesLen = holes.length;
		var _g13 = 0;
		var _g4 = holesLen;
		while(_g13 < _g4) {
			var l3 = _g13++;
			var nodeBeg1 = holes[l3];
			var nodeEnd1 = null;
			var out3 = false;
			if(nodeEnd1 == null) {
				var c3 = vertices[nodeBeg1.value];
				var d2 = vertices[nodeBeg1.next.value];
				var acOK3;
				if(c3 != a && c3 != c && d2 != a && d2 != c) {
					var out4 = true;
					var u_y4;
					var u_x4 = c.x - a.x;
					u_y4 = c.y - a.y;
					var v_y13;
					var v_x13 = c3.x - a.x;
					v_y13 = c3.y - a.y;
					var v_y14;
					var v_x14 = d2.x - a.x;
					v_y14 = d2.y - a.y;
					var su2 = (u_x4 * v_y13 - u_y4 * v_x13) * (u_x4 * v_y14 - u_y4 * v_x14);
					if(su2 > 0) {
						out4 = false;
					} else {
						var v_y15;
						var v_x15 = d2.x - c3.x;
						v_y15 = d2.y - c3.y;
						var v_y16;
						var v_x16 = a.x - c3.x;
						v_y16 = a.y - c3.y;
						var v_y17;
						var v_x17 = c.x - c3.x;
						v_y17 = c.y - c3.y;
						var sv2 = (v_x15 * v_y16 - v_y15 * v_x16) * (v_x15 * v_y17 - v_y15 * v_x17);
						if(sv2 > 0) {
							out4 = false;
						} else if(su2 == 0 && sv2 == 0) {
							var dx6 = a.x - c.x;
							var dy6 = a.y - c.y;
							var abLenSq2 = dx6 * dx6 + dy6 * dy6;
							var dx7 = a.x - c3.x;
							var dy7 = a.y - c3.y;
							if(!(dx7 * dx7 + dy7 * dy7 <= abLenSq2)) {
								var dx8 = a.x - d2.x;
								var dy8 = a.y - d2.y;
								out4 = dx8 * dx8 + dy8 * dy8 <= abLenSq2;
							} else {
								out4 = true;
							}
						}
					}
					acOK3 = out4;
				} else {
					acOK3 = false;
				}
				if(acOK3) {
					out3 = true;
				} else {
					nodeEnd1 = nodeBeg1;
					nodeBeg1 = nodeBeg1.next;
				}
			}
			if(out3 != true) {
				var node4 = nodeBeg1;
				while(node4 != nodeEnd1) {
					var c4 = vertices[node4.value];
					var d3 = vertices[node4.next.value];
					var acOK4;
					if(c4 != a && c4 != c && d3 != a && d3 != c) {
						var out5 = true;
						var u_y5;
						var u_x5 = c.x - a.x;
						u_y5 = c.y - a.y;
						var v_y18;
						var v_x18 = c4.x - a.x;
						v_y18 = c4.y - a.y;
						var v_y19;
						var v_x19 = d3.x - a.x;
						v_y19 = d3.y - a.y;
						var su3 = (u_x5 * v_y18 - u_y5 * v_x18) * (u_x5 * v_y19 - u_y5 * v_x19);
						if(su3 > 0) {
							out5 = false;
						} else {
							var v_y20;
							var v_x20 = d3.x - c4.x;
							v_y20 = d3.y - c4.y;
							var v_y21;
							var v_x21 = a.x - c4.x;
							v_y21 = a.y - c4.y;
							var v_y22;
							var v_x22 = c.x - c4.x;
							v_y22 = c.y - c4.y;
							var sv3 = (v_x20 * v_y21 - v_y20 * v_x21) * (v_x20 * v_y22 - v_y20 * v_x22);
							if(sv3 > 0) {
								out5 = false;
							} else if(su3 == 0 && sv3 == 0) {
								var dx9 = a.x - c.x;
								var dy9 = a.y - c.y;
								var abLenSq3 = dx9 * dx9 + dy9 * dy9;
								var dx10 = a.x - c4.x;
								var dy10 = a.y - c4.y;
								if(!(dx10 * dx10 + dy10 * dy10 <= abLenSq3)) {
									var dx11 = a.x - d3.x;
									var dy11 = a.y - d3.y;
									out5 = dx11 * dx11 + dy11 * dy11 <= abLenSq3;
								} else {
									out5 = true;
								}
							}
						}
						acOK4 = out5;
					} else {
						acOK4 = false;
					}
					if(acOK4) {
						out3 = true;
						break;
					} else {
						node4 = node4.next;
					}
				}
			}
			acOK = !out3;
			if(!acOK) {
				break;
			}
		}
		var split;
		var fromDllNode;
		var toDllNode;
		if(acOK) {
			fromDllNode = cDllNode;
			toDllNode = aDllNode;
			split = true;
		} else {
			var a3 = [a];
			var b1 = [b];
			var c5 = [c];
			var a4 = [a3[0]];
			var u_y6 = [];
			var u_x6 = [];
			var y2 = b1[0].y - a4[0].y;
			u_x6[0] = b1[0].x - a4[0].x;
			u_y6[0] = y2;
			var v_y23 = [];
			var v_x23 = [];
			var y3 = c5[0].y - a4[0].y;
			v_x23[0] = c5[0].x - a4[0].x;
			v_y23[0] = y3;
			var vxu2 = [v_x23[0] * u_y6[0] - v_y23[0] * u_x6[0]];
			var uxv2 = [-vxu2[0]];
			var inabc1 = [(function(v_y24,v_x24,u_y7,u_x7,uxv3,vxu3,a5) {
				return function(p1) {
					var w_y1;
					var w_x1 = p1.x - a5[0].x;
					w_y1 = p1.y - a5[0].y;
					var vxw1 = v_x24[0] * w_y1 - v_y24[0] * w_x1;
					if(vxu3[0] * vxw1 < 0) {
						return false;
					}
					var uxw1 = u_x7[0] * w_y1 - u_y7[0] * w_x1;
					if(uxv3[0] * uxw1 < 0) {
						return false;
					}
					return Math.abs(uxw1) + Math.abs(vxw1) <= Math.abs(uxv3[0]);
				};
			})(v_y23,v_x23,u_y6,u_x6,uxv2,vxu2,a4)];
			var u = [a3[0]];
			var uv_y = [];
			var uv_x = [];
			var y4 = c5[0].y - u[0].y;
			uv_x[0] = c5[0].x - u[0].x;
			uv_y[0] = y4;
			var uvLenSq = [uv_x[0] * uv_x[0] + uv_y[0] * uv_y[0]];
			var acDistSq = [(function(uv_y1,uv_x1,uvLenSq1,u1) {
				return function(p2) {
					var v_y25;
					var v_x25 = u1[0].x - p2.x;
					v_y25 = u1[0].y - p2.y;
					var uvxpu = uv_x1[0] * v_y25 - uv_y1[0] * v_x25;
					return uvxpu * uvxpu / uvLenSq1[0];
				};
			})(uv_y,uv_x,uvLenSq,u)];
			var findBest = (function(acDistSq1,inabc2,c6,b2,a6) {
				return function(vertices1,nodeBeg2,nodeEnd2,bestDllNode) {
					var v1;
					var maxDepthSq;
					if(bestDllNode != null) {
						v1 = bestDllNode.value;
						maxDepthSq = acDistSq1[0](vertices1[v1]);
					} else {
						maxDepthSq = -1;
					}
					var node5 = nodeBeg2;
					while(true) {
						var v2 = vertices1[node5.value];
						if(v2 != a6[0] && v2 != b2[0] && v2 != c6[0] && inabc2[0](v2)) {
							var depthSq = acDistSq1[0](v2);
							if(depthSq > maxDepthSq) {
								maxDepthSq = depthSq;
								bestDllNode = node5;
							}
						}
						node5 = node5.next;
						if(!(node5 != nodeEnd2)) {
							break;
						}
					}
					return bestDllNode;
				};
			})(acDistSq,inabc1,c5,b1,a3);
			var best = cDllNode.next != aDllNode ? findBest(vertices,cDllNode.next,aDllNode) : null;
			var lHole = -1;
			var holesLen1 = holes.length;
			var _g14 = 0;
			var _g5 = holesLen1;
			while(_g14 < _g5) {
				var l4 = _g14++;
				var newBest = findBest(vertices,holes[l4],holes[l4],best);
				if(newBest != best) {
					lHole = l4;
				}
				best = newBest;
			}
			fromDllNode = bDllNode;
			toDllNode = best;
			if(lHole < 0) {
				split = true;
			} else {
				holes.splice(lHole,1);
				split = false;
			}
		}
		if(toDllNode == null) {
			continue;
		}
		diagonals.push(new triangulations_Edge(fromDllNode.value,toDllNode.value));
		var poly1 = new triangulations_DllNode(fromDllNode.value);
		poly1.next = fromDllNode.next;
		var tempDllNode = new triangulations_DllNode(toDllNode.value);
		tempDllNode.prev = toDllNode.prev;
		tempDllNode.next = poly1;
		poly1.prev = tempDllNode;
		fromDllNode.next.prev = poly1;
		toDllNode.prev.next = poly1.prev;
		fromDllNode.next = toDllNode;
		toDllNode.prev = fromDllNode;
		var poly2 = fromDllNode;
		if(split) {
			polies.push(poly1);
			polies.push(poly2);
		} else {
			polies.push(poly2);
		}
	}
	return diagonals;
};
triangulations_Triangulate.makeLinkedPoly = function(face) {
	var linkedPoly = new triangulations_DllNode(face[0]);
	var node = linkedPoly;
	var l = face.length;
	var _g1 = 1;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var prevDllNode = node;
		node = new triangulations_DllNode(face[i]);
		prevDllNode.next = node;
		node.prev = prevDllNode;
	}
	node.next = linkedPoly;
	linkedPoly.prev = node;
	return linkedPoly;
};
triangulations_Triangulate.isDelaunayEdge = function(vertices,edge,coEdge) {
	var a = vertices[edge.p];
	var c = vertices[edge.q];
	var b = vertices[coEdge.p];
	var d = vertices[coEdge.q];
	var p_y;
	var p_x;
	var xa = a.x;
	var ya = a.y;
	var xb = c.x;
	var yb = c.y;
	var xc = b.x;
	var yc = b.y;
	var d1 = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
	var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
	var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
	var xp = ka * (yb - yc) - kb * (ya - yc);
	var yp = kb * (xa - xc) - ka * (xb - xc);
	p_x = xp / d1;
	p_y = yp / d1;
	var dx = p_x - d.x;
	var dy = p_y - d.y;
	var dx1 = a.x - p_x;
	var dy1 = a.y - p_y;
	var in0 = !(dx * dx + dy * dy < dx1 * dx1 + dy1 * dy1);
	var p_y1;
	var p_x1;
	var xa1 = a.x;
	var ya1 = a.y;
	var xb1 = c.x;
	var yb1 = c.y;
	var xc1 = d.x;
	var yc1 = d.y;
	var d2 = 2 * ((xa1 - xc1) * (yb1 - yc1) - (xb1 - xc1) * (ya1 - yc1));
	var ka1 = (xa1 - xc1) * (xa1 + xc1) + (ya1 - yc1) * (ya1 + yc1);
	var kb1 = (xb1 - xc1) * (xb1 + xc1) + (yb1 - yc1) * (yb1 + yc1);
	var xp1 = ka1 * (yb1 - yc1) - kb1 * (ya1 - yc1);
	var yp1 = kb1 * (xa1 - xc1) - ka1 * (xb1 - xc1);
	p_x1 = xp1 / d2;
	p_y1 = yp1 / d2;
	var dx2 = p_x1 - b.x;
	var dy2 = p_y1 - b.y;
	var dx3 = a.x - p_x1;
	var dy3 = a.y - p_y1;
	var in1 = !(dx2 * dx2 + dy2 * dy2 < dx3 * dx3 + dy3 * dy3);
	console.log("in0 " + (in0 == null ? "null" : "" + in0));
	console.log("in1 " + (in1 == null ? "null" : "" + in1));
	console.log("in_" + Std.string(in0 && in1));
	if(in0) {
		return in1;
	} else {
		return false;
	}
};
triangulations_Triangulate.intersects = function(a,b,vertices,nodeBeg,nodeEnd) {
	var out = false;
	if(nodeEnd == null) {
		var c = vertices[nodeBeg.value];
		var d = vertices[nodeBeg.next.value];
		var tmp;
		if(c != a && c != b && d != a && d != b) {
			var out1 = true;
			var u_y;
			var u_x = b.x - a.x;
			u_y = b.y - a.y;
			var v_y;
			var v_x = c.x - a.x;
			v_y = c.y - a.y;
			var v_y1;
			var v_x1 = d.x - a.x;
			v_y1 = d.y - a.y;
			var su = (u_x * v_y - u_y * v_x) * (u_x * v_y1 - u_y * v_x1);
			if(su > 0) {
				out1 = false;
			} else {
				var v_y2;
				var v_x2 = d.x - c.x;
				v_y2 = d.y - c.y;
				var v_y3;
				var v_x3 = a.x - c.x;
				v_y3 = a.y - c.y;
				var v_y4;
				var v_x4 = b.x - c.x;
				v_y4 = b.y - c.y;
				var sv = (v_x2 * v_y3 - v_y2 * v_x3) * (v_x2 * v_y4 - v_y2 * v_x4);
				if(sv > 0) {
					out1 = false;
				} else if(su == 0 && sv == 0) {
					var dx = a.x - b.x;
					var dy = a.y - b.y;
					var abLenSq = dx * dx + dy * dy;
					var dx1 = a.x - c.x;
					var dy1 = a.y - c.y;
					if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
						var dx2 = a.x - d.x;
						var dy2 = a.y - d.y;
						out1 = dx2 * dx2 + dy2 * dy2 <= abLenSq;
					} else {
						out1 = true;
					}
				}
			}
			tmp = out1;
		} else {
			tmp = false;
		}
		if(tmp) {
			out = true;
		} else {
			nodeEnd = nodeBeg;
			nodeBeg = nodeBeg.next;
		}
	}
	if(out != true) {
		var node = nodeBeg;
		while(node != nodeEnd) {
			var c1 = vertices[node.value];
			var d1 = vertices[node.next.value];
			var tmp1;
			if(c1 != a && c1 != b && d1 != a && d1 != b) {
				var out2 = true;
				var u_y1;
				var u_x1 = b.x - a.x;
				u_y1 = b.y - a.y;
				var v_y5;
				var v_x5 = c1.x - a.x;
				v_y5 = c1.y - a.y;
				var v_y6;
				var v_x6 = d1.x - a.x;
				v_y6 = d1.y - a.y;
				var su1 = (u_x1 * v_y5 - u_y1 * v_x5) * (u_x1 * v_y6 - u_y1 * v_x6);
				if(su1 > 0) {
					out2 = false;
				} else {
					var v_y7;
					var v_x7 = d1.x - c1.x;
					v_y7 = d1.y - c1.y;
					var v_y8;
					var v_x8 = a.x - c1.x;
					v_y8 = a.y - c1.y;
					var v_y9;
					var v_x9 = b.x - c1.x;
					v_y9 = b.y - c1.y;
					var sv1 = (v_x7 * v_y8 - v_y7 * v_x8) * (v_x7 * v_y9 - v_y7 * v_x9);
					if(sv1 > 0) {
						out2 = false;
					} else if(su1 == 0 && sv1 == 0) {
						var dx3 = a.x - b.x;
						var dy3 = a.y - b.y;
						var abLenSq1 = dx3 * dx3 + dy3 * dy3;
						var dx4 = a.x - c1.x;
						var dy4 = a.y - c1.y;
						if(!(dx4 * dx4 + dy4 * dy4 <= abLenSq1)) {
							var dx5 = a.x - d1.x;
							var dy5 = a.y - d1.y;
							out2 = dx5 * dx5 + dy5 * dy5 <= abLenSq1;
						} else {
							out2 = true;
						}
					}
				}
				tmp1 = out2;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				out = true;
				break;
			} else {
				node = node.next;
			}
		}
	}
	return out;
};
triangulations_Triangulate.aux = function(vertices,a,b,node) {
	var c = vertices[node.value];
	var d = vertices[node.next.value];
	if(c != a && c != b && d != a && d != b) {
		var out = true;
		var u_y;
		var u_x = b.x - a.x;
		u_y = b.y - a.y;
		var v_y;
		var v_x = c.x - a.x;
		v_y = c.y - a.y;
		var v_y1;
		var v_x1 = d.x - a.x;
		v_y1 = d.y - a.y;
		var su = (u_x * v_y - u_y * v_x) * (u_x * v_y1 - u_y * v_x1);
		if(su > 0) {
			out = false;
		} else {
			var v_y2;
			var v_x2 = d.x - c.x;
			v_y2 = d.y - c.y;
			var v_y3;
			var v_x3 = a.x - c.x;
			v_y3 = a.y - c.y;
			var v_y4;
			var v_x4 = b.x - c.x;
			v_y4 = b.y - c.y;
			var sv = (v_x2 * v_y3 - v_y2 * v_x3) * (v_x2 * v_y4 - v_y2 * v_x4);
			if(sv > 0) {
				out = false;
			} else if(su == 0 && sv == 0) {
				var dx = a.x - b.x;
				var dy = a.y - b.y;
				var abLenSq = dx * dx + dy * dy;
				var dx1 = a.x - c.x;
				var dy1 = a.y - c.y;
				if(!(dx1 * dx1 + dy1 * dy1 <= abLenSq)) {
					var dx2 = a.x - d.x;
					var dy2 = a.y - d.y;
					out = dx2 * dx2 + dy2 * dy2 <= abLenSq;
				} else {
					out = true;
				}
			}
		}
		return out;
	} else {
		return false;
	}
};
triangulations_Triangulate.findDeepestInside = function(a,b,c) {
	var a1 = a;
	var u_y;
	var u_x = b.x - a1.x;
	u_y = b.y - a1.y;
	var v_y;
	var v_x = c.x - a1.x;
	v_y = c.y - a1.y;
	var vxu = v_x * u_y - v_y * u_x;
	var uxv = -vxu;
	var inabc = function(p) {
		var w_y;
		var w_x = p.x - a1.x;
		w_y = p.y - a1.y;
		var vxw = v_x * w_y - v_y * w_x;
		if(vxu * vxw < 0) {
			return false;
		}
		var uxw = u_x * w_y - u_y * w_x;
		if(uxv * uxw < 0) {
			return false;
		}
		return Math.abs(uxw) + Math.abs(vxw) <= Math.abs(uxv);
	};
	var u = a;
	var uv_y;
	var uv_x = c.x - u.x;
	uv_y = c.y - u.y;
	var uvLenSq = uv_x * uv_x + uv_y * uv_y;
	var acDistSq = function(p1) {
		var v_y1;
		var v_x1 = u.x - p1.x;
		v_y1 = u.y - p1.y;
		var uvxpu = uv_x * v_y1 - uv_y * v_x1;
		return uvxpu * uvxpu / uvLenSq;
	};
	return function(vertices,nodeBeg,nodeEnd,bestDllNode) {
		var v;
		var maxDepthSq;
		if(bestDllNode != null) {
			v = bestDllNode.value;
			maxDepthSq = acDistSq(vertices[v]);
		} else {
			maxDepthSq = -1;
		}
		var node = nodeBeg;
		while(true) {
			var v1 = vertices[node.value];
			if(v1 != a && v1 != b && v1 != c && inabc(v1)) {
				var depthSq = acDistSq(v1);
				if(depthSq > maxDepthSq) {
					maxDepthSq = depthSq;
					bestDllNode = node;
				}
			}
			node = node.next;
			if(!(node != nodeEnd)) {
				break;
			}
		}
		return bestDllNode;
	};
};
triangulations_Triangulate.makeQuadEdge = function(vertices,edges,coEdges,sideEdges) {
	var _g1 = 0;
	var _g = edges.length;
	while(_g1 < _g) {
		var j = _g1++;
		coEdges[j] = new triangulations_Edge(null,null);
		var sideEdge = new triangulations_SideEdge(null,null,null,null);
		sideEdges[j] = sideEdge;
	}
	var outEdges = [];
	var _g11 = 0;
	var _g2 = vertices.length;
	while(_g11 < _g2) {
		var i = _g11++;
		outEdges[i] = [];
	}
	var _g12 = 0;
	var _g3 = edges.length;
	while(_g12 < _g3) {
		var j1 = _g12++;
		var e = edges[j1];
		outEdges[e.p].push(j1);
		outEdges[e.q].push(j1);
	}
	var l = vertices.length;
	var _g13 = 0;
	var _g4 = l;
	while(_g13 < _g4) {
		var i1 = _g13++;
		var v = vertices[i1];
		var js1 = outEdges[i1];
		var _g31 = 0;
		var _g21 = js1.length;
		while(_g31 < _g21) {
			var k = _g31++;
			var e1 = edges[js1[k]];
			if(e1.p != i1) {
				e1.q = e1.p;
				e1.p = i1;
			}
		}
		var c = [v];
		var d = vertices[edges[js1[0]].q];
		var cd_y = [];
		var cd_x = [];
		var y = d.y - c[0].y;
		cd_x[0] = d.x - c[0].x;
		cd_y[0] = y;
		var angleCmp = [(function(cd_y1,cd_x1,c1) {
			return function(u,v1) {
				var cu_y;
				var cu_x = u.x - c1[0].x;
				cu_y = u.y - c1[0].y;
				var cv_y;
				var cv_x = v1.x - c1[0].x;
				cv_y = v1.y - c1[0].y;
				var cvxcu = cv_x * cu_y - cv_y * cu_x;
				if(cvxcu == 0 && cu_x * cv_x + cu_y * cv_y >= 0) {
					return 0;
				}
				var cuxcd = cu_x * cd_y1[0] - cu_y * cd_x1[0];
				var cvxcd = cv_x * cd_y1[0] - cv_y * cd_x1[0];
				if(cuxcd == 0 && cd_x1[0] * cu_x + cd_y1[0] * cu_y >= 0) {
					return -1;
				}
				if(cvxcd == 0 && cd_x1[0] * cv_x + cd_y1[0] * cv_y >= 0) {
					return 1;
				}
				if(cuxcd * cvxcd >= 0) {
					return cvxcu;
				}
				return cuxcd;
			};
		})(cd_y,cd_x,c)];
		js1.sort((function(angleCmp1) {
			return function(j11,j2) {
				return angleCmp1[0](vertices[edges[j11].q],vertices[edges[j2].q]) | 0;
			};
		})(angleCmp));
		var _g32 = 0;
		var _g22 = js1.length;
		while(_g32 < _g22) {
			var k1 = _g32++;
			var jPrev = js1[(js1.length + k1 - 1) % js1.length];
			var j3 = js1[k1];
			var jNext = js1[(k1 + 1) % js1.length];
			var _this = coEdges[j3];
			var val = edges[jPrev].q;
			if(_this.p == null) {
				_this.p = val;
			} else if(_this.q == null) {
				_this.q = val;
			} else {
				throw new js__$Boot_HaxeError("Edge already full can't push");
			}
			console.log("coEdges[" + j3 + "]" + Std.string(coEdges[j3]));
			var _this1 = sideEdges[j3];
			if(_this1.a == null) {
				_this1.a = jPrev;
			} else if(_this1.b == null) {
				_this1.b = jPrev;
			} else if(_this1.c == null) {
				_this1.c = jPrev;
			} else if(_this1.d == null) {
				_this1.d = jPrev;
			} else {
				throw new js__$Boot_HaxeError("Error SideEdge already full can't push");
			}
			var _this2 = sideEdges[j3];
			if(_this2.a == null) {
				_this2.a = jNext;
			} else if(_this2.b == null) {
				_this2.b = jNext;
			} else if(_this2.c == null) {
				_this2.c = jNext;
			} else if(_this2.d == null) {
				_this2.d = jNext;
			} else {
				throw new js__$Boot_HaxeError("Error SideEdge already full can't push");
			}
		}
	}
	var disjoint = function(i2,j4) {
		if(edges[j4].p != i2) {
			return edges[j4].q != i2;
		} else {
			return false;
		}
	};
	var _g14 = 0;
	var _g5 = edges.length;
	while(_g14 < _g5) {
		var j5 = _g14++;
		if(!edges[j5].external) {
			continue;
		}
		var ce = coEdges[j5];
		var ses = sideEdges[j5];
		if(ce.p == ce.q) {
			ce.q = ses.b = ses.c = null;
			continue;
		}
	}
	console.log("coEdges__ " + triangulations__$Edges_Edges_$Impl_$.toString(coEdges));
};
triangulations_Triangulate.ensureDelaunayEdge = function(vertices,edges,coEdges,sideEdges,j) {
	var out;
	var edge = edges[j];
	var coEdge = coEdges[j];
	var a = vertices[edge.p];
	var c = vertices[edge.q];
	var b = vertices[coEdge.p];
	var d = vertices[coEdge.q];
	var p_y;
	var p_x;
	var xa = a.x;
	var ya = a.y;
	var xb = c.x;
	var yb = c.y;
	var xc = b.x;
	var yc = b.y;
	var d1 = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
	var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
	var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
	var xp = ka * (yb - yc) - kb * (ya - yc);
	var yp = kb * (xa - xc) - ka * (xb - xc);
	p_x = xp / d1;
	p_y = yp / d1;
	var dx = p_x - d.x;
	var dy = p_y - d.y;
	var dx1 = a.x - p_x;
	var dy1 = a.y - p_y;
	var in0 = !(dx * dx + dy * dy < dx1 * dx1 + dy1 * dy1);
	var p_y1;
	var p_x1;
	var xa1 = a.x;
	var ya1 = a.y;
	var xb1 = c.x;
	var yb1 = c.y;
	var xc1 = d.x;
	var yc1 = d.y;
	var d2 = 2 * ((xa1 - xc1) * (yb1 - yc1) - (xb1 - xc1) * (ya1 - yc1));
	var ka1 = (xa1 - xc1) * (xa1 + xc1) + (ya1 - yc1) * (ya1 + yc1);
	var kb1 = (xb1 - xc1) * (xb1 + xc1) + (yb1 - yc1) * (yb1 + yc1);
	var xp1 = ka1 * (yb1 - yc1) - kb1 * (ya1 - yc1);
	var yp1 = kb1 * (xa1 - xc1) - ka1 * (xb1 - xc1);
	p_x1 = xp1 / d2;
	p_y1 = yp1 / d2;
	var dx2 = p_x1 - b.x;
	var dy2 = p_y1 - b.y;
	var dx3 = a.x - p_x1;
	var dy3 = a.y - p_y1;
	var in1 = !(dx2 * dx2 + dy2 * dy2 < dx3 * dx3 + dy3 * dy3);
	console.log("in0 " + (in0 == null ? "null" : "" + in0));
	console.log("in1 " + (in1 == null ? "null" : "" + in1));
	console.log("in_" + Std.string(in0 && in1));
	if(in0 && in1) {
		console.log("ensureDelaunayEdge " + j + " false ");
		out = false;
	} else {
		var _this = edges[j];
		var e = new triangulations_Edge(_this.p,_this.q);
		e.fixed = _this.fixed;
		e.external = _this.external;
		var edge1 = e;
		var coEdge1 = coEdges[j];
		var se = sideEdges[j];
		var j0 = se.a;
		var j1 = se.b;
		var j2 = se.c;
		var j3 = se.d;
		var _this1 = coEdges[j0];
		var y = coEdge1.q;
		if(_this1 != null) {
			if(_this1.p == edge1.p) {
				_this1.p = y;
			} else {
				_this1.p = y;
			}
		}
		se = sideEdges[j0];
		if(se != null) {
			if(j == se.a) {
				se.a = j1;
			} else if(j == se.b) {
				se.b = j1;
			} else if(j == se.c) {
				se.c = j1;
			} else {
				se.d = j1;
			}
		}
		if(se != null) {
			if(j3 == se.a) {
				se.a = j;
			} else if(j3 == se.b) {
				se.b = j;
			} else if(j3 == se.c) {
				se.c = j;
			} else {
				se.d = j;
			}
		}
		var _this2 = coEdges[j1];
		var y1 = coEdge1.p;
		if(_this2 != null) {
			if(_this2.p == edge1.p) {
				_this2.p = y1;
			} else {
				_this2.p = y1;
			}
		}
		se = sideEdges[j1];
		if(se != null) {
			if(j == se.a) {
				se.a = j0;
			} else if(j == se.b) {
				se.b = j0;
			} else if(j == se.c) {
				se.c = j0;
			} else {
				se.d = j0;
			}
		}
		if(se != null) {
			if(j2 == se.a) {
				se.a = j;
			} else if(j2 == se.b) {
				se.b = j;
			} else if(j2 == se.c) {
				se.c = j;
			} else {
				se.d = j;
			}
		}
		var _this3 = coEdges[j2];
		var y2 = coEdge1.p;
		if(_this3 != null) {
			if(_this3.p == edge1.q) {
				_this3.p = y2;
			} else {
				_this3.p = y2;
			}
		}
		se = sideEdges[j2];
		if(se != null) {
			if(j == se.a) {
				se.a = j3;
			} else if(j == se.b) {
				se.b = j3;
			} else if(j == se.c) {
				se.c = j3;
			} else {
				se.d = j3;
			}
		}
		if(se != null) {
			if(j1 == se.a) {
				se.a = j;
			} else if(j1 == se.b) {
				se.b = j;
			} else if(j1 == se.c) {
				se.c = j;
			} else {
				se.d = j;
			}
		}
		var _this4 = coEdges[j3];
		var y3 = coEdge1.q;
		if(_this4 != null) {
			if(_this4.p == edge1.q) {
				_this4.p = y3;
			} else {
				_this4.p = y3;
			}
		}
		se = sideEdges[j3];
		if(se != null) {
			if(j == se.a) {
				se.a = j2;
			} else if(j == se.b) {
				se.b = j2;
			} else if(j == se.c) {
				se.c = j2;
			} else {
				se.d = j2;
			}
		}
		if(se != null) {
			if(j0 == se.a) {
				se.a = j;
			} else if(j0 == se.b) {
				se.b = j;
			} else if(j0 == se.c) {
				se.c = j;
			} else {
				se.d = j;
			}
		}
		edges[j] = coEdges[j];
		coEdges[j] = edge1;
		var tmp = sideEdges[j].a;
		sideEdges[j].a = sideEdges[j].c;
		sideEdges[j].c = tmp;
		console.log("ensureDelaunayEdge " + j + " true ");
		out = true;
	}
	console.log(" ensureDelaunayEdge " + (out == null ? "null" : "" + out));
	return out;
};
triangulations_Triangulate.faceFromDllNode = function(linkedPoly) {
	var v = null;
	var this1;
	if(v == null) {
		v = triangulations__$Face_Face_$Impl_$._new([]);
	}
	this1 = v;
	var face = this1;
	var node = linkedPoly;
	var l = 0;
	while(true) {
		face[l] = node.value;
		++l;
		node = node.next;
		if(!(node != linkedPoly)) {
			break;
		}
	}
	return face;
};
triangulations_Triangulate.refineToDelaunay = function(vertices,edges,coEdges,sideEdges) {
	var unsureEdges = [];
	var l = edges.length;
	var lu = 0;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var j = _g1++;
		if(!edges[j].fixed) {
			unsureEdges[lu] = j;
			++lu;
		}
	}
	var unsureEdges1 = unsureEdges;
	console.log("unsureEdges " + Std.string(unsureEdges1));
	return (triangulations_Triangulate.get_delaunay())(vertices,edges,coEdges,sideEdges,unsureEdges1);
};
triangulations_Triangulate.get_delaunay = function() {
	if(triangulations_Triangulate._delaunay == null) {
		var unsure = [];
		var tried = [];
		var cookie = 0;
		triangulations_Triangulate._delaunay = function(vertices,edges,coEdges,sideEdges,unsureEdges) {
			cookie += 1;
			var triedEdges = unsureEdges.slice(0);
			var _g1 = 0;
			var _g = unsureEdges.length;
			while(_g1 < _g) {
				var l = _g1++;
				unsure[unsureEdges[l]] = true;
				tried[unsureEdges[l]] = cookie;
			}
			while(unsureEdges.length > 0) {
				var j = unsureEdges.pop();
				unsure[j] = false;
				var out;
				var edge = edges[j];
				var coEdge = coEdges[j];
				var a = vertices[edge.p];
				var c = vertices[edge.q];
				var b = vertices[coEdge.p];
				var d = vertices[coEdge.q];
				var p_y;
				var p_x;
				var xa = a.x;
				var ya = a.y;
				var xb = c.x;
				var yb = c.y;
				var xc = b.x;
				var yc = b.y;
				var d1 = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
				var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
				var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
				var xp = ka * (yb - yc) - kb * (ya - yc);
				var yp = kb * (xa - xc) - ka * (xb - xc);
				p_x = xp / d1;
				p_y = yp / d1;
				var dx = p_x - d.x;
				var dy = p_y - d.y;
				var dx1 = a.x - p_x;
				var dy1 = a.y - p_y;
				var in0 = !(dx * dx + dy * dy < dx1 * dx1 + dy1 * dy1);
				var p_y1;
				var p_x1;
				var xa1 = a.x;
				var ya1 = a.y;
				var xb1 = c.x;
				var yb1 = c.y;
				var xc1 = d.x;
				var yc1 = d.y;
				var d2 = 2 * ((xa1 - xc1) * (yb1 - yc1) - (xb1 - xc1) * (ya1 - yc1));
				var ka1 = (xa1 - xc1) * (xa1 + xc1) + (ya1 - yc1) * (ya1 + yc1);
				var kb1 = (xb1 - xc1) * (xb1 + xc1) + (yb1 - yc1) * (yb1 + yc1);
				var xp1 = ka1 * (yb1 - yc1) - kb1 * (ya1 - yc1);
				var yp1 = kb1 * (xa1 - xc1) - ka1 * (xb1 - xc1);
				p_x1 = xp1 / d2;
				p_y1 = yp1 / d2;
				var dx2 = p_x1 - b.x;
				var dy2 = p_y1 - b.y;
				var dx3 = a.x - p_x1;
				var dy3 = a.y - p_y1;
				var in1 = !(dx2 * dx2 + dy2 * dy2 < dx3 * dx3 + dy3 * dy3);
				console.log("in0 " + (in0 == null ? "null" : "" + in0));
				console.log("in1 " + (in1 == null ? "null" : "" + in1));
				console.log("in_" + Std.string(in0 && in1));
				if(in0 && in1) {
					console.log("ensureDelaunayEdge " + j + " false ");
					out = false;
				} else {
					var _this = edges[j];
					var e = new triangulations_Edge(_this.p,_this.q);
					e.fixed = _this.fixed;
					e.external = _this.external;
					var edge1 = e;
					var coEdge1 = coEdges[j];
					var se = sideEdges[j];
					var j0 = se.a;
					var j1 = se.b;
					var j2 = se.c;
					var j3 = se.d;
					var _this1 = coEdges[j0];
					var y = coEdge1.q;
					if(_this1 != null) {
						if(_this1.p == edge1.p) {
							_this1.p = y;
						} else {
							_this1.p = y;
						}
					}
					se = sideEdges[j0];
					if(se != null) {
						if(j == se.a) {
							se.a = j1;
						} else if(j == se.b) {
							se.b = j1;
						} else if(j == se.c) {
							se.c = j1;
						} else {
							se.d = j1;
						}
					}
					if(se != null) {
						if(j3 == se.a) {
							se.a = j;
						} else if(j3 == se.b) {
							se.b = j;
						} else if(j3 == se.c) {
							se.c = j;
						} else {
							se.d = j;
						}
					}
					var _this2 = coEdges[j1];
					var y1 = coEdge1.p;
					if(_this2 != null) {
						if(_this2.p == edge1.p) {
							_this2.p = y1;
						} else {
							_this2.p = y1;
						}
					}
					se = sideEdges[j1];
					if(se != null) {
						if(j == se.a) {
							se.a = j0;
						} else if(j == se.b) {
							se.b = j0;
						} else if(j == se.c) {
							se.c = j0;
						} else {
							se.d = j0;
						}
					}
					if(se != null) {
						if(j2 == se.a) {
							se.a = j;
						} else if(j2 == se.b) {
							se.b = j;
						} else if(j2 == se.c) {
							se.c = j;
						} else {
							se.d = j;
						}
					}
					var _this3 = coEdges[j2];
					var y2 = coEdge1.p;
					if(_this3 != null) {
						if(_this3.p == edge1.q) {
							_this3.p = y2;
						} else {
							_this3.p = y2;
						}
					}
					se = sideEdges[j2];
					if(se != null) {
						if(j == se.a) {
							se.a = j3;
						} else if(j == se.b) {
							se.b = j3;
						} else if(j == se.c) {
							se.c = j3;
						} else {
							se.d = j3;
						}
					}
					if(se != null) {
						if(j1 == se.a) {
							se.a = j;
						} else if(j1 == se.b) {
							se.b = j;
						} else if(j1 == se.c) {
							se.c = j;
						} else {
							se.d = j;
						}
					}
					var _this4 = coEdges[j3];
					var y3 = coEdge1.q;
					if(_this4 != null) {
						if(_this4.p == edge1.q) {
							_this4.p = y3;
						} else {
							_this4.p = y3;
						}
					}
					se = sideEdges[j3];
					if(se != null) {
						if(j == se.a) {
							se.a = j2;
						} else if(j == se.b) {
							se.b = j2;
						} else if(j == se.c) {
							se.c = j2;
						} else {
							se.d = j2;
						}
					}
					if(se != null) {
						if(j0 == se.a) {
							se.a = j;
						} else if(j0 == se.b) {
							se.b = j;
						} else if(j0 == se.c) {
							se.c = j;
						} else {
							se.d = j;
						}
					}
					edges[j] = coEdges[j];
					coEdges[j] = edge1;
					var tmp = sideEdges[j].a;
					sideEdges[j].a = sideEdges[j].c;
					sideEdges[j].c = tmp;
					console.log("ensureDelaunayEdge " + j + " true ");
					out = true;
				}
				console.log(" ensureDelaunayEdge " + (out == null ? "null" : "" + out));
				var tmp1;
				if(!edges[j].fixed) {
					var out1;
					var edge2 = edges[j];
					var coEdge2 = coEdges[j];
					var a1 = vertices[edge2.p];
					var c1 = vertices[edge2.q];
					var b1 = vertices[coEdge2.p];
					var d3 = vertices[coEdge2.q];
					var p_y2;
					var p_x2;
					var xa2 = a1.x;
					var ya2 = a1.y;
					var xb2 = c1.x;
					var yb2 = c1.y;
					var xc2 = b1.x;
					var yc2 = b1.y;
					var d4 = 2 * ((xa2 - xc2) * (yb2 - yc2) - (xb2 - xc2) * (ya2 - yc2));
					var ka2 = (xa2 - xc2) * (xa2 + xc2) + (ya2 - yc2) * (ya2 + yc2);
					var kb2 = (xb2 - xc2) * (xb2 + xc2) + (yb2 - yc2) * (yb2 + yc2);
					var xp2 = ka2 * (yb2 - yc2) - kb2 * (ya2 - yc2);
					var yp2 = kb2 * (xa2 - xc2) - ka2 * (xb2 - xc2);
					p_x2 = xp2 / d4;
					p_y2 = yp2 / d4;
					var dx4 = p_x2 - d3.x;
					var dy4 = p_y2 - d3.y;
					var dx5 = a1.x - p_x2;
					var dy5 = a1.y - p_y2;
					var in01 = !(dx4 * dx4 + dy4 * dy4 < dx5 * dx5 + dy5 * dy5);
					var p_y3;
					var p_x3;
					var xa3 = a1.x;
					var ya3 = a1.y;
					var xb3 = c1.x;
					var yb3 = c1.y;
					var xc3 = d3.x;
					var yc3 = d3.y;
					var d5 = 2 * ((xa3 - xc3) * (yb3 - yc3) - (xb3 - xc3) * (ya3 - yc3));
					var ka3 = (xa3 - xc3) * (xa3 + xc3) + (ya3 - yc3) * (ya3 + yc3);
					var kb3 = (xb3 - xc3) * (xb3 + xc3) + (yb3 - yc3) * (yb3 + yc3);
					var xp3 = ka3 * (yb3 - yc3) - kb3 * (ya3 - yc3);
					var yp3 = kb3 * (xa3 - xc3) - ka3 * (xb3 - xc3);
					p_x3 = xp3 / d5;
					p_y3 = yp3 / d5;
					var dx6 = p_x3 - b1.x;
					var dy6 = p_y3 - b1.y;
					var dx7 = a1.x - p_x3;
					var dy7 = a1.y - p_y3;
					var in11 = !(dx6 * dx6 + dy6 * dy6 < dx7 * dx7 + dy7 * dy7);
					console.log("in0 " + (in01 == null ? "null" : "" + in01));
					console.log("in1 " + (in11 == null ? "null" : "" + in11));
					console.log("in_" + Std.string(in01 && in11));
					if(in01 && in11) {
						console.log("ensureDelaunayEdge " + j + " false ");
						out1 = false;
					} else {
						var _this5 = edges[j];
						var e1 = new triangulations_Edge(_this5.p,_this5.q);
						e1.fixed = _this5.fixed;
						e1.external = _this5.external;
						var edge3 = e1;
						var coEdge3 = coEdges[j];
						var se1 = sideEdges[j];
						var j01 = se1.a;
						var j11 = se1.b;
						var j21 = se1.c;
						var j31 = se1.d;
						var _this6 = coEdges[j01];
						var y4 = coEdge3.q;
						if(_this6 != null) {
							if(_this6.p == edge3.p) {
								_this6.p = y4;
							} else {
								_this6.p = y4;
							}
						}
						se1 = sideEdges[j01];
						if(se1 != null) {
							if(j == se1.a) {
								se1.a = j11;
							} else if(j == se1.b) {
								se1.b = j11;
							} else if(j == se1.c) {
								se1.c = j11;
							} else {
								se1.d = j11;
							}
						}
						if(se1 != null) {
							if(j31 == se1.a) {
								se1.a = j;
							} else if(j31 == se1.b) {
								se1.b = j;
							} else if(j31 == se1.c) {
								se1.c = j;
							} else {
								se1.d = j;
							}
						}
						var _this7 = coEdges[j11];
						var y5 = coEdge3.p;
						if(_this7 != null) {
							if(_this7.p == edge3.p) {
								_this7.p = y5;
							} else {
								_this7.p = y5;
							}
						}
						se1 = sideEdges[j11];
						if(se1 != null) {
							if(j == se1.a) {
								se1.a = j01;
							} else if(j == se1.b) {
								se1.b = j01;
							} else if(j == se1.c) {
								se1.c = j01;
							} else {
								se1.d = j01;
							}
						}
						if(se1 != null) {
							if(j21 == se1.a) {
								se1.a = j;
							} else if(j21 == se1.b) {
								se1.b = j;
							} else if(j21 == se1.c) {
								se1.c = j;
							} else {
								se1.d = j;
							}
						}
						var _this8 = coEdges[j21];
						var y6 = coEdge3.p;
						if(_this8 != null) {
							if(_this8.p == edge3.q) {
								_this8.p = y6;
							} else {
								_this8.p = y6;
							}
						}
						se1 = sideEdges[j21];
						if(se1 != null) {
							if(j == se1.a) {
								se1.a = j31;
							} else if(j == se1.b) {
								se1.b = j31;
							} else if(j == se1.c) {
								se1.c = j31;
							} else {
								se1.d = j31;
							}
						}
						if(se1 != null) {
							if(j11 == se1.a) {
								se1.a = j;
							} else if(j11 == se1.b) {
								se1.b = j;
							} else if(j11 == se1.c) {
								se1.c = j;
							} else {
								se1.d = j;
							}
						}
						var _this9 = coEdges[j31];
						var y7 = coEdge3.q;
						if(_this9 != null) {
							if(_this9.p == edge3.q) {
								_this9.p = y7;
							} else {
								_this9.p = y7;
							}
						}
						se1 = sideEdges[j31];
						if(se1 != null) {
							if(j == se1.a) {
								se1.a = j21;
							} else if(j == se1.b) {
								se1.b = j21;
							} else if(j == se1.c) {
								se1.c = j21;
							} else {
								se1.d = j21;
							}
						}
						if(se1 != null) {
							if(j01 == se1.a) {
								se1.a = j;
							} else if(j01 == se1.b) {
								se1.b = j;
							} else if(j01 == se1.c) {
								se1.c = j;
							} else {
								se1.d = j;
							}
						}
						edges[j] = coEdges[j];
						coEdges[j] = edge3;
						var tmp2 = sideEdges[j].a;
						sideEdges[j].a = sideEdges[j].c;
						sideEdges[j].c = tmp2;
						console.log("ensureDelaunayEdge " + j + " true ");
						out1 = true;
					}
					console.log(" ensureDelaunayEdge " + (out1 == null ? "null" : "" + out1));
					tmp1 = !out1;
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					var newUnsureCnt = 0;
					var _g2 = sideEdges[j];
					while(_g2.count < _g2.length) {
						var out2;
						var _g3 = _g2.count;
						switch(_g3) {
						case 0:
							out2 = _g2.a;
							break;
						case 1:
							out2 = _g2.b;
							break;
						case 2:
							out2 = _g2.c;
							break;
						case 3:
							out2 = _g2.d;
							break;
						default:
							out2 = _g2.a;
						}
						_g2.count++;
						var jk = out2;
						if(!unsure[jk]) {
							if(tried[jk] != cookie) {
								triedEdges.push(jk);
								tried[jk] = cookie;
							}
							if(!edges[jk].fixed) {
								unsureEdges.push(jk);
								unsure[jk] = true;
								++newUnsureCnt;
							}
						}
					}
				}
			}
			return triedEdges;
		};
	}
	return triangulations_Triangulate._delaunay;
};
triangulations_Triangulate.delaunayReset = function() {
	triangulations_Triangulate._delaunay = null;
	return triangulations_Triangulate.get_delaunay();
};
triangulations_Triangulate.maintainDelaunay = function() {
	var unsure = [];
	var tried = [];
	var cookie = 0;
	return function(vertices,edges,coEdges,sideEdges,unsureEdges) {
		cookie += 1;
		var triedEdges = unsureEdges.slice(0);
		var _g1 = 0;
		var _g = unsureEdges.length;
		while(_g1 < _g) {
			var l = _g1++;
			unsure[unsureEdges[l]] = true;
			tried[unsureEdges[l]] = cookie;
		}
		while(unsureEdges.length > 0) {
			var j = unsureEdges.pop();
			unsure[j] = false;
			var out;
			var edge = edges[j];
			var coEdge = coEdges[j];
			var a = vertices[edge.p];
			var c = vertices[edge.q];
			var b = vertices[coEdge.p];
			var d = vertices[coEdge.q];
			var p_y;
			var p_x;
			var xa = a.x;
			var ya = a.y;
			var xb = c.x;
			var yb = c.y;
			var xc = b.x;
			var yc = b.y;
			var d1 = 2 * ((xa - xc) * (yb - yc) - (xb - xc) * (ya - yc));
			var ka = (xa - xc) * (xa + xc) + (ya - yc) * (ya + yc);
			var kb = (xb - xc) * (xb + xc) + (yb - yc) * (yb + yc);
			var xp = ka * (yb - yc) - kb * (ya - yc);
			var yp = kb * (xa - xc) - ka * (xb - xc);
			p_x = xp / d1;
			p_y = yp / d1;
			var dx = p_x - d.x;
			var dy = p_y - d.y;
			var dx1 = a.x - p_x;
			var dy1 = a.y - p_y;
			var in0 = !(dx * dx + dy * dy < dx1 * dx1 + dy1 * dy1);
			var p_y1;
			var p_x1;
			var xa1 = a.x;
			var ya1 = a.y;
			var xb1 = c.x;
			var yb1 = c.y;
			var xc1 = d.x;
			var yc1 = d.y;
			var d2 = 2 * ((xa1 - xc1) * (yb1 - yc1) - (xb1 - xc1) * (ya1 - yc1));
			var ka1 = (xa1 - xc1) * (xa1 + xc1) + (ya1 - yc1) * (ya1 + yc1);
			var kb1 = (xb1 - xc1) * (xb1 + xc1) + (yb1 - yc1) * (yb1 + yc1);
			var xp1 = ka1 * (yb1 - yc1) - kb1 * (ya1 - yc1);
			var yp1 = kb1 * (xa1 - xc1) - ka1 * (xb1 - xc1);
			p_x1 = xp1 / d2;
			p_y1 = yp1 / d2;
			var dx2 = p_x1 - b.x;
			var dy2 = p_y1 - b.y;
			var dx3 = a.x - p_x1;
			var dy3 = a.y - p_y1;
			var in1 = !(dx2 * dx2 + dy2 * dy2 < dx3 * dx3 + dy3 * dy3);
			console.log("in0 " + (in0 == null ? "null" : "" + in0));
			console.log("in1 " + (in1 == null ? "null" : "" + in1));
			console.log("in_" + Std.string(in0 && in1));
			if(in0 && in1) {
				console.log("ensureDelaunayEdge " + j + " false ");
				out = false;
			} else {
				var _this = edges[j];
				var e = new triangulations_Edge(_this.p,_this.q);
				e.fixed = _this.fixed;
				e.external = _this.external;
				var edge1 = e;
				var coEdge1 = coEdges[j];
				var se = sideEdges[j];
				var j0 = se.a;
				var j1 = se.b;
				var j2 = se.c;
				var j3 = se.d;
				var _this1 = coEdges[j0];
				var y = coEdge1.q;
				if(_this1 != null) {
					if(_this1.p == edge1.p) {
						_this1.p = y;
					} else {
						_this1.p = y;
					}
				}
				se = sideEdges[j0];
				if(se != null) {
					if(j == se.a) {
						se.a = j1;
					} else if(j == se.b) {
						se.b = j1;
					} else if(j == se.c) {
						se.c = j1;
					} else {
						se.d = j1;
					}
				}
				if(se != null) {
					if(j3 == se.a) {
						se.a = j;
					} else if(j3 == se.b) {
						se.b = j;
					} else if(j3 == se.c) {
						se.c = j;
					} else {
						se.d = j;
					}
				}
				var _this2 = coEdges[j1];
				var y1 = coEdge1.p;
				if(_this2 != null) {
					if(_this2.p == edge1.p) {
						_this2.p = y1;
					} else {
						_this2.p = y1;
					}
				}
				se = sideEdges[j1];
				if(se != null) {
					if(j == se.a) {
						se.a = j0;
					} else if(j == se.b) {
						se.b = j0;
					} else if(j == se.c) {
						se.c = j0;
					} else {
						se.d = j0;
					}
				}
				if(se != null) {
					if(j2 == se.a) {
						se.a = j;
					} else if(j2 == se.b) {
						se.b = j;
					} else if(j2 == se.c) {
						se.c = j;
					} else {
						se.d = j;
					}
				}
				var _this3 = coEdges[j2];
				var y2 = coEdge1.p;
				if(_this3 != null) {
					if(_this3.p == edge1.q) {
						_this3.p = y2;
					} else {
						_this3.p = y2;
					}
				}
				se = sideEdges[j2];
				if(se != null) {
					if(j == se.a) {
						se.a = j3;
					} else if(j == se.b) {
						se.b = j3;
					} else if(j == se.c) {
						se.c = j3;
					} else {
						se.d = j3;
					}
				}
				if(se != null) {
					if(j1 == se.a) {
						se.a = j;
					} else if(j1 == se.b) {
						se.b = j;
					} else if(j1 == se.c) {
						se.c = j;
					} else {
						se.d = j;
					}
				}
				var _this4 = coEdges[j3];
				var y3 = coEdge1.q;
				if(_this4 != null) {
					if(_this4.p == edge1.q) {
						_this4.p = y3;
					} else {
						_this4.p = y3;
					}
				}
				se = sideEdges[j3];
				if(se != null) {
					if(j == se.a) {
						se.a = j2;
					} else if(j == se.b) {
						se.b = j2;
					} else if(j == se.c) {
						se.c = j2;
					} else {
						se.d = j2;
					}
				}
				if(se != null) {
					if(j0 == se.a) {
						se.a = j;
					} else if(j0 == se.b) {
						se.b = j;
					} else if(j0 == se.c) {
						se.c = j;
					} else {
						se.d = j;
					}
				}
				edges[j] = coEdges[j];
				coEdges[j] = edge1;
				var tmp = sideEdges[j].a;
				sideEdges[j].a = sideEdges[j].c;
				sideEdges[j].c = tmp;
				console.log("ensureDelaunayEdge " + j + " true ");
				out = true;
			}
			console.log(" ensureDelaunayEdge " + (out == null ? "null" : "" + out));
			var tmp1;
			if(!edges[j].fixed) {
				var out1;
				var edge2 = edges[j];
				var coEdge2 = coEdges[j];
				var a1 = vertices[edge2.p];
				var c1 = vertices[edge2.q];
				var b1 = vertices[coEdge2.p];
				var d3 = vertices[coEdge2.q];
				var p_y2;
				var p_x2;
				var xa2 = a1.x;
				var ya2 = a1.y;
				var xb2 = c1.x;
				var yb2 = c1.y;
				var xc2 = b1.x;
				var yc2 = b1.y;
				var d4 = 2 * ((xa2 - xc2) * (yb2 - yc2) - (xb2 - xc2) * (ya2 - yc2));
				var ka2 = (xa2 - xc2) * (xa2 + xc2) + (ya2 - yc2) * (ya2 + yc2);
				var kb2 = (xb2 - xc2) * (xb2 + xc2) + (yb2 - yc2) * (yb2 + yc2);
				var xp2 = ka2 * (yb2 - yc2) - kb2 * (ya2 - yc2);
				var yp2 = kb2 * (xa2 - xc2) - ka2 * (xb2 - xc2);
				p_x2 = xp2 / d4;
				p_y2 = yp2 / d4;
				var dx4 = p_x2 - d3.x;
				var dy4 = p_y2 - d3.y;
				var dx5 = a1.x - p_x2;
				var dy5 = a1.y - p_y2;
				var in01 = !(dx4 * dx4 + dy4 * dy4 < dx5 * dx5 + dy5 * dy5);
				var p_y3;
				var p_x3;
				var xa3 = a1.x;
				var ya3 = a1.y;
				var xb3 = c1.x;
				var yb3 = c1.y;
				var xc3 = d3.x;
				var yc3 = d3.y;
				var d5 = 2 * ((xa3 - xc3) * (yb3 - yc3) - (xb3 - xc3) * (ya3 - yc3));
				var ka3 = (xa3 - xc3) * (xa3 + xc3) + (ya3 - yc3) * (ya3 + yc3);
				var kb3 = (xb3 - xc3) * (xb3 + xc3) + (yb3 - yc3) * (yb3 + yc3);
				var xp3 = ka3 * (yb3 - yc3) - kb3 * (ya3 - yc3);
				var yp3 = kb3 * (xa3 - xc3) - ka3 * (xb3 - xc3);
				p_x3 = xp3 / d5;
				p_y3 = yp3 / d5;
				var dx6 = p_x3 - b1.x;
				var dy6 = p_y3 - b1.y;
				var dx7 = a1.x - p_x3;
				var dy7 = a1.y - p_y3;
				var in11 = !(dx6 * dx6 + dy6 * dy6 < dx7 * dx7 + dy7 * dy7);
				console.log("in0 " + (in01 == null ? "null" : "" + in01));
				console.log("in1 " + (in11 == null ? "null" : "" + in11));
				console.log("in_" + Std.string(in01 && in11));
				if(in01 && in11) {
					console.log("ensureDelaunayEdge " + j + " false ");
					out1 = false;
				} else {
					var _this5 = edges[j];
					var e1 = new triangulations_Edge(_this5.p,_this5.q);
					e1.fixed = _this5.fixed;
					e1.external = _this5.external;
					var edge3 = e1;
					var coEdge3 = coEdges[j];
					var se1 = sideEdges[j];
					var j01 = se1.a;
					var j11 = se1.b;
					var j21 = se1.c;
					var j31 = se1.d;
					var _this6 = coEdges[j01];
					var y4 = coEdge3.q;
					if(_this6 != null) {
						if(_this6.p == edge3.p) {
							_this6.p = y4;
						} else {
							_this6.p = y4;
						}
					}
					se1 = sideEdges[j01];
					if(se1 != null) {
						if(j == se1.a) {
							se1.a = j11;
						} else if(j == se1.b) {
							se1.b = j11;
						} else if(j == se1.c) {
							se1.c = j11;
						} else {
							se1.d = j11;
						}
					}
					if(se1 != null) {
						if(j31 == se1.a) {
							se1.a = j;
						} else if(j31 == se1.b) {
							se1.b = j;
						} else if(j31 == se1.c) {
							se1.c = j;
						} else {
							se1.d = j;
						}
					}
					var _this7 = coEdges[j11];
					var y5 = coEdge3.p;
					if(_this7 != null) {
						if(_this7.p == edge3.p) {
							_this7.p = y5;
						} else {
							_this7.p = y5;
						}
					}
					se1 = sideEdges[j11];
					if(se1 != null) {
						if(j == se1.a) {
							se1.a = j01;
						} else if(j == se1.b) {
							se1.b = j01;
						} else if(j == se1.c) {
							se1.c = j01;
						} else {
							se1.d = j01;
						}
					}
					if(se1 != null) {
						if(j21 == se1.a) {
							se1.a = j;
						} else if(j21 == se1.b) {
							se1.b = j;
						} else if(j21 == se1.c) {
							se1.c = j;
						} else {
							se1.d = j;
						}
					}
					var _this8 = coEdges[j21];
					var y6 = coEdge3.p;
					if(_this8 != null) {
						if(_this8.p == edge3.q) {
							_this8.p = y6;
						} else {
							_this8.p = y6;
						}
					}
					se1 = sideEdges[j21];
					if(se1 != null) {
						if(j == se1.a) {
							se1.a = j31;
						} else if(j == se1.b) {
							se1.b = j31;
						} else if(j == se1.c) {
							se1.c = j31;
						} else {
							se1.d = j31;
						}
					}
					if(se1 != null) {
						if(j11 == se1.a) {
							se1.a = j;
						} else if(j11 == se1.b) {
							se1.b = j;
						} else if(j11 == se1.c) {
							se1.c = j;
						} else {
							se1.d = j;
						}
					}
					var _this9 = coEdges[j31];
					var y7 = coEdge3.q;
					if(_this9 != null) {
						if(_this9.p == edge3.q) {
							_this9.p = y7;
						} else {
							_this9.p = y7;
						}
					}
					se1 = sideEdges[j31];
					if(se1 != null) {
						if(j == se1.a) {
							se1.a = j21;
						} else if(j == se1.b) {
							se1.b = j21;
						} else if(j == se1.c) {
							se1.c = j21;
						} else {
							se1.d = j21;
						}
					}
					if(se1 != null) {
						if(j01 == se1.a) {
							se1.a = j;
						} else if(j01 == se1.b) {
							se1.b = j;
						} else if(j01 == se1.c) {
							se1.c = j;
						} else {
							se1.d = j;
						}
					}
					edges[j] = coEdges[j];
					coEdges[j] = edge3;
					var tmp2 = sideEdges[j].a;
					sideEdges[j].a = sideEdges[j].c;
					sideEdges[j].c = tmp2;
					console.log("ensureDelaunayEdge " + j + " true ");
					out1 = true;
				}
				console.log(" ensureDelaunayEdge " + (out1 == null ? "null" : "" + out1));
				tmp1 = !out1;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var newUnsureCnt = 0;
				var _g2 = sideEdges[j];
				while(_g2.count < _g2.length) {
					var out2;
					var _g3 = _g2.count;
					switch(_g3) {
					case 0:
						out2 = _g2.a;
						break;
					case 1:
						out2 = _g2.b;
						break;
					case 2:
						out2 = _g2.c;
						break;
					case 3:
						out2 = _g2.d;
						break;
					default:
						out2 = _g2.a;
					}
					_g2.count++;
					var jk = out2;
					if(!unsure[jk]) {
						if(tried[jk] != cookie) {
							triedEdges.push(jk);
							tried[jk] = cookie;
						}
						if(!edges[jk].fixed) {
							unsureEdges.push(jk);
							unsure[jk] = true;
							++newUnsureCnt;
						}
					}
				}
			}
		}
		return triedEdges;
	};
};
var triangulations__$Vertices_Vertices_$Impl_$ = {};
triangulations__$Vertices_Vertices_$Impl_$.__name__ = true;
triangulations__$Vertices_Vertices_$Impl_$._new = function(v) {
	var this1;
	if(v == null) {
		v = triangulations__$Vertices_Vertices_$Impl_$._new([]);
	}
	this1 = v;
	return this1;
};
triangulations__$Vertices_Vertices_$Impl_$.getEmpty = function() {
	return triangulations__$Vertices_Vertices_$Impl_$._new([]);
};
triangulations__$Vertices_Vertices_$Impl_$.scale = function(this1,f) {
	var l = this1.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var _this = this1[i];
		this1[i] = new khaMath_Vector2(_this.x * f,_this.y * f);
	}
};
triangulations__$Vertices_Vertices_$Impl_$.translate = function(this1,x,y) {
	var t_y;
	var t_x = x;
	t_y = y;
	var l = this1.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var _this = this1[i];
		this1[i] = new khaMath_Vector2(_this.x + t_x,_this.y + t_y);
	}
};
triangulations__$Vertices_Vertices_$Impl_$.polygonOrientation = function(this1,poly) {
	var area = 0.;
	var l = poly.length;
	var v = this1[poly[l - 1]];
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var u = v;
		v = this1[poly[i]];
		area += (u.x + v.x) * (u.y - v.y);
	}
	if(area > 0) {
		return 1;
	} else if(area < 0) {
		return -1;
	} else {
		return 0;
	}
};
triangulations__$Vertices_Vertices_$Impl_$.pointInPolygon = function(this1,poly,w) {
	var l = poly.length;
	var v = this1[poly[l - 1]];
	var result = false;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var u = v;
		v = this1[poly[i]];
		if(u.y == v.y) {
			var wux = w.x - u.x;
			if(u.y == w.y && wux * wux <= 0) {
				return false;
			}
			continue;
		} else {
			var u1 = u;
			var v1 = v;
			var y = w.y;
			var val;
			if(u1.y > v1.y) {
				var tmp = u1;
				u1 = v1;
				v1 = tmp;
			}
			if(y <= u1.y || v1.y < y) {
				val = null;
			} else {
				var t = (y - u1.y) / (v1.y - u1.y);
				val = u1.x + t * (v1.x - u1.x);
			}
			var x = val;
			if(x != null && w.x > x) {
				result = !result;
			}
		}
	}
	return result;
};
triangulations__$Vertices_Vertices_$Impl_$.clone = function(this1) {
	var v = triangulations__$Vertices_Vertices_$Impl_$._new([]);
	var l = this1.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		v[i] = new khaMath_Vector2(this1[i].x,this1[i].y);
	}
	return v;
};
triangulations__$Vertices_Vertices_$Impl_$.fitClone = function(this1,width,height,margin) {
	if(margin == null) {
		margin = 10;
	}
	var v = triangulations__$Vertices_Vertices_$Impl_$._new([]);
	var l = this1.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		v[i] = new khaMath_Vector2(this1[i].x,this1[i].y);
	}
	var v1 = v;
	var xMin = Infinity;
	var xMax = -Infinity;
	var yMin = Infinity;
	var yMax = -Infinity;
	var l1 = this1.length;
	var _g11 = 0;
	var _g2 = this1.length;
	while(_g11 < _g2) {
		var i1 = _g11++;
		var v2 = this1[i1];
		var x = v2.x;
		var y = v2.y;
		xMin = Math.min(x,xMin);
		xMax = Math.max(x,xMax);
		yMin = Math.min(y,yMin);
		yMax = Math.max(y,yMax);
	}
	var xdif = xMax - xMin;
	var ydif = yMax - yMin;
	var scaleX = (width - 2 * margin) / xdif;
	var scaleY = (height - 2 * margin) / ydif;
	var scale = Math.min(scaleX,scaleY);
	var marginX = (width - scale * xdif) / 2;
	var marginY = (height - scale * ydif) / 2;
	var _g12 = 0;
	var _g3 = this1.length;
	while(_g12 < _g3) {
		var i2 = _g12++;
		var v3 = this1[i2];
		v3.x = marginX + scale * (v3.x - xMin);
		v3.y = marginY + scale * (v3.y - yMin);
	}
	return v1;
};
triangulations__$Vertices_Vertices_$Impl_$.fit = function(this1,width,height,margin) {
	if(margin == null) {
		margin = 10;
	}
	var xMin = Infinity;
	var xMax = -Infinity;
	var yMin = Infinity;
	var yMax = -Infinity;
	var l = this1.length;
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		var v = this1[i];
		var x = v.x;
		var y = v.y;
		xMin = Math.min(x,xMin);
		xMax = Math.max(x,xMax);
		yMin = Math.min(y,yMin);
		yMax = Math.max(y,yMax);
	}
	var xdif = xMax - xMin;
	var ydif = yMax - yMin;
	var scaleX = (width - 2 * margin) / xdif;
	var scaleY = (height - 2 * margin) / ydif;
	var scale = Math.min(scaleX,scaleY);
	var marginX = (width - scale * xdif) / 2;
	var marginY = (height - scale * ydif) / 2;
	var _g11 = 0;
	var _g2 = this1.length;
	while(_g11 < _g2) {
		var i1 = _g11++;
		var v1 = this1[i1];
		v1.x = marginX + scale * (v1.x - xMin);
		v1.y = marginY + scale * (v1.y - yMin);
	}
};
triangulations__$Vertices_Vertices_$Impl_$.fromArrayArray = function(arr) {
	var v = triangulations__$Vertices_Vertices_$Impl_$._new([]);
	var arr2;
	var l = arr.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		arr2 = arr[i];
		v[i] = new khaMath_Vector2(arr2[0],arr2[1]);
	}
	return v;
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var Float32Array = $global.Float32Array || js_html_compat_Float32Array._new;
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
js_Boot.__toStr = ({ }).toString;
js_html_compat_Float32Array.BYTES_PER_ELEMENT = 4;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
justTriangles_Draw.circleSides = 60;
justTriangles_PathContext.circleSides = 60;
justTriangles_PolyK.small = 0.0000000001;
justTriangles_ShapePoints.quadStep = 0.03;
justTriangles_ShapePoints.cubicStep = 0.03;
justTriangles_Triangle.triangles = [];
justTrianglesWebGL_Shader.vertex = "attribute vec3 pos;" + "attribute vec4 color;" + "varying vec4 vcol;" + "uniform mat4 modelViewProjection;" + "void main(void) {" + " gl_Position = modelViewProjection * vec4(pos, 1.0);" + " vcol = color;" + "}";
justTrianglesWebGL_Shader.fragment = "precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}";
khaMath_Matrix4.width = 4;
khaMath_Matrix4.height = 4;
tests_MainTestSetup.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
